<?xml version="1.0" encoding="UTF-8"?>
<!-- This software is in the public domain under CC0 1.0 Universal plus a 
     Grant of Patent License.

     To the extent possible under law, the author(s) have dedicated all
     copyright and related and neighboring rights to this software to the
     public domain worldwide. This software is distributed without any warranty.

     You should have received a copy of the CC0 Public Domain Dedication
     along with this software (see the LICENSE.md file). If not, see
     <https://creativecommons.org/publicdomain/zero/1.0/>. -->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- MCP Entity Tools -->
    
    <service verb="execute" noun="EntityTool" authenticate="false" transaction-timeout="300">
        <description>Execute entity-related MCP tool</description>
        <in-parameters>
            <parameter name="sessionId" type="id" required="true"/>
            <parameter name="toolName" type="text-medium" required="true"/>
            <parameter name="parameters" type="Map" required="true"/>
            <parameter name="toolCallId" type="id"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="text-very-long"/>
            <parameter name="success" type="text-indicator"/>
            <parameter name="errorMessage" type="text-long"/>
            <parameter name="entityName" type="text-medium"/>
            <parameter name="recordCount" type="number-integer"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                import groovy.json.JsonSlurper
                
                ExecutionContext ec = context.ec
                
                // Get session information
                def session = ec.entity.find("McpSession")
                    .condition("sessionId", sessionId)
                    .one()
                if (!session) {
                    success = "N"
                    errorMessage = "Invalid session"
                    return
                }
                
                // Set user context
                ec.user.setUserIdByToken(session.userAccountId)
                
                def result = null
                try {
                    switch (toolName) {
                        case "entity_find":
                            result = executeEntityFind(parameters, session.userAccountId, toolCallId)
                            break
                        case "entity_find_one":
                            result = executeEntityFindOne(parameters, session.userAccountId, toolCallId)
                            break
                        case "entity_create":
                            result = executeEntityCreate(parameters, session.userAccountId, toolCallId)
                            break
                        case "entity_update":
                            result = executeEntityUpdate(parameters, session.userAccountId, toolCallId)
                            break
                        case "entity_delete":
                            result = executeEntityDelete(parameters, session.userAccountId, toolCallId)
                            break
                        case "entity_count":
                            result = executeEntityCount(parameters, session.userAccountId, toolCallId)
                            break
                        case "entity_describe":
                            result = executeEntityDescribe(parameters, session.userAccountId, toolCallId)
                            break
                        case "entity_list":
                            result = executeEntityList(parameters, session.userAccountId, toolCallId)
                            break
                        default:
                            result = [success: "N", errorMessage: "Unknown entity tool: ${toolName}"]
                    }
                } catch (Exception e) {
                    result = [success: "N", errorMessage: "Error executing entity tool ${toolName}: ${e.message}"]
                    ec.logger.error("Entity tool execution error", e)
                }
                
                success = result.success
                errorMessage = result.errorMessage
                entityName = result.entityName
                recordCount = result.recordCount
                result = result.result
            ]]></script>
        </actions>
    </service>

    <!-- Entity Tool Implementations -->
    
    <script><![CDATA[
        def executeEntityFind(Map parameters, String userAccountId, String toolCallId) {
            def ec = context.ec
            
            def entityName = parameters.entityName
            def condition = parameters.condition
            def orderBy = parameters.orderBy
            def limit = parameters.limit ?: 100
            def offset = parameters.offset ?: 0
            def fields = parameters.fields
            def useCache = parameters.useCache != "N"
            
            if (!entityName) {
                return [success: "N", errorMessage: "entityName parameter required"]
            }
            
            // Validate entity access
            def accessCheck = ec.service.sync("org.moqui.mcp.McpSecurityServices.validate#EntityAccess", [
                entityName: entityName,
                userAccountId: userAccountId,
                operation: "VIEW"
            ])
            
            if (accessCheck.allowed != "Y") {
                return [success: "N", errorMessage: accessCheck.reason]
            }
            
            try {
                def findBuilder = ec.entity.find(entityName)
                
                // Apply conditions
                if (condition) {
                    for (entry in condition) {
                        if (entry.value instanceof Map && entry.value.containsKey("value")) {
                            def conditionMap = entry.value
                            def operator = conditionMap.operator ?: "equals"
                            def value = conditionMap.value
                            findBuilder.condition(entry.key, value, operator)
                        } else {
                            findBuilder.condition(entry.key, entry.value)
                        }
                    }
                }
                
                // Apply ordering
                if (orderBy) {
                    if (orderBy instanceof List) {
                        findBuilder.orderBy(orderBy.join(", "))
                    } else {
                        findBuilder.orderBy(orderBy)
                    }
                }
                
                // Apply pagination
                findBuilder.offset(offset)
                findBuilder.limit(limit)
                
                // Apply cache setting
                findBuilder.useCache(useCache)
                
                // Select specific fields if specified
                if (fields) {
                    if (fields instanceof List) {
                        findBuilder.selectFields(fields as String[])
                    } else {
                        findBuilder.selectFields(fields.split(","))
                    }
                }
                
                // Execute query
                def resultList = findBuilder.list()
                def count = findBuilder.count()
                
                // Convert to JSON-safe format
                def jsonResult = [
                    entityName: entityName,
                    records: resultList.collect { it.getMap() },
                    count: count,
                    limit: limit,
                    offset: offset,
                    hasMore: (offset + resultList.size()) < count
                ]
                
                return [
                    success: "Y",
                    result: new JsonBuilder(jsonResult).toString(),
                    entityName: entityName,
                    recordCount: resultList.size()
                ]
                
            } catch (Exception e) {
                return [success: "N", errorMessage: "Error finding entities: ${e.message}"]
            }
        }
        
        def executeEntityFindOne(Map parameters, String userAccountId, String toolCallId) {
            def ec = context.ec
            
            def entityName = parameters.entityName
            def condition = parameters.condition
            def fields = parameters.fields
            def useCache = parameters.useCache != "N"
            
            if (!entityName) {
                return [success: "N", errorMessage: "entityName parameter required"]
            }
            
            if (!condition) {
                return [success: "N", errorMessage: "condition parameter required for find_one"]
            }
            
            // Validate entity access
            def accessCheck = ec.service.sync("org.moqui.mcp.McpSecurityServices.validate#EntityAccess", [
                entityName: entityName,
                userAccountId: userAccountId,
                operation: "VIEW"
            ])
            
            if (accessCheck.allowed != "Y") {
                return [success: "N", errorMessage: accessCheck.reason]
            }
            
            try {
                def findBuilder = ec.entity.find(entityName)
                
                // Apply conditions
                for (entry in condition) {
                    if (entry.value instanceof Map && entry.value.containsKey("value")) {
                        def conditionMap = entry.value
                        def operator = conditionMap.operator ?: "equals"
                        def value = conditionMap.value
                        findBuilder.condition(entry.key, value, operator)
                    } else {
                        findBuilder.condition(entry.key, entry.value)
                    }
                }
                
                // Apply cache setting
                findBuilder.useCache(useCache)
                
                // Select specific fields if specified
                if (fields) {
                    if (fields instanceof List) {
                        findBuilder.selectFields(fields as String[])
                    } else {
                        findBuilder.selectFields(fields.split(","))
                    }
                }
                
                // Execute query
                def record = findBuilder.one()
                
                def jsonResult = [
                    entityName: entityName,
                    record: record ? record.getMap() : null,
                    found: record != null
                ]
                
                return [
                    success: "Y",
                    result: new JsonBuilder(jsonResult).toString(),
                    entityName: entityName,
                    recordCount: record ? 1 : 0
                ]
                
            } catch (Exception e) {
                return [success: "N", errorMessage: "Error finding entity: ${e.message}"]
            }
        }
        
        def executeEntityCreate(Map parameters, String userAccountId, String toolCallId) {
            def ec = context.ec
            
            def entityName = parameters.entityName
            def fields = parameters.fields
            def createOnlyIfNotExists = parameters.createOnlyIfNotExists == "Y"
            
            if (!entityName) {
                return [success: "N", errorMessage: "entityName parameter required"]
            }
            
            if (!fields) {
                return [success: "N", errorMessage: "fields parameter required for create"]
            }
            
            // Validate entity access
            def accessCheck = ec.service.sync("org.moqui.mcp.McpSecurityServices.validate#EntityAccess", [
                entityName: entityName,
                userAccountId: userAccountId,
                operation: "CREATE"
            ])
            
            if (accessCheck.allowed != "Y") {
                return [success: "N", errorMessage: accessCheck.reason]
            }
            
            try {
                def entity = ec.entity.makeValue(entityName)
                
                // Set field values
                for (entry in fields) {
                    entity.set(entry.key, entry.value)
                }
                
                // Check if record already exists (if requested)
                if (createOnlyIfNotExists) {
                    def pkMap = entity.getPrimaryKeys()
                    def existing = ec.entity.find(entityName)
                        .condition(pkMap)
                        .one()
                    
                    if (existing) {
                        def jsonResult = [
                            entityName: entityName,
                            created: false,
                            reason: "Record already exists",
                            existingRecord: existing.getMap()
                        ]
                        
                        return [
                            success: "Y",
                            result: new JsonBuilder(jsonResult).toString(),
                            entityName: entityName,
                            recordCount: 0
                        ]
                    }
                }
                
                // Create the record
                entity.create()
                
                def jsonResult = [
                    entityName: entityName,
                    created: true,
                    record: entity.getMap()
                ]
                
                // Log entity creation
                ec.service.async("org.moqui.mcp.McpSecurityServices.log#AuditEvent", [
                    toolCallId: toolCallId,
                    userAccountId: userAccountId,
                    eventType: "McpEventToolCompleted",
                    eventDetail: "Entity created: ${entityName}",
                    entityName: entityName,
                    recordId: entity.getPrimaryKeys().values().first(),
                    newValues: new JsonBuilder(fields).toString(),
                    severity: "McpSeverityInfo"
                ])
                
                return [
                    success: "Y",
                    result: new JsonBuilder(jsonResult).toString(),
                    entityName: entityName,
                    recordCount: 1
                ]
                
            } catch (Exception e) {
                return [success: "N", errorMessage: "Error creating entity: ${e.message}"]
            }
        }
        
        def executeEntityUpdate(Map parameters, String userAccountId, String toolCallId) {
            def ec = context.ec
            
            def entityName = parameters.entityName
            def condition = parameters.condition
            def fields = parameters.fields
            def updateOnlyIfChanged = parameters.updateOnlyIfChanged == "Y"
            
            if (!entityName) {
                return [success: "N", errorMessage: "entityName parameter required"]
            }
            
            if (!condition) {
                return [success: "N", errorMessage: "condition parameter required for update"]
            }
            
            if (!fields) {
                return [success: "N", errorMessage: "fields parameter required for update"]
            }
            
            // Validate entity access
            def accessCheck = ec.service.sync("org.moqui.mcp.McpSecurityServices.validate#EntityAccess", [
                entityName: entityName,
                userAccountId: userAccountId,
                operation: "UPDATE"
            ])
            
            if (accessCheck.allowed != "Y") {
                return [success: "N", errorMessage: accessCheck.reason]
            }
            
            try {
                def findBuilder = ec.entity.find(entityName)
                
                // Apply conditions
                for (entry in condition) {
                    if (entry.value instanceof Map && entry.value.containsKey("value")) {
                        def conditionMap = entry.value
                        def operator = conditionMap.operator ?: "equals"
                        def value = conditionMap.value
                        findBuilder.condition(entry.key, value, operator)
                    } else {
                        findBuilder.condition(entry.key, entry.value)
                    }
                }
                
                // Find records to update
                def records = findBuilder.list()
                
                if (records.isEmpty()) {
                    def jsonResult = [
                        entityName: entityName,
                        updated: false,
                        reason: "No records found matching condition",
                        recordsUpdated: 0
                    ]
                    
                    return [
                        success: "Y",
                        result: new JsonBuilder(jsonResult).toString(),
                        entityName: entityName,
                        recordCount: 0
                    ]
                }
                
                def updatedRecords = []
                def recordsUpdated = 0
                
                for (record in records) {
                    def oldValues = record.getMap()
                    
                    // Check if values have changed (if requested)
                    if (updateOnlyIfChanged) {
                        def hasChanges = false
                        for (entry in fields) {
                            def oldValue = record.get(entry.key)
                            def newValue = entry.value
                            if (oldValue != newValue) {
                                hasChanges = true
                                break
                            }
                        }
                        if (!hasChanges) {
                            continue
                        }
                    }
                    
                    // Update field values
                    for (entry in fields) {
                        record.set(entry.key, entry.value)
                    }
                    
                    record.update()
                    updatedRecords << record.getMap()
                    recordsUpdated++
                    
                    // Log update
                    ec.service.async("org.moqui.mcp.McpSecurityServices.log#AuditEvent", [
                        toolCallId: toolCallId,
                        userAccountId: userAccountId,
                        eventType: "McpEventToolCompleted",
                        eventDetail: "Entity updated: ${entityName}",
                        entityName: entityName,
                        recordId: record.getPrimaryKeys().values().first(),
                        oldValues: new JsonBuilder(oldValues).toString(),
                        newValues: new JsonBuilder(fields).toString(),
                        severity: "McpSeverityInfo"
                    ])
                }
                
                def jsonResult = [
                    entityName: entityName,
                    updated: true,
                    recordsUpdated: recordsUpdated,
                    records: updatedRecords
                ]
                
                return [
                    success: "Y",
                    result: new JsonBuilder(jsonResult).toString(),
                    entityName: entityName,
                    recordCount: recordsUpdated
                ]
                
            } catch (Exception e) {
                return [success: "N", errorMessage: "Error updating entities: ${e.message}"]
            }
        }
        
        def executeEntityDelete(Map parameters, String userAccountId, String toolCallId) {
            def ec = context.ec
            
            def entityName = parameters.entityName
            def condition = parameters.condition
            
            if (!entityName) {
                return [success: "N", errorMessage: "entityName parameter required"]
            }
            
            if (!condition) {
                return [success: "N", errorMessage: "condition parameter required for delete"]
            }
            
            // Validate entity access
            def accessCheck = ec.service.sync("org.moqui.mcp.McpSecurityServices.validate#EntityAccess", [
                entityName: entityName,
                userAccountId: userAccountId,
                operation: "DELETE"
            ])
            
            if (accessCheck.allowed != "Y") {
                return [success: "N", errorMessage: accessCheck.reason]
            }
            
            try {
                def findBuilder = ec.entity.find(entityName)
                
                // Apply conditions
                for (entry in condition) {
                    if (entry.value instanceof Map && entry.value.containsKey("value")) {
                        def conditionMap = entry.value
                        def operator = conditionMap.operator ?: "equals"
                        def value = conditionMap.value
                        findBuilder.condition(entry.key, value, operator)
                    } else {
                        findBuilder.condition(entry.key, entry.value)
                    }
                }
                
                // Find records to delete (for logging)
                def recordsToDelete = findBuilder.list()
                
                if (recordsToDelete.isEmpty()) {
                    def jsonResult = [
                        entityName: entityName,
                        deleted: false,
                        reason: "No records found matching condition",
                        recordsDeleted: 0
                    ]
                    
                    return [
                        success: "Y",
                        result: new JsonBuilder(jsonResult).toString(),
                        entityName: entityName,
                        recordCount: 0
                    ]
                }
                
                // Delete records
                def recordsDeleted = findBuilder.deleteAll()
                
                // Log deletions
                for (record in recordsToDelete) {
                    ec.service.async("org.moqui.mcp.McpSecurityServices.log#AuditEvent", [
                        toolCallId: toolCallId,
                        userAccountId: userAccountId,
                        eventType: "McpEventToolCompleted",
                        eventDetail: "Entity deleted: ${entityName}",
                        entityName: entityName,
                        recordId: record.getPrimaryKeys().values().first(),
                        oldValues: new JsonBuilder(record.getMap()).toString(),
                        severity: "McpSeverityWarning"
                    ])
                }
                
                def jsonResult = [
                    entityName: entityName,
                    deleted: true,
                    recordsDeleted: recordsDeleted,
                    deletedRecords: recordsToDelete.collect { it.getMap() }
                ]
                
                return [
                    success: "Y",
                    result: new JsonBuilder(jsonResult).toString(),
                    entityName: entityName,
                    recordCount: recordsDeleted
                ]
                
            } catch (Exception e) {
                return [success: "N", errorMessage: "Error deleting entities: ${e.message}"]
            }
        }
        
        def executeEntityCount(Map parameters, String userAccountId, String toolCallId) {
            def ec = context.ec
            
            def entityName = parameters.entityName
            def condition = parameters.condition
            def useCache = parameters.useCache != "N"
            
            if (!entityName) {
                return [success: "N", errorMessage: "entityName parameter required"]
            }
            
            // Validate entity access
            def accessCheck = ec.service.sync("org.moqui.mcp.McpSecurityServices.validate#EntityAccess", [
                entityName: entityName,
                userAccountId: userAccountId,
                operation: "VIEW"
            ])
            
            if (accessCheck.allowed != "Y") {
                return [success: "N", errorMessage: accessCheck.reason]
            }
            
            try {
                def findBuilder = ec.entity.find(entityName)
                
                // Apply conditions
                if (condition) {
                    for (entry in condition) {
                        if (entry.value instanceof Map && entry.value.containsKey("value")) {
                            def conditionMap = entry.value
                            def operator = conditionMap.operator ?: "equals"
                            def value = conditionMap.value
                            findBuilder.condition(entry.key, value, operator)
                        } else {
                            findBuilder.condition(entry.key, entry.value)
                        }
                    }
                }
                
                // Apply cache setting
                findBuilder.useCache(useCache)
                
                // Get count
                def count = findBuilder.count()
                
                def jsonResult = [
                    entityName: entityName,
                    count: count
                ]
                
                return [
                    success: "Y",
                    result: new JsonBuilder(jsonResult).toString(),
                    entityName: entityName,
                    recordCount: count
                ]
                
            } catch (Exception e) {
                return [success: "N", errorMessage: "Error counting entities: ${e.message}"]
            }
        }
        
        def executeEntityDescribe(Map parameters, String userAccountId, String toolCallId) {
            def ec = context.ec
            
            def entityName = parameters.entityName
            
            if (!entityName) {
                return [success: "N", errorMessage: "entityName parameter required"]
            }
            
            // Validate entity access
            def accessCheck = ec.service.sync("org.moqui.mcp.McpSecurityServices.validate#EntityAccess", [
                entityName: entityName,
                userAccountId: userAccountId,
                operation: "VIEW"
            ])
            
            if (accessCheck.allowed != "Y") {
                return [success: "N", errorMessage: accessCheck.reason]
            }
            
            try {
                def entityExists = ec.entity.isEntityDefined(entityName)
                
                if (!entityExists) {
                    return [success: "N", errorMessage: "Entity not found: ${entityName}"]
                }
                
                def entityInfo = ec.entity.getEntityInfo(entityName)
                def fieldInfoList = []
                
                for (fieldInfo in entityInfo.allFieldInfoList) {
                    fieldInfoList << [
                        name: fieldInfo.name,
                        type: fieldInfo.type,
                        isPk: fieldInfo.isPk,
                        isNotNull: fieldInfo.isNotNull,
                        defaultStr: fieldInfo.defaultStr,
                        description: fieldInfo.description
                    ]
                }
                
                def relationshipInfoList = []
                for (relInfo in entityInfo.relationshipInfoList) {
                    relationshipInfoList << [
                        type: relInfo.type,
                        relatedEntityName: relInfo.relatedEntityName,
                        title: relInfo.title,
                        keyMaps: relInfo.keyMapList.collect { [fieldName: it.fieldName, relatedFieldName: it.relatedFieldName] }
                    ]
                }
                
                def jsonResult = [
                    entityName: entityName,
                    packageName: entityInfo.packageName,
                    tableName: entityInfo.tableName,
                    fields: fieldInfoList,
                    relationships: relationshipInfoList,
                    pkFieldNames: entityInfo.pkFieldNames,
                    allFieldNames: entityInfo.allFieldNames,
                    nonPkFieldNames: entityInfo.nonPkFieldNames
                ]
                
                return [
                    success: "Y",
                    result: new JsonBuilder(jsonResult).toString(),
                    entityName: entityName,
                    recordCount: 0
                ]
                
            } catch (Exception e) {
                return [success: "N", errorMessage: "Error describing entity: ${e.message}"]
            }
        }
        
        def executeEntityList(Map parameters, String userAccountId, String toolCallId) {
            def ec = context.ec
            
            def packageName = parameters.packageName
            def includeEntities = parameters.includeEntities
            def excludeEntities = parameters.excludeEntities
            
            try {
                def allEntityNames = ec.entity.getEntityNames(packageName)
                def filteredEntityNames = []
                
                for (entityName in allEntityNames) {
                    // Apply include filter
                    if (includeEntities) {
                        def includeMatch = false
                        for (pattern in includeEntities) {
                            if (entityName.matches(pattern)) {
                                includeMatch = true
                                break
                            }
                        }
                        if (!includeMatch) continue
                    }
                    
                    // Apply exclude filter
                    if (excludeEntities) {
                        def excludeMatch = false
                        for (pattern in excludeEntities) {
                            if (entityName.matches(pattern)) {
                                excludeMatch = true
                                break
                            }
                        }
                        if (excludeMatch) continue
                    }
                    
                    // Check access
                    def accessCheck = ec.service.sync("org.moqui.mcp.McpSecurityServices.validate#EntityAccess", [
                        entityName: entityName,
                        userAccountId: userAccountId,
                        operation: "VIEW"
                    ])
                    
                    if (accessCheck.allowed == "Y") {
                        filteredEntityNames << entityName
                    }
                }
                
                def jsonResult = [
                    packageName: packageName,
                    entityNames: filteredEntityNames,
                    count: filteredEntityNames.size()
                ]
                
                return [
                    success: "Y",
                    result: new JsonBuilder(jsonResult).toString(),
                    entityName: null,
                    recordCount: filteredEntityNames.size()
                ]
                
            } catch (Exception e) {
                return [success: "N", errorMessage: "Error listing entities: ${e.message}"]
            }
        }
    ]]></script>

</services>