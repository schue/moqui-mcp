<?xml version="1.0" encoding="UTF-8"?>
<!-- This software is in the public domain under CC0 1.0 Universal plus a 
     Grant of Patent License.

     To the extent possible under law, the author(s) have dedicated all
     copyright and related and neighboring rights to this software to the
     public domain worldwide. This software is distributed without any warranty.

     You should have received a copy of the CC0 Public Domain Dedication
     along with this software (see the LICENSE.md file). If not, see
     <https://creativecommons.org/publicdomain/zero/1.0/>. -->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- MCP Services using Moqui's built-in JSON-RPC support -->
    
    
    <service verb="mcp" noun="Initialize" authenticate="true" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP initialize request using Moqui authentication</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="protocolVersion" required="true"/>
            <parameter name="capabilities" type="Map"/>
            <parameter name="clientInfo" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Permissions are handled by Moqui's artifact authorization system
                // Users must be in appropriate groups (McpUser, MCP_BUSINESS) with access to McpServices artifact group
                
                // Disable authz to prevent automatic Visit updates during MCP operations
                ec.artifactExecution.disableAuthz()
                
                // Get Visit (session) created by servlet and validate access
                def visit = ec.entity.find("moqui.server.Visit")
                    .condition("visitId", sessionId)
                    .one()
                
                if (!visit) {
                    throw new Exception("Invalid session: ${sessionId}")
                }
                
                if (visit.userId != ec.user.userId) {
                    throw new Exception("Access denied for session: ${sessionId}")
                }
                
                // Update Visit with MCP initialization data
                UserInfo adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def metadata = [:]
                    try {
                        metadata = groovy.json.JsonSlurper().parseText(visit.initialRequest ?: "{}") as Map
                    } catch (Exception e) {
                        ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                    }
                    
                    metadata.mcpInitialized = true
                    metadata.mcpProtocolVersion = protocolVersion
                    metadata.mcpCapabilities = capabilities
                    metadata.mcpClientInfo = clientInfo
                    metadata.mcpInitializedAt = System.currentTimeMillis()
                    
                    // Session metadata stored in memory only - no Visit updates to prevent lock contention
                    ec.logger.info("SESSIONID: ${sessionId} - metadata stored in memory")
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Validate protocol version - support common MCP versions with version negotiation
                def supportedVersions = ["2025-11-25", "2025-06-18", "2024-11-05", "2024-10-07", "2023-06-05"]
                if (!supportedVersions.contains(protocolVersion)) {
                    throw new Exception("Unsupported protocol version: ${protocolVersion}. Supported versions: ${supportedVersions.join(', ')}")
                }

                // Get current user context (if authenticated)
                def userId = ec.user.userId
                def userAccountId = userId ? userId : null

                // Try to load root instructions from wiki
                def instructions = null
                try {
                    def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                        .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                        .condition("pagePath", "root")
                        .useCache(true)
                        .one()

                    if (wikiPage) {
                        def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                            .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                            .one()

                        if (wikiSpace) {
                            def pageLocation = wikiSpace.rootPageLocation
                            if (!pageLocation.endsWith('/')) pageLocation += '/'
                            pageLocation += wikiPage.pagePath + '.md'

                            def pageRef = ec.resource.getLocationReference(pageLocation)
                            def wikiText = pageRef?.getText()
                            if (wikiText) {
                                instructions = wikiText
                                ec.logger.info("MCP Initialize: Loaded root instructions from wiki")
                            }
                        }
                    }
                } catch (Exception e) {
                    ec.logger.debug("Could not load root instructions from wiki: ${e.message}")
                }

                // Fallback to hardcoded instructions if wiki not available
                if (!instructions) {
                    instructions = "This server provides access to Moqui ERP through MCP. Use moqui_browse_screens(path='/PopCommerce') to begin. Key screens include: /PopCommerce/Catalog/Product/FindProduct for products, /PopCommerce/Order/FindOrder for orders, and /PopCommerce/Customer for customer management. All screens support parameterized queries for filtering results."
                }
                
                // Build server capabilities - don't fetch actual tools/resources during init
                // Tools and resources will be discovered via separate list requests per MCP spec
                def serverCapabilities = [
                    tools: [listChanged: true],
                    resources: [subscribe: true, listChanged: true],
                    logging: [:]
                ]
                
                // Build server info with useful metadata
                def moquiVersion = ec.factory.moquiVersion ?: "Unknown"
                def runtimePath = ec.factory.runtimePath ?: "Unknown"
                
                // Get hostname and IP
                def hostname = "Unknown"
                def ipAddress = "Unknown"
                try {
                    def localhost = java.net.InetAddress.getLocalHost()
                    hostname = localhost.getHostName()
                    ipAddress = localhost.getHostAddress()
                } catch (Exception e) { /* ignore */ }
                
                // Get Java/JVM info
                def javaVersion = System.getProperty("java.version") ?: "Unknown"
                def javaVendor = System.getProperty("java.vendor") ?: "Unknown"
                
                // Get server start time from Runtime MXBean
                def serverStartTime = null
                try {
                    def runtimeMXBean = java.lang.management.ManagementFactory.getRuntimeMXBean()
                    serverStartTime = runtimeMXBean.getStartTime()
                } catch (Exception e) { /* ignore */ }
                
                def serverInfo = [
                    name: "Moqui MCP Server",
                    version: "2.0.2",
                    moquiVersion: moquiVersion,
                    hostname: hostname,
                    ipAddress: ipAddress,
                    javaVersion: javaVersion,
                    javaVendor: javaVendor,
                    serverStartTime: serverStartTime,
                    runtimePath: runtimePath,
                    currentUser: ec.user?.username,
                    currentUserId: ec.user?.userId
                ]
                
                result = [
                    protocolVersion: "2025-06-18",
                    capabilities: serverCapabilities,
                    serverInfo: serverInfo,
                    sessionId: sessionId,
                    instructions: instructions
                ]
                
                ec.logger.info("MCP Initialize for user ${userId} (session ${sessionId}): capabilities negotiated")
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ToolsCall" authenticate="true" allow-remote="true" transaction-timeout="300">
        <description>Handle MCP tools/call request with direct Moqui service execution</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="name" required="true"/>
            <parameter name="arguments" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                // Start timing for execution metrics
                def startTime = System.currentTimeMillis()
                def isError = false
                
                try {
                    // Consolidated Tool Dispatching

                    ec.logger.info("MCP ToolsCall: Dispatching tool name=${name}, arguments=${arguments}")
                    ec.logger.info("MCP ToolsCall: CODE VERSION: 2025-01-09 - FIXED NULL CHECK")

                    if (name == "moqui_render_screen" || name == "moqui_browse_screens") {
                        def targetServiceName = name == "moqui_browse_screens" ? "McpServices.mcp#BrowseScreens" : "McpServices.execute#ScreenAsMcpTool"
                        def serviceResult = ec.service.sync().name(targetServiceName).parameters(arguments ?: [:]).call()
                        
                        // Ensure standard MCP response format with content array
                        def actualRes = serviceResult?.result ?: serviceResult
                        if (actualRes instanceof Map && actualRes.content && actualRes.content instanceof List) {
                            result = actualRes
                        } else {
                            result = [ content: [[type: "text", text: new groovy.json.JsonBuilder(actualRes).toString()]], isError: false ]
                        }
                        return
                    }
                    
                    // Handle internal discovery/utility tools
                    def internalToolMappings = [
                        "moqui_search_screens": "McpServices.mcp#SearchScreens",
                        "moqui_get_screen_details": "McpServices.mcp#GetScreenDetails",
                        "moqui_get_help": "McpServices.mcp#GetHelp",
                        "moqui_batch_operations": "McpServices.mcp#BatchOperations"
                    ]
                    
                    def targetServiceName = internalToolMappings[name]
                    if (targetServiceName) {
                        def serviceResult = ec.service.sync().name(targetServiceName).parameters(arguments ?: [:]).call()
                        def actualRes = serviceResult?.result ?: serviceResult
                        // Ensure standard MCP response format with content array
                        if (actualRes instanceof Map && actualRes.content && actualRes.content instanceof List) {
                            result = actualRes
                        } else {
                            result = [ content: [[type: "text", text: new groovy.json.JsonBuilder(actualRes).toString()]], isError: false ]
                        }
                        return
                     }

                    // Fallback: check if it's a general Moqui service (non-screen-based tools)
                    if (ec.service.isServiceDefined(name)) {
                        // Execute service with current user context
                        def serviceResult = ec.service.sync().name(name).parameters(arguments ?: [:]).call()
                        // Convert result to MCP format for general services
                        result = [content: [[type: "text", text: new JsonBuilder(serviceResult).toString()]], isError: false]
                        return
                    }

                    throw new Exception("Unknown tool name: ${name}")
                } catch (Exception e) {
                    isError = true
                    
                    result = [
                        content: [
                            [
                                type: "text",
                                text: "Error executing tool ${name}: ${e.message}"
                            ]
                        ],
                        isError: true
                    ]
                    
                    ec.logger.error("MCP tool execution error", e)
                } finally {
                    // Send a simple notification about tool execution
                    try {
                        def servlet = ec.web.getServletContext().getAttribute("enhancedMcpServlet")
                        if (servlet && sessionId) {
                            def notification = [
                                method: "notifications/tool_execution",
                                params: [
                                    toolName: name,
                                    executionTime: (System.currentTimeMillis() - startTime) / 1000.0,
                                    success: !isError,
                                    timestamp: System.currentTimeMillis()
                                ]
                            ]
                            //servlet.queueNotification(sessionId, notification)
                        }
                    } catch (Exception e) {
                        ec.logger.warn("Failed to send tool execution notification: ${e.message}")
                    }
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesList" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Handle MCP resources/list request with Moqui entity discovery based on user permissions</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                def availableResources = []
                
                ec.logger.debug("MCP ResourcesList: Discovering entities for user groups: ${userGroups}")
                
                // Use ArtifactAuthzCheckView to find all entities user has permission for
                // This is the "Moqui Way" - rely on the security system to tell us what is accessible
                def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                    .condition("userGroupId", userGroups)
                    .condition("artifactTypeEnumId", "AT_ENTITY")
                    .condition("authzActionEnumId", "AUTHZA_VIEW")
                    .useCache(true)
                    .disableAuthz()
                    .list()
                
                for (def aacv in aacvList) {
                    def entityName = aacv.artifactName
                    // Basic sanity check to ensure entity is actually defined
                    if (ec.entity.isEntityDefined(entityName)) {
                        def description = "Moqui entity: ${entityName}"
                        if (entityName.contains("View")) {
                            description = "Moqui ViewEntity: ${entityName}"
                        }
                        
                        availableResources << [
                            uri: "entity://${entityName}",
                            name: entityName,
                            description: description,
                            mimeType: "application/json"
                        ]
                    }
                }
                
                // Add instructions resource for MCP_USER role
                if (userGroups.contains("McpUser")) {
                    availableResources << [
                        uri: "moqui://mcp/instructions",
                        name: "instructions",
                        description: "MCP server usage instructions",
                        mimeType: "text/plain"
                    ]
                }
                
                result = [resources: availableResources]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesRead" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Handle MCP resources/read request with Moqui entity queries</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                def startTime = System.currentTimeMillis()
                
                // Handle special moqui://mcp/instructions resource
                if (uri == "moqui://mcp/instructions") {
                    // Try to load from wiki
                    def instructionsText = null
                    try {
                        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                            .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                            .condition("pagePath", "root")
                            .useCache(true)
                            .one()

                        if (wikiPage) {
                            def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                                .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                                .one()

                            if (wikiSpace) {
                                def pageLocation = wikiSpace.rootPageLocation
                                if (!pageLocation.endsWith('/')) pageLocation += '/'
                                pageLocation += wikiPage.pagePath + '.md'

                                def pageRef = ec.resource.getLocationReference(pageLocation)
                                instructionsText = pageRef?.getText()
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not load instructions from wiki: ${e.message}")
                    }

                    // Fallback to hardcoded instructions
                    if (!instructionsText) {
                        instructionsText = "This server provides access to Moqui ERP through MCP. Use moqui_browse_screens(path='/PopCommerce') to begin. Key screens include: /PopCommerce/Catalog/Product/FindProduct for products, /PopCommerce/Order/FindOrder for orders, and /PopCommerce/Customer for customer management. All screens support parameterized queries for filtering results."
                    }

                    result = [
                        content: [[
                            uri: "moqui://mcp/instructions",
                            mimeType: "text/plain",
                            text: instructionsText
                        ]],
                        isError: false
                    ]
                    return
                }
                
                // Parse entity URI (format: entity://EntityName)
                if (!uri.startsWith("entity://")) {
                    throw new Exception("Invalid resource URI: ${uri}")
                }
                
                def entityName = uri.substring(9)
                
                if (!ec.entity.isEntityDefined(entityName)) {
                    throw new Exception("Entity not found: ${entityName}")
                }
                
                try {
                    def entityDef = null
                    try {
                        def entityInfoList = ec.entity.getAllEntityInfo(-1, true)
                        entityDef = entityInfoList.find { it.entityName == entityName }
                    } catch (Exception e) {
                        ec.logger.debug("Error getting detailed entity info: ${e.message}")
                    }
                    
                    if (!entityDef) {
                        entityDef = [
                            entityName: entityName,
                            packageName: entityName.contains('.') ? entityName.split('\\.')[0] : "",
                            description: "Entity: ${entityName}",
                            isViewEntity: entityName.contains('View'),
                            allFieldInfoList: []
                        ]
                    }
                    
                    // Query entity data
                    def entityList = ec.entity.find(entityName).limit(100).list()
                    
                    // Format response for MCP - create multiple content objects
                    def contentList = []
                    
                    // Add main content with entity data as text
                    contentList << [
                        type: "text",
                        text: new JsonBuilder([
                            entityName: entityName,
                            description: entityDef.description,
                            packageName: entityDef.packageName,
                            recordCount: entityList.size(),
                            data: entityList
                        ]).toString()
                    ]
                    
                    def responseMap = [
                        content: contentList,
                        isError: false
                    ]
                    
                    def jsonOutput = new JsonBuilder(responseMap).toString()
                    
                    // Size protection
                    def maxResponseSize = 1024 * 1024 // 1MB
                    if (jsonOutput.length() > maxResponseSize) {
                         def truncatedList = entityList.take(10)
                         responseMap.data = truncatedList
                         responseMap.truncated = true
                         responseMap.message = "Truncated to 10 records due to size."
                         jsonOutput = new JsonBuilder(responseMap).toString()
                    }
                    
                    result = [
                        content: [[
                            uri: uri,
                            mimeType: "application/json",
                            text: jsonOutput
                        ]],
                        isError: false
                    ]
                    
                } catch (Exception e) {
                    ec.logger.error("Error reading resource ${uri}", e)
                    result = [isError: true, content: [[type:"text", text: e.message]]]
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="Ping" authenticate="true" allow-remote="true" transaction-timeout="10">
        <description>Handle MCP ping request for health check</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
          <script><![CDATA[
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                // Get current user information
                def currentUser = ec.user.username
                def currentUserId = ec.user.userId
                
                // Try to get visit information if sessionId is provided
                def visitInfo = null
                if (sessionId) {
                    try {
                        ec.artifactExecution.disableAuthz()
                        def adminUserInfo = ec.user.pushUser("ADMIN")
                        try {
                            def visit = ec.entity.find("moqui.server.Visit")
                                .condition("visitId", sessionId)
                                .one()
                            
                            if (visit) {
                                visitInfo = [
                                    visitId: visit.visitId,
                                    userId: visit.userId,
                                    fromDate: visit.fromDate,
                                    lastUpdatedStamp: visit.lastUpdatedStamp
                                ]
                            }
                        } finally {
                            ec.user.popUser()
                        }
                        ec.artifactExecution.enableAuthz()
                    } catch (Exception e) {
                        // Log but don't fail the ping
                        ec.logger.warn("Error getting visit info for sessionId ${sessionId}: ${e.message}")
                    }
                }
                
                result = [
                    timestamp: ec.user.getNowTimestamp(),
                    status: "healthy",
                    version: "2.0.2",
                    sessionId: sessionId,
                    currentUser: currentUser,
                    currentUserId: currentUserId,
                    visitInfo: visitInfo,
                    architecture: "Visit-based sessions"
                ]
            ]]></script>
        </actions>
    </service>

    <!-- Debug Service -->
    
    <service verb="debug" noun="ComponentStatus" authenticate="false" allow-remote="true">
        <description>Debug service to verify component is loaded and working</description>
        <in-parameters/>
        <out-parameters>
            <parameter name="status" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                def status = [
                    componentLoaded: true,
                    componentName: "mo-mcp",
                    timestamp: ec.user.getNowTimestamp(),
                    user: ec.user.username,
                    userId: ec.user.userId,
                    serviceNames: ec.service.getKnownServiceNames().findAll { it.contains("Mcp") },
                    entityNames: ec.entity.getAllEntityNames().findAll { it.contains("ArtifactHit") }
                ]
                
                ec.logger.info("=== MCP COMPONENT DEBUG ===")
                ec.logger.info("Component status: ${status}")
                ec.logger.info("All service names count: ${ec.service.getKnownServiceNames().size()}")
                ec.logger.info("All entity names count: ${ec.entity.getAllEntityNames().size()}")
                ec.logger.info("=== END MCP COMPONENT DEBUG ===")
                
                result.status = status
            ]]></script>
        </actions>
    </service>

    <service verb="execute" noun="ScreenAsMcpTool" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Execute a screen as an MCP tool</description>
        <in-parameters>
            <parameter name="path" required="true"/>
            <parameter name="parameters" type="Map"><description>Parameters to pass to screen</description></parameter>
            <parameter name="action"><description>Action being processed: if not null, use real screen rendering instead of test mock</description></parameter>
            <parameter name="renderMode" default="compact"><description>Render mode: compact (default, actionable summary), aria (accessibility tree), mcp (full metadata), text, html, xml, vuet, qvt</description></parameter>
            <parameter name="sessionId"><description>Session ID for user context restoration</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
import org.moqui.context.ExecutionContext
import groovy.json.JsonBuilder

ExecutionContext ec = context.ec

def startTime = System.currentTimeMillis()

// Set parameters in context
if (parameters) {
    ec.context.putAll(parameters)
}

// Map path parameter to screenPath for consistency
def screenPath = path

// Helper function to get simple path from component path
def getSimplePath = { fullPath ->
    if (!fullPath || fullPath == "root") return "root"
    String cleanPath = fullPath
    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
    List<String> parts = cleanPath.split('/').toList()
    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
    return parts.join('/')
}

// Helper to extract short description/summary from wiki content
def extractSummary = { wikiText ->
    if (!wikiText) return null
    def textString = wikiText instanceof String ? wikiText : new String(wikiText, "UTF-8")
    def lines = textString.split('\n')
    for (def line : lines) {
        def trimmed = line.trim()
        // Skip empty lines and headers
        if (trimmed && !trimmed.startsWith('#')) {
            return trimmed.take(200)
        }
    }
    return null
}

// Helper function to load wiki instructions for a screen
// Walks up the path hierarchy to find the most specific wiki doc available
// e.g., for "Catalog/Product/EditProduct/Assocs", tries in order:
//   1. Catalog/Product/EditProduct/Assocs (most specific)
//   2. Catalog/Product/EditProduct
//   3. Catalog/Product
//   4. Catalog
def getWikiInstructions = { lookupPath ->
    if (!lookupPath) return null
    
    // Normalize path - remove leading/trailing slashes
    def normalizedPath = lookupPath.replaceAll('^/+', '').replaceAll('/+$', '')
    if (!normalizedPath) return null
    
    // Build list of paths from most specific to least specific
    def pathsToTry = []
    def segments = normalizedPath.split('/')
    for (int i = segments.length; i > 0; i--) {
        pathsToTry.add(segments[0..i-1].join('/'))
    }
    
    ec.logger.debug("Wiki lookup: trying paths ${pathsToTry} for ${lookupPath}")
    
    for (def tryPath in pathsToTry) {
        try {
            def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                .condition("pagePath", tryPath)
                .useCache(true)
                .one()

            if (!wikiPage) continue

            def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                .one()

            if (!wikiSpace) continue

            // Build the resource location for the page
            def pageLocation = wikiSpace.rootPageLocation
            if (!pageLocation.endsWith('/')) {
                pageLocation += '/'
            }
            pageLocation += wikiPage.pagePath + '.md'

            // Get the resource reference and text content
            def pageRef = ec.resource.getLocationReference(pageLocation)
            def wikiText = pageRef?.getText()

            if (wikiText) {
                if (tryPath != normalizedPath) {
                    ec.logger.debug("Wiki lookup: found inherited docs at ${tryPath} for ${lookupPath}")
                }
                return wikiText
            }
        } catch (Exception e) {
            ec.logger.debug("Could not load wiki instructions for ${tryPath}: ${e.message}")
        }
    }
    return null
}

// Recursive serializer for Moqui/Java objects to JSON-friendly Map/List
// Applies reasonable safety limits to prevent massive payloads
def serializeMoquiObject
serializeMoquiObject = { obj, depth = 0 ->
    if (depth > 8) return "..." // Prevent deep recursion
    
    if (obj == null) return null
    if (obj instanceof Map) {
        def newMap = [:]
        obj.each { k, v ->
            def keyStr = k.toString()
            // Skip internal framework keys and metadata fields
            if (keyStr.startsWith("_") || keyStr == "ec" || keyStr == "sri") return
            // Skip audit fields to reduce payload
            if (keyStr in ["lastUpdatedStamp", "lastUpdatedTxStamp", "createdDate", "createdTxStamp", "createdByUserLogin"]) return
            def value = serializeMoquiObject(v, depth + 1)
            if (value != null) newMap[keyStr] = value
        }
        return newMap
    }
    if (obj instanceof Iterable) {
        def list = obj.collect()
        // Safety limit: truncate very large lists (10000+ items)
        def maxItems = 10000
        if (list.size() > maxItems) {
            ec.logger.info("serializeMoquiObject: Truncating large list from ${list.size()} to ${maxItems} items")
            def truncated = list.take(maxItems)
            def resultList = truncated.collect { serializeMoquiObject(it, depth + 1) }
            return [
                _items: resultList,
                _totalCount: list.size(),
                _truncated: true,
                _hasMore: true,
                _message: "Showing first ${maxItems} of ${list.size()} items. Use pagination for more."
            ]
        }
        return list.collect { serializeMoquiObject(it, depth + 1) }
    }
    if (obj instanceof org.moqui.entity.EntityValue) {
        return serializeMoquiObject(obj.getMap(), depth + 1)
    }
    if (obj instanceof java.sql.Timestamp || obj instanceof java.util.Date) {
        return obj.toString()
    }
    if (obj instanceof Number || obj instanceof Boolean) {
        return obj
    }
    if (obj instanceof String) {
        // Safety limit: truncate very large strings (1MB+)
        if (obj.length() > 1000000) {
            return [
                _value: obj.substring(0, 1000000) + "...",
                _fullLength: obj.length(),
                _truncated: true,
                _message: "Truncated to 1MB for safety."
            ]
        }
        return obj
    }
    if (obj.getClass().getName().startsWith("org.moqui.impl.screen.ScreenDefinition")) {
        return [location: obj.location]
    }
    // Skip EntityFind objects entirely - they're query definitions, not actual data
    if (obj instanceof org.moqui.entity.EntityFind) {
        return null
    }
    // Fallback for unknown types
    def str = obj.toString()
    if (str.length() > 10000) {
        return [
            _value: str.substring(0, 10000) + "...",
            _fullLength: str.length(),
            _truncated: true
        ]
    }
    return str
}

// Convert MCP semantic state to ARIA accessibility tree format
// This produces a compact, standard representation matching W3C ARIA roles
// Following ARIA naming guidelines: name (short label), description (brief explanation), details (extended help)
def convertToAriaTree = { semanticState, targetScreenPath ->
    if (!semanticState) return null
    
    def data = semanticState.data
    if (!data) return [role: "document", name: targetScreenPath, children: []]
    
    def children = []
    def formMetadata = data.formMetadata ?: [:]
    
    // Map Moqui field types to ARIA roles
    def fieldToAriaRole = { field ->
        switch (field.type) {
            case "dropdown": return "combobox"
            case "text": return "textbox"
            case "textarea": return "textbox"
            case "checkbox": return "checkbox"
            case "radio": return "radio"
            case "date": return "textbox"  // with date semantics
            case "date-time": return "textbox"
            case "number": return "spinbutton"
            case "password": return "textbox"
            case "hidden": return null  // skip hidden fields
            case "display": return "text"  // read-only display
            case "link": return "link"
            default: return "textbox"
        }
    }
    
    // Convert a field to ARIA node with full attributes
    def fieldToAriaNode = { field, formDataMap ->
        def role = fieldToAriaRole(field)
        if (!role) return null
        
        def node = [
            role: role,
            name: field.title ?: field.name,
            ref: field.name  // Reference for interaction
        ]
        
        // Add current value if available from form data
        if (formDataMap && formDataMap[field.name] != null) {
            node.value = formDataMap[field.name]?.toString()
        }
        
        // Add required attribute
        if (field.required) node.required = true
        
        // For dropdowns, just indicate type - use get_screen_details for options
        if (field.type == "dropdown") {
            node.description = "dropdown - use moqui_get_screen_details for options"
            // Check for dynamic options (autocomplete)
            if (field.dynamicOptions) {
                node.description = "autocomplete - type to search"
            }
        }
        
        return node
    }
    
    // Generate description for an action based on its name and service
    def actionDescription = { actionName, serviceName ->
        def verb = actionName.replaceAll(/([A-Z])/, ' $1').trim().toLowerCase()
        if (serviceName) {
            // Extract entity/operation from service name like "create#mantle.product.Product"
            def parts = serviceName.split('#')
            if (parts.length == 2) {
                def operation = parts[0]
                def entity = parts[1].split('\\.').last()
                return "${operation} ${entity}"
            }
            return serviceName.split('\\.').last()
        }
        return verb
    }
    
    // Process forms (form-single types become form landmarks)
    formMetadata.each { formName, formData ->
        if (formData.type == "form-list") return  // Handle separately
        
        // Look for form data (current values)
        def formDataKey = "${formName}_data"
        def formDataMap = data[formDataKey] ?: [:]
        
        def formNode = [
            role: "form",
            name: formData.name ?: formName,
            ref: formName,
            children: []
        ]
        
        // Add fields with values
        formData.fields?.each { field ->
            def fieldNode = fieldToAriaNode(field, formDataMap)
            if (fieldNode) formNode.children << fieldNode
        }
        
        // Find submit button by matching form name pattern
        // e.g., CreatePersonForm -> createPerson action
        def formBaseName = formName.replaceAll(/Form$/, "")
        def expectedActionName = formBaseName.substring(0,1).toLowerCase() + formBaseName.substring(1)
        def submitAction = semanticState.actions?.find { a -> 
            a.name == expectedActionName || a.name?.equalsIgnoreCase(expectedActionName)
        }
        if (submitAction) {
            def btnNode = [
                role: "button", 
                name: submitAction.name,
                ref: submitAction.name
            ]
            if (submitAction.service) {
                btnNode.description = actionDescription(submitAction.name, submitAction.service)
            }
            formNode.children << btnNode
        }
        
        if (formNode.children) children << formNode
    }
    
    // Process form-lists (become grids)
    formMetadata.findAll { k, v -> v.type == "form-list" }.each { formName, formData ->
        def listData = data[formName]
        def itemCount = 0
        if (listData instanceof List) {
            itemCount = listData.size()
        } else if (listData?._totalCount) {
            itemCount = listData._totalCount
        }
        
        def gridNode = [
            role: "grid",
            name: formData.name ?: formName,
            ref: formName,
            rowcount: itemCount
        ]
        
        // Add column info
        def columns = formData.fields?.collect { it.title ?: it.name }
        if (columns) gridNode.columns = columns
        
        // Add all rows with detail (no truncation - model needs complete data)
        if (listData instanceof List && listData.size() > 0) {
            gridNode.children = []
            listData.each { row ->
                def rowNode = [role: "row"]
                // Extract key identifying info - prefer specific IDs over generic productId
                // For features: productFeatureId, for assocs: toProductId, etc.
                def id = row.pseudoId ?: row.toProductId ?: row.productFeatureId ?: 
                         row.partyId ?: row.orderId ?: row.id
                // Avoid using productId as ref when it's the same for all rows (e.g., feature list)
                if (!id && row.productId) {
                    // Only use productId if there's no better identifier
                    id = row.productId
                }
                def name = row.combinedName ?: row.name ?: row.productName ?: 
                           row.description ?: row.abbrev
                if (id) rowNode.ref = id
                if (name) rowNode.name = name
                if (id && name && id != name) rowNode.description = id
                gridNode.children << rowNode
            }
        }
        
        children << gridNode
    }
    
    // Process navigation links - filter out noise
    def navLinks = semanticState.data?.links?.findAll { it.type == "navigation" }
    if (navLinks && navLinks.size() > 0) {
        // Determine current app from target path
        def currentApp = targetScreenPath?.split('/')?.find { it.startsWith('Popc') || it.startsWith('marble') || it.startsWith('hm') || it.startsWith('my') || it.startsWith('system') || it.startsWith('tools') }
        
        def filteredLinks = navLinks.findAll { link ->
            def path = link.path?.toString() ?: ""
            
            // Skip links with encoded timestamps (delete/update action URLs) - these are action URLs, not navigation
            if (path.contains("fromDate=") || path.contains("thruDate=")) {
                return false
            }
            
            // Skip cross-app navigation links (apps/marble, apps/hm, etc.) unless they're current app
            if (path.startsWith("apps/")) {
                def linkApp = path.split('/')[1]
                // Keep if same app or if it's a my/User link (global nav)
                return linkApp == currentApp || path.startsWith("apps/my/")
            }
            
            return true
        }
        
        if (filteredLinks.size() > 0) {
            def navNode = [
                role: "navigation",
                name: "Links",
                children: filteredLinks.collect { link ->
                    def linkNode = [role: "link", name: link.text, ref: link.path]
                    linkNode
                }
            ]
            children << navNode
        }
    }
    
    // Process ALL actions as buttons (unified - no separate transitions/actions, no truncation)
    def allActions = semanticState.actions ?: []
    if (allActions && allActions.size() > 0) {
        def toolbarNode = [
            role: "toolbar",
            name: "Actions",
            description: "Available operations on this screen",
            children: allActions.collect { action ->
                def btnNode = [
                    role: "button", 
                    name: action.name,
                    ref: action.name
                ]
                // Add description based on action type (no service names - they confuse models)
                if (action.service) {
                    btnNode.description = actionDescription(action.name, action.service)
                    // Add help reference for moqui_get_help tool
                    def serviceParts = action.service.split('\\.')
                    if (serviceParts.length > 0) {
                        btnNode.help = "wiki:service:${serviceParts[-1]}"
                    }
                } else if (action.type == "screen-transition") {
                    btnNode.description = "Navigate"
                } else if (action.type == "form-action") {
                    btnNode.description = "Form operation"
                }
                btnNode
            }
        ]
        children << toolbarNode
    }
    
    // Build the main node
    def mainNode = [
        role: "main",
        name: targetScreenPath?.split('/')?.last() ?: "Screen",
        description: "Use ref values with action parameter to interact",
        children: children
    ]
    
    // Note: Removed wiki:screen references - models can't usefully act on them
    // Wiki instructions are already included in the response when available
    
    return mainNode
}

// Convert MCP semantic state to compact actionable format
// Designed for LLM efficiency: enough info to act without fetching more
def convertToCompactFormat = { semanticState, targetScreenPath ->
    if (!semanticState) return null
    
    def data = semanticState.data
    def formMetadata = data?.formMetadata ?: [:]
    def actions = semanticState.actions ?: []
    def params = semanticState.parameters ?: [:]
    
    def result = [
        screen: targetScreenPath?.split('/')?.last() ?: "Screen"
    ]
    
    // Check for missing required parameters
    def missingRequired = params.findAll { name, info -> 
        info.required == true && info.value == null
    }
    if (missingRequired) {
        result.missingRequired = missingRequired.keySet().toList()
        result.error = "Required parameters missing: ${missingRequired.keySet().join(', ')}. Pass these parameters to view the screen."
    }
    
    // Build summary
    def formCount = formMetadata.count { k, v -> v.type != "form-list" }
    def listCount = formMetadata.count { k, v -> v.type == "form-list" }
    def actionNames = actions.findAll { it.type == "service-action" }.collect { it.name }.take(5)
    
    def summaryParts = []
    if (formCount > 0) summaryParts << "${formCount} form${formCount > 1 ? 's' : ''}"
    if (listCount > 0) {
        // Get total row count
        def totalRows = 0
        formMetadata.findAll { k, v -> v.type == "form-list" }.each { formName, formData ->
            def listData = data[formName]
            if (listData instanceof List) totalRows += listData.size()
        }
        summaryParts << "${totalRows} result${totalRows != 1 ? 's' : ''}"
    }
    if (actionNames) summaryParts << "actions: ${actionNames.join(', ')}"
    result.summary = summaryParts.join(". ")
    
    // Process forms (non-list)
    def forms = [:]
    formMetadata.findAll { k, v -> v.type != "form-list" }.each { formName, formData ->
        def formInfo = [:]
        def fields = []
        
        formData.fields?.each { field ->
            if (field.type == "hidden") return
            
            def fieldInfo
            def fieldName = field.name
            def displayName = field.title ?: field.name
            
            if (field.type == "dropdown") {
                // Just indicate it's a dropdown - use get_screen_details for actual options
                fieldInfo = [(fieldName): [type: "dropdown"]]
                if (field.dynamicOptions) {
                    fieldInfo[fieldName].autocomplete = true
                }
                if (displayName != fieldName) fieldInfo[fieldName].label = displayName
            } else {
                // Simple field - just use name, add label if different
                if (displayName != fieldName) {
                    fieldInfo = [(fieldName): displayName]
                } else {
                    fieldInfo = fieldName
                }
            }
            
            if (field.required) {
                if (fieldInfo instanceof String) {
                    fieldInfo = [(fieldName): [required: true]]
                } else if (fieldInfo instanceof Map && fieldInfo[fieldName] instanceof String) {
                    fieldInfo[fieldName] = [label: fieldInfo[fieldName], required: true]
                } else if (fieldInfo instanceof Map && fieldInfo[fieldName] instanceof Map) {
                    fieldInfo[fieldName].required = true
                }
            }
            
            fields << fieldInfo
        }
        
        formInfo.fields = fields
        
        // Find matching action for this form
        def formBaseName = formName.replaceAll(/Form$/, "")
        def expectedActionName = formBaseName.substring(0,1).toLowerCase() + formBaseName.substring(1)
        def submitAction = actions.find { a -> 
            a.name == expectedActionName || a.name?.equalsIgnoreCase(expectedActionName)
        }
        if (submitAction) {
            formInfo.submit = submitAction.name
            // Note: Removed service name - it confuses models into trying to call services directly
        }
        
        forms[formName] = formInfo
    }
    if (forms) result.forms = forms
    
    // Process grids (form-lists)
    def grids = [:]
    formMetadata.findAll { k, v -> v.type == "form-list" }.each { formName, formData ->
        def listData = data[formName]
        def gridInfo = [:]
        
        // Column names
        def columns = formData.fields?.findAll { it.type != "hidden" }?.collect { it.title ?: it.name }
        if (columns) gridInfo.columns = columns
        
        // Rows with key data and links
        if (listData instanceof List && listData.size() > 0) {
            gridInfo.rowCount = listData.size()
            
            // Get field names from form definition for determining key fields
            def fieldNames = formData.fields?.collect { it.name } ?: []
            
            gridInfo.rows = listData.take(10).collect { row ->
                def rowInfo = [:]
                
                // Get identifying info - prefer specific IDs over generic productId
                // For features: productFeatureId, for assocs: toProductId, etc.
                def id = row.pseudoId ?: row.toProductId ?: row.productFeatureId ?: 
                         row.partyId ?: row.orderId ?: row.communicationEventId ?: row.id
                // Avoid using productId as id when it's the same for all rows (e.g., feature list)
                if (!id && row.productId) id = row.productId
                def name = row.combinedName ?: row.productName ?: row.organizationName ?: 
                           row.subject ?: row.name ?: row.description ?: row.abbrev
                
                if (id) rowInfo.id = id
                if (name && name != id) rowInfo.name = name
                
                // Add key display values (2-3 additional fields beyond id/name)
                // Priority: status, type, date, amount, role, class fields
                def keyFieldPriority = [
                    'statusId', 'status', 'productTypeEnumId', 'productAssocTypeEnumId', 
                    'communicationEventTypeId', 'roleTypeId', 'partyClassificationId',
                    'orderPartStatusId', 'placedDate', 'entryDate', 'fromDate', 'thruDate',
                    'grandTotal', 'quantity', 'price', 'amount',
                    'username', 'emailAddress', 'fromPartyId', 'toPartyId'
                ]
                
                def extraFields = [:]
                def extraCount = 0
                for (fieldName in keyFieldPriority) {
                    if (extraCount >= 3) break
                    def value = row[fieldName]
                    if (value != null && value != '' && value != id && value != name) {
                        // Simplify enumId suffixes for display
                        def displayKey = fieldName.replaceAll(/EnumId$/, '').replaceAll(/Id$/, '')
                        extraFields[displayKey] = value.toString()
                        extraCount++
                    }
                }
                
                // If no priority fields found, add first 2-3 non-empty visible fields
                if (extraCount == 0) {
                    for (fieldDef in formData.fields?.take(8)) {
                        if (extraCount >= 3) break
                        def fieldName = fieldDef.name
                        if (fieldDef.type == 'hidden') continue
                        if (fieldName in ['id', 'pseudoId', 'name', 'productId', 'partyId', 'submitButton']) continue
                        def value = row[fieldName]
                        if (value != null && value != '' && value != id && value != name) {
                            extraFields[fieldName] = value.toString()
                            extraCount++
                        }
                    }
                }
                
                if (extraFields) rowInfo.data = extraFields
                
                // Find link for this row
                def rowLinks = data.links?.findAll { link ->
                    link.path?.contains(id?.toString()) && link.type == "navigation"
                }
                if (rowLinks && rowLinks.size() > 0) {
                    // Pick the most relevant link (edit/view)
                    def editLink = rowLinks.find { it.path?.contains("Edit") }
                    rowInfo.link = (editLink ?: rowLinks[0]).path
                }
                
                rowInfo
            }
            if (listData.size() > 10) {
                gridInfo.more = listData.size() - 10
            }
        } else {
            gridInfo.rowCount = 0
        }
        
        grids[formName] = gridInfo
    }
    if (grids) result.grids = grids
    
    // Actions - just action names with help references (no service names)
    def actionMap = [:]
    actions.findAll { it.type == "service-action" && it.service }.each { action ->
        def actionInfo = [:]
        
        // Add help reference for moqui_get_help tool
        def serviceParts = action.service.split('\\.')
        if (serviceParts.length > 0) {
            actionInfo.help = "wiki:service:${serviceParts[-1]}"
        }
        
        // Find form that uses this action to get parameter hints
        def matchingForm = forms.find { k, v -> v.submit == action.name }
        if (matchingForm) {
            def requiredFields = matchingForm.value.fields?.findAll { f ->
                (f instanceof Map && f.values().any { v -> 
                    (v instanceof Map && v.required) || v == "required"
                })
            }?.collect { f ->
                f instanceof Map ? f.keySet()[0] : f
            }
            if (requiredFields) actionInfo.required = requiredFields
        }
        
        if (actionInfo) actionMap[action.name] = actionInfo
    }
    if (actionMap) result.actions = actionMap
    
    // Transitions - screen navigation actions (toolbar buttons, row actions)
    def transitionList = actions.findAll { 
        it.type == "screen-transition" && 
        it.name && 
        !it.name.startsWith("form") &&  // Skip formSelectColumns, formSaveFind
        it.name != "actions" &&          // Skip generic 'actions'
        it.name != "screenDoc"           // Skip documentation link
    }.collect { it.name }
    if (transitionList) result.transitions = transitionList
    
    // Navigation - only external/important links
    def navLinks = data?.links?.findAll { link ->
        link.type == "navigation" && link.path && !link.path.contains("?")
    }?.take(5)?.collect { [name: it.text, path: it.path] }
    if (navLinks) result.nav = navLinks
    
    return result
}

// Resolve input screen path to simple path for lookup
def inputScreenPath = screenPath
if (screenPath.startsWith("component://")) {
    inputScreenPath = getSimplePath(screenPath)
}
ec.logger.info("MCP Screen Execution: Looking up wiki docs for ${inputScreenPath}")

// Try to get wiki instructions
def wikiInstructions = getWikiInstructions(inputScreenPath)
        
        // Try to render screen content for LLM consumption
        def output = null
        def screenUrl = "http://localhost:8080/${screenPath}"
        def isError = false
        def resolvedScreenDef = null
         
        try {
            ec.logger.info("MCP Screen Execution: Attempting to render screen ${screenPath}")
            
            def rootScreen = "component://webroot/screen/webroot.xml"
            def testScreenPath = screenPath
            
            if (screenPath.startsWith("component://")) {
                // Component path handling
                resolvedScreenDef = ec.screen.getScreenDefinition(screenPath)
                rootScreen = screenPath
                testScreenPath = ""
            } else {
                // Forward slash path handling (e.g. /PopCommerce/Catalog)
                def testPath = screenPath.startsWith('/') ? screenPath : "/" + screenPath
                def pathSegments = []
                testPath.split('/').each { if (it && it.trim()) pathSegments.add(it) }
                
                // 1. Try literal resolution from webroot
                rootScreen = "component://webroot/screen/webroot.xml"
                def webrootSd = ec.screen.getScreenDefinition(rootScreen)
                def screenPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                    webrootSd, webrootSd, pathSegments, testPath, [:], ec.screenFacade
                )
                
                def currentSd = webrootSd
                def reachedIndex = -1
                if (screenPathList) {
                    for (int i = 0; i < screenPathList.size(); i++) {
                        def screenName = screenPathList[i]
                        def ssi = currentSd?.getSubscreensItem(screenName)
                        if (ssi && ssi.getLocation()) {
                            currentSd = ec.screen.getScreenDefinition(ssi.getLocation())
                            reachedIndex = i
                        } else {
                            break
                        }
                    }
                }
                
                // Set resolvedScreenDef if we successfully traversed the path
                if (reachedIndex >= 0 && currentSd && reachedIndex == (screenPathList.size() - 1)) {
                    resolvedScreenDef = currentSd
                    ec.logger.info("MCP Path Resolution: Resolved to screen '${resolvedScreenDef?.getScreenName()}' via literal path")
                }
                
                // 2. If literal resolution failed, try Component-based resolution
                if (reachedIndex == -1 && pathSegments.size() >= 2) {
                    def componentName = pathSegments[0]
                    def rootScreenName = pathSegments[1]
                    def compRootLoc = "component://${componentName}/screen/${rootScreenName}.xml"
                    
                    if (ec.resource.getLocationReference(compRootLoc).exists) {
                        ec.logger.info("MCP Path Resolution: Found component root at ${compRootLoc}")
                        rootScreen = compRootLoc
                        testScreenPath = pathSegments.size() > 2 ? pathSegments[2..-1].join('/') : ""
                        resolvedScreenDef = ec.screen.getScreenDefinition(rootScreen)
                        
                        // Resolve further if there are remaining segments
                        if (testScreenPath) {
                            def remainingSegments = pathSegments[2..-1]
                            def compPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                                resolvedScreenDef, resolvedScreenDef, remainingSegments, testScreenPath, [:], ec.screenFacade
                            )
                            if (compPathList) {
                                for (String screenName in compPathList) {
                                    def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                    if (ssi && ssi.getLocation()) {
                                        resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                    } else {
                                        break
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 3. Fallback to double-slash search if still not found
                if (reachedIndex == -1 && !resolvedScreenDef && pathSegments.size() > 0 && !testPath.startsWith("//")) {
                    def searchPath = "//" + pathSegments.join('/')
                    ec.logger.info("MCP Path Resolution: Fallback to search path ${searchPath}")
                    
                    rootScreen = "component://webroot/screen/webroot.xml"
                    def searchPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                        webrootSd, webrootSd, pathSegments, searchPath, [:], ec.screenFacade
                    )
                    
                    if (searchPathList) {
                        testScreenPath = searchPath
                        resolvedScreenDef = webrootSd
                        for (String screenName in searchPathList) {
                            def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                            if (ssi && ssi.getLocation()) {
                                resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                            } else {
                                break
                            }
                        }
                    }
                }
                
                // If we found a specific target, we're good. 
                // If not, default to webroot with full path (original behavior, but now we know it failed)
                if (!resolvedScreenDef) {
                    rootScreen = "component://webroot/screen/webroot.xml"
                    resolvedScreenDef = webrootSd
                    testScreenPath = testPath
                }
            }

            // Regular screen rendering with current user context - use our custom ScreenTestImpl
            // For compact/ARIA modes, we still render with MCP to get semantic data, then convert
            def actualScreenRenderMode = (renderMode == "aria" || renderMode == "compact" || renderMode == null) ? "mcp" : renderMode
            def screenTest = new org.moqui.mcp.CustomScreenTestImpl(ec.ecfi)
                .rootScreen(rootScreen)
                .renderMode(actualScreenRenderMode)
                .auth(ec.user.username)

            def renderParams = parameters ?: [:]
            // Note: Don't inject userId/username into renderParams as they may conflict with
            // screen search fields (e.g., FindCustomer has a 'username' search field).
            // User context is already available via ec.user for authorization purposes.

            // Build the screen path - append action/transition if specified
            // This lets the framework handle transition execution properly (inheritance, pre/post actions, etc.)
            def relativePath = testScreenPath
            def actionResult = [:]
            
            if (action && resolvedScreenDef) {
                // Find the transition - must traverse default subscreens like discovery does
                // because transitions may be defined on default subscreens, not the parent screen
                def transition = null
                def transitionScreenDef = null
                def subscreenPath = ""  // Track the path through default subscreens
                
                def currentScreenDef = resolvedScreenDef
                def depth = 0
                while (currentScreenDef && depth < 5 && !transition) {
                    // Check this screen for the transition
                    transition = currentScreenDef.getAllTransitions().find { it.getName() == action }
                    if (transition) {
                        transitionScreenDef = currentScreenDef
                        ec.logger.info("MCP: Found transition '${action}' on screen '${currentScreenDef.getScreenName()}' at depth ${depth}")
                        break
                    }
                    
                    // Check for default subscreen to continue traversal
                    def defaultSubscreenName = currentScreenDef.getDefaultSubscreensItem()
                    if (defaultSubscreenName) {
                        def subscreenItem = currentScreenDef.getSubscreensItem(defaultSubscreenName)
                        if (subscreenItem?.location) {
                            try {
                                def subscreenDef = currentScreenDef.sfi.getScreenDefinition(subscreenItem.location)
                                if (subscreenDef) {
                                    subscreenPath += "/" + defaultSubscreenName
                                    currentScreenDef = subscreenDef
                                    depth++
                                } else {
                                    currentScreenDef = null
                                }
                            } catch (Exception e) {
                                ec.logger.warn("MCP: Could not load subscreen for transition lookup: ${e.message}")
                                currentScreenDef = null
                            }
                        } else {
                            currentScreenDef = null
                        }
                    } else {
                        currentScreenDef = null
                    }
                }
                
                if (transition) {
                    // Append subscreen path and transition to the render path
                    // The framework needs the full path including default subscreens to find the transition
                    relativePath = testScreenPath + subscreenPath + "/" + action
                    def serviceName = transition.getSingleServiceName()
                    actionResult = [
                        action: action,
                        service: serviceName,
                        status: "pending"  // Will be updated after render based on errors
                    ]
                    ec.logger.info("MCP Screen Execution: Will execute transition '${action}' via framework path '${relativePath}' (service: ${serviceName ?: 'none'})")
                } else {
                    ec.logger.warn("MCP Screen Execution: Action '${action}' not found in screen transitions (checked ${depth + 1} screens in hierarchy)")
                    actionResult = [
                        action: action,
                        status: "error",
                        message: "Transition '${action}' not found on screen"
                    ]
                }
            }
            
            // Clear entity cache before rendering to ensure fresh data
            ec.cache.clearAllCaches()
            ec.logger.info("MCP Screen Execution: Entity cache cleared before rendering")
            
            ec.logger.info("TESTRENDER root=${rootScreen} path=${relativePath} params=${renderParams}")
            
            def testRender = screenTest.render(relativePath, renderParams, "POST")
            output = testRender.getOutput()
            
            // --- Capture Action Result from Framework Execution ---
            def postContext = testRender.getPostRenderContext()
            
            if (action && actionResult.status == "pending") {
                // Check for errors from transition execution
                def errorMessages = testRender.getErrorMessages()
                def hasError = errorMessages && errorMessages.size() > 0
                
                // Also check JSON response for validation errors (more structured)
                def jsonResponse = testRender.getJsonObject()
                def validationErrors = []
                def jsonErrors = []
                if (jsonResponse instanceof Map) {
                    // Extract structured validation errors from JSON response
                    if (jsonResponse.validationErrors) {
                        validationErrors = jsonResponse.validationErrors.collect { ve ->
                            // ValidationError.getMap() returns: form, field, serviceName, message
                            [
                                field: ve.field ?: ve.fieldPretty,
                                form: ve.form,
                                service: ve.serviceName,
                                message: ve.message ?: ve.messageWithFieldPretty ?: ve.toString()
                            ]
                        }
                        hasError = true
                    }
                    // Also capture general errors from JSON
                    if (jsonResponse.errors) {
                        jsonErrors = jsonResponse.errors
                        hasError = true
                    }
                }
                
                if (hasError) {
                    actionResult.status = "error"
                    
                    // Build comprehensive error message
                    def allMessages = []
                    if (errorMessages) allMessages.addAll(errorMessages)
                    if (jsonErrors) allMessages.addAll(jsonErrors)
                    actionResult.message = allMessages.join("; ") ?: "Validation failed"
                    
                    // Add structured validation errors for field-level feedback
                    if (validationErrors) {
                        actionResult.validationErrors = validationErrors
                        // Also add field-specific summary
                        def fieldSummary = validationErrors.collect { ve ->
                            ve.field ? "${ve.field}: ${ve.message}" : ve.message
                        }.join("; ")
                        if (!actionResult.message || actionResult.message == "Validation failed") {
                            actionResult.message = fieldSummary
                        }
                    }
                    
                    ec.logger.error("MCP Screen Execution: Transition '${action}' completed with errors: ${actionResult.message}")
                } else {
                    actionResult.status = "executed"
                    actionResult.message = "Transition '${action}' executed successfully"
                    
                    // Try to extract result from context (services often put results in context)
                    // Common patterns: result, serviceResult, *Id (for create operations)
                    def result = [:]
                    if (postContext) {
                        // Look for common result patterns
                        ['result', 'serviceResult', 'createResult'].each { key ->
                            if (postContext.containsKey(key)) {
                                result[key] = postContext.get(key)
                            }
                        }
                        // Look for created IDs (common pattern: partyId, productId, orderId, etc.)
                        postContext.each { key, value ->
                            if (key.toString().endsWith('Id') && value && !key.toString().startsWith('_')) {
                                // Only include if it looks like a created/returned ID
                                def keyStr = key.toString()
                                if (!['userId', 'username', 'sessionId', 'requestId'].contains(keyStr)) {
                                    result[keyStr] = value
                                }
                            }
                        }
                    }
                    
                    // Also check JSON response for result data
                    if (jsonResponse instanceof Map) {
                        // Copy any IDs from JSON response
                        jsonResponse.each { key, value ->
                            if (key.toString().endsWith('Id') && value && !key.toString().startsWith('_')) {
                                def keyStr = key.toString()
                                if (!['userId', 'username', 'sessionId', 'requestId'].contains(keyStr)) {
                                    result[keyStr] = value
                                }
                            }
                        }
                        // Copy messages if present
                        if (jsonResponse.messages) {
                            actionResult.messages = jsonResponse.messages
                        }
                    }
                    
                    if (result) {
                        actionResult.result = result
                    }
                    ec.logger.info("MCP Screen Execution: Transition '${action}' executed successfully, result: ${result}")
                }
            }

            // --- Semantic State Extraction ---
            def semanticState = [:]

            // Get final screen definition - prefer the actual rendered screen from ScreenRender
            // This ensures we get the deepest screen in the path, not just the root
            def finalScreenDef = resolvedScreenDef
            try {
                def screenRender = testRender.getScreenRender()
                if (screenRender?.screenUrlInfo?.screenPathDefList) {
                    def pathDefList = screenRender.screenUrlInfo.screenPathDefList
                    if (pathDefList.size() > 0) {
                        // Get the last (deepest) screen in the path
                        finalScreenDef = pathDefList.get(pathDefList.size() - 1)
                        ec.logger.info("MCP: Using actual rendered screen '${finalScreenDef?.getScreenName()}' from screenPathDefList (${pathDefList.size()} screens in path)")
                    }
                }
            } catch (Exception e) {
                ec.logger.warn("MCP: Could not get screen from ScreenRender, using resolved: ${e.message}")
            }

            if (finalScreenDef && postContext) {
                semanticState.screenPath = inputScreenPath
                semanticState.data = [:]
                
                // Use the explicit semantic data captured by macros if available
                def explicitData = postContext.get("mcpSemanticData")
                if (explicitData instanceof Map) {
                    explicitData.each { k, v ->
                        semanticState.data[k] = serializeMoquiObject(v, 0)
                    }
                }
                
                // Extract transitions (Actions) with type classification and metadata
                // Collect from current screen AND active subscreens (iterative traversal)
                semanticState.actions = []
                def collectedTransitionNames = [] as Set
                
                // Build list of screens to process (current + default subscreens chain)
                def screensToProcess = []
                def currentScreenDef = finalScreenDef
                def depth = 0
                while (currentScreenDef && depth < 5) {
                    screensToProcess << currentScreenDef
                    
                    // Check for default subscreen
                    def defaultSubscreenName = currentScreenDef.getDefaultSubscreensItem()
                    if (defaultSubscreenName) {
                        def subscreenItem = currentScreenDef.getSubscreensItem(defaultSubscreenName)
                        if (subscreenItem?.location) {
                            try {
                                def subscreenDef = currentScreenDef.sfi.getScreenDefinition(subscreenItem.location)
                                if (subscreenDef) {
                                    ec.logger.info("MCP: Adding default subscreen '${defaultSubscreenName}' at ${subscreenItem.location} to traversal")
                                    currentScreenDef = subscreenDef
                                    depth++
                                } else {
                                    currentScreenDef = null
                                }
                            } catch (Exception e) {
                                ec.logger.warn("MCP: Could not load subscreen ${subscreenItem.location}: ${e.message}")
                                currentScreenDef = null
                            }
                        } else {
                            currentScreenDef = null
                        }
                    } else {
                        currentScreenDef = null
                    }
                }
                
                // Now collect transitions from all screens
                screensToProcess.each { screenDef ->
                    screenDef.getAllTransitions().each { trans ->
                        def transName = trans.getName()
                        if (collectedTransitionNames.contains(transName)) return // skip duplicates
                        collectedTransitionNames.add(transName)
                        
                        def service = trans.getSingleServiceName()
                        
                        // Classify action type
                        def actionType = "screen-transition"
                        def transNameLower = transName?.toString()?.toLowerCase() ?: ''
                        
                        if (service) {
                            actionType = "service-action"
                        } else if (transNameLower.contains('delete')) {
                            actionType = "delete-action"
                        } else if (transNameLower.startsWith('form') || transNameLower == 'find' || transNameLower == 'search') {
                            actionType = "form-action"
                        }
                        
                        def actionInfo = [
                            name: transName,
                            service: service,
                            type: actionType
                        ]
                        
                        semanticState.actions << actionInfo
                    }
                }
                
                // 3. Extract parameters with metadata
                semanticState.parameters = [:]
                if (finalScreenDef.parameterByName) {
                    finalScreenDef.parameterByName.each { name, param ->
                        def value = postContext.get(name) ?: parameters?.get(name)
                        
                        // Build parameter metadata
                        def paramInfo = [:]
                        
                        // Add value if exists
                        if (value != null) {
                            paramInfo.value = serializeMoquiObject(value, 0)
                        }
                        
                        // Extract parameter type - try multiple approaches
                        def type = "string"
                        try {
                            // Try to get type via reflection or known properties
                            if (param.hasProperty('type')) {
                                def typeObj = param.type
                                if (typeObj != null) type = typeObj.toString().toLowerCase()
                            } else if (param.hasProperty('parameterType')) {
                                def typeObj = param.parameterType
                                if (typeObj != null) type = typeObj.toString().toLowerCase()
                            }
                        } catch (Exception e) {
                            // Fall back to type inference from value
                        }
                        
                        // Infer type from value if type couldn't be extracted
                        if (type == "string" && value != null) {
                            if (value instanceof Number) {
                                type = (value instanceof Integer || value instanceof Long) ? "long" : "decimal"
                            } else if (value instanceof Boolean) {
                                type = "boolean"
                            } else if (value instanceof Collection || value instanceof Map) {
                                type = (value instanceof Collection) ? "list" : "map"
                            }
                        }
                        paramInfo.type = type
                        
                        // Extract required flag - defensive check
                        paramInfo.required = false
                        try {
                            if (param.hasProperty('required')) {
                                paramInfo.required = (param.required == true)
                            }
                        } catch (Exception e) {
                            // Skip if property doesn't exist
                        }
                        
                        // Extract default value - defensive check
                        try {
                            if (param.hasProperty('defaultValue') && param.defaultValue != null) {
                                paramInfo.defaultValue = param.defaultValue.toString()
                            }
                        } catch (Exception e) {
                            // Skip if property doesn't exist
                        }
                        
                        semanticState.parameters[name] = paramInfo
                    }
                }
                
                // Log semantic state size for optimization tracking
                def semanticStateJson = new groovy.json.JsonBuilder(semanticState).toString()
                def semanticStateSize = semanticStateJson.length()
                ec.logger.info("MCP Screen Execution: Semantic state size: ${semanticStateSize} bytes, data keys: ${semanticState.data.keySet()}, actions count: ${semanticState.actions.size()}")
            }
            
            ec.logger.info("MCP Screen Execution: Successfully rendered screen ${screenPath}, output length: ${output?.length() ?: 0}")

            def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
            
            // Build result based on renderMode
            def content = []
            if ((renderMode == null || renderMode == "compact") && semanticState) {
                // Return compact actionable format (default)
                def compactData = convertToCompactFormat(semanticState, screenPath)
                
                // Include wiki summary if available
                if (wikiInstructions) {
                    def wikiSummary = extractSummary(wikiInstructions)
                    if (wikiSummary) compactData.help = wikiSummary
                }
                
                // Add action result if an action was executed
                if (actionResult) {
                    compactData.result = actionResult
                }
                
                content << [
                    type: "text",
                    text: new groovy.json.JsonBuilder(compactData).toString()
                ]
            } else if (renderMode == "aria" && semanticState) {
                // Return ARIA accessibility tree format
                def ariaTree = convertToAriaTree(semanticState, screenPath)
                def ariaResult = [
                    screenPath: screenPath,
                    aria: ariaTree
                ]
                
                // Include summary if available
                if (wikiInstructions) {
                    def summary = extractSummary(wikiInstructions)
                    if (summary) ariaResult.summary = summary
                }
                
                // Add action result if an action was executed
                if (actionResult) {
                    ariaResult.actionResult = actionResult
                }
                
                content << [
                    type: "text",
                    text: new groovy.json.JsonBuilder(ariaResult).toString()
                ]
            } else if ((renderMode == "mcp" || renderMode == "json") && semanticState) {
                // Return structured MCP data
                def mcpResult = [
                    screenPath: screenPath,
                    screenUrl: screenUrl,
                    executionTime: executionTime,
                    isError: isError,
                    semanticState: semanticState
                ]
                
                // Add action result if an action was executed
                if (actionResult) {
                    mcpResult.actionResult = actionResult
                }
                
                // Include text output preview (truncated for readability)
                if (output) {
                    mcpResult.textPreview = output.take(2000) + (output.length() > 2000 ? "..." : "")
                }
                if (wikiInstructions) {
                    mcpResult.wikiInstructions = wikiInstructions
                    def summary = extractSummary(wikiInstructions)
                    if (summary) mcpResult.summary = summary
                }
                
                content << [
                    type: "text",
                    text: new groovy.json.JsonBuilder(mcpResult).toString()
                ]
            } else {
                // Return raw output for other modes (text, html, etc)
                def textOutput = output
                if (wikiInstructions) {
                    textOutput = "--- Wiki Instructions ---\n\n${wikiInstructions}\n\n--- Screen Output ---\n\n${output}"
                }
                content << [
                    type: "text",
                    text: textOutput,
                    screenPath: screenPath,
                    screenUrl: screenUrl,
                    executionTime: executionTime,
                    isError: isError
                ]
            }
            
            result = [
                content: content,
                isError: false
            ]
            return // Success!

        } catch (Exception e) {
            isError = true
            ec.logger.error("MCP Screen Execution: Full exception for ${screenPath}", e)
            output = "SCREEN RENDERING ERROR: ${e.message}"
            result = [
                isError: true,
                content: [[type: "text", text: output]]
            ]
        }
    ]]></script>
</actions>
</service>

    <service verb="mcp" noun="ResourcesTemplatesList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/templates/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // For now, return empty templates list - can be extended later
                def templates = []
                
                result = [resourceTemplates: templates]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ResourcesSubscribe" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/subscribe request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"><description>Resource URI to subscribe to</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Resource subscription requested for URI: ${uri}, sessionId: ${sessionId}")
                
                // For now, just return success - actual subscription tracking could be added
                result = [subscribed: true, uri: uri]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ResourcesUnsubscribe" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/unsubscribe request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"><description>Resource URI to unsubscribe from</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Resource unsubscription requested for URI: ${uri}, sessionId: ${sessionId}")
                
                // For now, just return success - actual subscription tracking could be added
                result = [unsubscribed: true, uri: uri]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="PromptsList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP prompts/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonSlurper
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("MCP PromptsList: Listing prompts from wiki space MCP_PROMPTS")
                
                def prompts = []
                
                // Query all wiki pages in MCP_PROMPTS space
                def wikiPageList = ec.entity.find("moqui.resource.wiki.WikiPage")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .useCache(true)
                    .list()
                
                for (def wp in wikiPageList) {
                    // Try to load argument schema from attachment
                    def arguments = []
                    try {
                        def attachment = ec.entity.find("moqui.resource.wiki.WikiPageAttachment")
                            .condition("wikiPageId", wp.wikiPageId)
                            .condition("filename", "arguments.json")
                            .one()
                        if (attachment) {
                            def attachmentRef = ec.resource.getLocationReference(attachment.getLocation())
                            def jsonText = attachmentRef?.getText()
                            if (jsonText) {
                                arguments = new JsonSlurper().parseText(jsonText) ?: []
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not parse arguments for ${wp.pagePath}: ${e.message}")
                    }
                    
                    prompts << [
                        name: wp.pagePath,
                        title: wp.pagePath.split('-').collect { it.capitalize() }.join(' '),
                        description: "MCP prompt template",
                        arguments: arguments
                    ]
                }
                
                result = [prompts: prompts]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="PromptsGet" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP prompts/get request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="name" required="true"><description>Prompt name to retrieve</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.text.GStringTemplateEngine
                import groovy.json.JsonSlurper
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("MCP PromptsGet: Retrieving prompt '${name}' from wiki space MCP_PROMPTS")
                
                // Get the wiki page for this prompt
                def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .condition("pagePath", name)
                    .one()
                
                if (!wikiPage) {
                    throw new Exception("Prompt not found: ${name}")
                }
                
                // Get the wiki space to build the page location
                def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .one()
                
                if (!wikiSpace) {
                    throw new Exception("MCP Prompts wiki space not found")
                }
                
                // Build the resource location for the page (root + page path + .md)
                def pageLocation = wikiSpace.rootPageLocation
                if (!pageLocation.endsWith('/')) {
                    pageLocation += '/'
                }
                pageLocation += name + '.md'
                
                // Get the resource reference and text content
                def pageRef = ec.resource.getLocationReference(pageLocation)
                def templateText = pageRef?.getText()
                
                if (!templateText) {
                    throw new Exception("Prompt template not found: ${name}")
                }
                
                // Render template using Groovy GString engine
                def templateEngine = new GStringTemplateEngine()
                def template = templateEngine.createTemplate(templateText)
                def binding = arguments ?: [:]
                def rendered = template.make(binding).toString()
                
                ec.logger.info("MCP PromptsGet: Rendered prompt '${name}' with ${binding.size()} arguments")
                
                result = [
                    description: "MCP prompt template",
                    messages: [[
                        role: "user",
                        content: [type: "text", text: rendered]
                    ]]
                ]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="RootsList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP roots/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // For now, return empty roots list - can be extended later
                def roots = []
                
                result = [roots: roots]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="SamplingCreateMessage" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP sampling/createMessage request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="messages" type="List"><description>List of messages to sample</description></parameter>
            <parameter name="maxTokens" type="Integer"><description>Maximum tokens to generate</description></parameter>
            <parameter name="temperature" type="BigDecimal"><description>Sampling temperature</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Sampling createMessage requested for sessionId: ${sessionId}")
                
                // For now, return not implemented - can be extended with actual LLM integration
                result = [error: "Sampling not implemented"]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ElicitationCreate" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP elicitation/create request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="prompt"><description>Prompt for elicitation</description></parameter>
            <parameter name="context"><description>Context for elicitation</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Elicitation create requested for sessionId: ${sessionId}")
                
                // For now, return not implemented - can be extended later
                result = [error: "Elicitation not implemented"]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="BrowseScreens" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Browse Moqui screens hierarchically to discover functionality. Renders screen content with renderMode='mcp' by default. Supports action parameter for form submission and transitions.</description>
        <in-parameters>
            <parameter name="path" required="false"><description>Screen path to browse (e.g. 'PopCommerce'). Leave empty for root apps.</description></parameter>
            <parameter name="action"><description>Action to process before rendering: null (browse), 'submit' (form), 'create', 'update', or transition name</description></parameter>
            <parameter name="renderMode" default="compact"><description>Render mode: compact (default, actionable summary), aria (accessibility tree), mcp (full metadata), text, html, xml, vuet, qvt</description></parameter>
            <parameter name="parameters" type="Map"><description>Parameters to pass to screen during rendering or action</description></parameter>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext

                ExecutionContext ec = context.ec
                ec.logger.info("BrowseScreens: SERVICE STARTED")
                def subscreens = []
                def currentPath = path ?: "root"
                def userGroups = ec.user.getUserGroupIdSet().collect { it }

                // Strip query parameters from path for screen resolution
                if (currentPath.contains("?")) {
                    currentPath = currentPath.split("\\?")[0]
                }
                
                // Helper to load wiki content for a specific path (no hierarchy walk)
                def loadWikiContentForPath = { simplePath ->
                    try {
                        ec.logger.debug("BrowseScreens: Looking up wiki instructions for ${simplePath}")

                        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                            .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                            .condition("pagePath", simplePath)
                            .useCache(true)
                            .one()

                        if (wikiPage) {
                            ec.logger.debug("BrowseScreens: Found wikiPage: ${wikiPage.pagePath}")
                            def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                                .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                                .one()

                            if (wikiSpace) {
                                def dbResource = ec.entity.find("moqui.resource.DbResource")
                                    .condition("parentResourceId", "WIKI_MCP_SCREEN_DOCS")
                                    .condition("filename", wikiPage.pagePath + ".md")
                                    .one()

                                if (dbResource) {
                                    def dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                        .condition("resourceId", dbResource.resourceId)
                                        .condition("versionName", wikiPage.publishedVersionName)
                                        .one()

                                    if (!dbResourceFile) {
                                        dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                            .condition("resourceId", dbResource.resourceId)
                                            .one()
                                    }

                                    if (dbResourceFile && dbResourceFile.fileData) {
                                        def content = new String(dbResourceFile.fileData.getBytes(new Long(1).longValue(), new Long(dbResourceFile.fileData.length()).intValue()), "UTF-8")
                                        ec.logger.debug("BrowseScreens: Found wiki instructions for ${simplePath}, length: ${content?.length()}")
                                        return content
                                    }
                                }
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("BrowseScreens: Error getting wiki instructions for ${simplePath}: ${e.message}")
                    }
                    return null
                }
                
                // Helper function to load wiki content with path hierarchy walk
                // Walks up the path hierarchy to find the most specific wiki doc available
                // e.g., for "Catalog/Product/EditProduct/Assocs", tries in order:
                //   1. Catalog/Product/EditProduct/Assocs (most specific)
                //   2. Catalog/Product/EditProduct
                //   3. Catalog/Product
                //   4. Catalog
                def loadWikiContent = { path ->
                    ec.logger.info("BrowseScreens: loadWikiContent CALLED for ${path}")
                    
                    if (!path || path == "root") {
                        // For root, try exact match only
                        return loadWikiContentForPath("root")
                    }
                    
                    def simplePath = path
                    if (simplePath.contains("?")) {
                        simplePath = simplePath.split("\\?")[0]
                    }
                    // Normalize - remove leading/trailing slashes
                    simplePath = simplePath.replaceAll('^/+', '').replaceAll('/+$', '')
                    
                    if (!simplePath) return null
                    
                    // Build list of paths from most specific to least specific
                    def segments = simplePath.split('/')
                    for (int i = segments.length; i > 0; i--) {
                        def tryPath = segments[0..i-1].join('/')
                        def content = loadWikiContentForPath(tryPath)
                        if (content) {
                            if (tryPath != simplePath) {
                                ec.logger.info("BrowseScreens: Found inherited wiki docs at ${tryPath} for ${simplePath}")
                            }
                            return content
                        }
                    }
                    return null
                }

                // Helper to convert full component path to simple path (PopCommerce/screen/Root.xml -> PopCommerce/Root)
                def convertToSimplePath = { fullPath ->
                    if (!fullPath) return null
                    String cleanPath = fullPath
                    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
                    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
                    List<String> parts = cleanPath.split('/').toList()
                    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
                    return parts.join('/')
                }

                // Helper to extract short description from wiki content
                def getShortDescription = { wikiText ->
                    if (!wikiText) return null
                    def textString = wikiText instanceof String ? wikiText : new String(wikiText, "UTF-8")
                    def lines = textString.split('\n')
                    for (def line : lines) {
                        if (line.trim() && !line.trim().startsWith('#')) {
                            return line.trim().take(200)
                        }
                    }
                    return null
                }

                def resolvedScreenDef = null
                if (currentPath == "root") {
                    // Discover top-level applications
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_XML_SCREEN")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                        
                    def rootScreens = new HashSet()
                    for (def aacv in aacvList) {
                        def name = aacv.artifactName
                        if (name.startsWith("component://") && name.endsWith(".xml")) {
                            def parts = name.substring(12).split('/')
                            if (parts.length >= 3 && parts[1] == "screen") {
                                def filename = parts[parts.length - 1]
                                def componentName = parts[0]
                                if (filename == componentName + ".xml" || filename == componentName + "Admin.xml" || filename == componentName + "Root.xml" || filename == "webroot.xml") {
                                    rootScreens.add(name)
                                }
                            }
                        }
                    }
                    
                    for (def screenPath in rootScreens) {
                        def simplePath = convertToSimplePath(screenPath)
                        def wikiContent = loadWikiContent(simplePath)
                        def description = wikiContent ? getShortDescription(wikiContent) : "Application: ${simplePath}"
                        subscreens << [
                            path: simplePath,
                            description: description
                        ]
                    }
                } else {
                    // Forward slash path resolution using Moqui standard with robust component-based fallback
                    def webrootSd = ec.screen.getScreenDefinition("component://webroot/screen/webroot.xml")
                    def pathSegments = []
                    currentPath.split('/').each { if (it && it.trim()) pathSegments.add(it) }
                    
                    // 1. Try literal resolution from webroot
                    def screenPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                        webrootSd, webrootSd, pathSegments, currentPath, [:], ec.screenFacade
                    )
                    
                    def currentSd = webrootSd
                    def reachedIndex = -1
                    if (screenPathList) {
                        for (int i = 0; i < screenPathList.size(); i++) {
                            def screenName = screenPathList[i]
                            def ssi = currentSd?.getSubscreensItem(screenName)
                            if (ssi && ssi.getLocation()) {
                                currentSd = ec.screen.getScreenDefinition(ssi.getLocation())
                                reachedIndex = i
                            } else {
                                break
                            }
                        }
                    }
                    
                    resolvedScreenDef = currentSd

                    // 2. If literal resolution failed, try Component-based resolution
                    if (reachedIndex == -1 && pathSegments.size() >= 2) {
                        def componentName = pathSegments[0]
                        def rootScreenName = pathSegments[1]
                        def compRootLoc = "component://${componentName}/screen/${rootScreenName}.xml"
                        
                        if (ec.resource.getLocationReference(compRootLoc).exists) {
                            ec.logger.info("BrowseScreens Path Resolution: Found component root at ${compRootLoc}")
                            resolvedScreenDef = ec.screen.getScreenDefinition(compRootLoc)
                            def subScreenPath = pathSegments.size() > 2 ? pathSegments[2..-1].join('/') : ""
                            
                            // Resolve further if there are remaining segments
                            if (subScreenPath) {
                                def remainingSegments = pathSegments[2..-1]
                                def compPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                                    resolvedScreenDef, resolvedScreenDef, remainingSegments, subScreenPath, [:], ec.screenFacade
                                )
                                if (compPathList) {
                                    for (String screenName in compPathList) {
                                        def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                        if (ssi && ssi.getLocation()) {
                                            resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                        } else {
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // 3. Fallback to double-slash search if still not found
                    if (reachedIndex == -1 && resolvedScreenDef == webrootSd && pathSegments.size() > 0 && !currentPath.startsWith("//")) {
                        def searchPath = "//" + pathSegments.join('/')
                        ec.logger.info("BrowseScreens Path Resolution: Fallback to search path ${searchPath}")
                        
                        def searchPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                            webrootSd, webrootSd, pathSegments, searchPath, [:], ec.screenFacade
                        )
                        
                        if (searchPathList) {
                            resolvedScreenDef = webrootSd
                            for (String screenName in searchPathList) {
                                def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                if (ssi && ssi.getLocation()) {
                                    resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                } else {
                                    break
                                }
                            }
                        }
                    }

                    if (resolvedScreenDef) {
                        resolvedScreenDef.getSubscreensItemsSorted().each { subItem ->
                            def subName = subItem.getName()
                            def subPath = currentPath + "/" + subName
                            def wikiContent = loadWikiContent(subPath)
                            subscreens << [
                                path: subPath,
                                description: wikiContent ? getShortDescription(wikiContent) : "Subscreen: ${subName}"
                            ]
                        }
                    }
                }
                
                // Process action before rendering
                // Action execution is now handled by ScreenAsMcpTool via framework's transition handling
                // Just log that we're passing the action through
                if (action) {
                    ec.logger.info("BrowseScreens: Passing action '${action}' to ScreenAsMcpTool for framework execution")
                }
                
                // Try to get wiki instructions for screen
                def wikiInstructions = null

                ec.logger.info("BrowseScreens: About to check wiki instructions, currentPath='${currentPath}', isRoot=${currentPath == 'root'}")

                wikiInstructions = loadWikiContent(currentPath)

                // Render current screen if not root browsing
                def renderedContent = null
                def renderError = null
                def actualRenderMode = renderMode ?: "compact"

                def resultMap = [
                    currentPath: currentPath,
                    subscreens: subscreens,
                    renderMode: actualRenderMode
                ]
                
                // Add global navigation - these are always available regardless of current app
                // Mirrors the MyAccountNav component in the web UI
                resultMap.globalNav = [
                    [name: "My Notifications", path: "apps/my/User/Notifications", icon: "info"],
                    [name: "My Messages", path: "apps/my/User/Messages/FindMessage", icon: "message"],
                    [name: "My Calendar", path: "apps/my/User/Calendar/MyCalendar", icon: "calendar"],
                    [name: "My Tasks", path: "apps/my/User/Task/MyTasks", icon: "tasks"]
                ]

                if (currentPath != "root") {
                    try {
                        ec.logger.info("BrowseScreens: Rendering screen ${currentPath} with mode=${actualRenderMode}")

                        // Pass forward-slash path directly to ScreenAsMcpTool
                        // ScreenAsMcpTool will use Moqui's ScreenUrlInfo.parseSubScreenPath to navigate through screen hierarchy
                        // Action is passed through for framework-based transition execution
                        def browseScreenCallParams = [
                            path: path,
                            parameters: parameters ?: [:],
                            action: action,  // Let ScreenAsMcpTool handle via framework
                            renderMode: actualRenderMode,
                            sessionId: sessionId
                        ]

                        // Call ScreenAsMcpTool to render
                        def browseResult = ec.service.sync().name("McpServices.execute#ScreenAsMcpTool")
                            .parameters(browseScreenCallParams)
                            .call()

                        // Extract rendered content and semantic state from result
                        if (browseResult) {
                            def resultObj = null
                            // ScreenAsMcpTool returns {result: {content: [...]}}
                            if (browseResult.result) {
                                def contentList = browseResult.result.content
                                if (contentList && contentList.size() > 0) {
                                    def rawText = contentList[0].text
                                    if (rawText && rawText.startsWith("{")) {
                                        try { resultObj = new groovy.json.JsonSlurper().parseText(rawText) } catch(e) {}
                                    }
                                    renderedContent = rawText
                                }
                            }

                            // Handle compact mode - pass through compact data directly
                            if ((actualRenderMode == "compact" || actualRenderMode == null) && resultObj && resultObj.screen) {
                                // Compact mode returns flat structure, merge it into resultMap
                                resultObj.each { k, v -> if (k != "screen") resultMap[k] = v }
                                resultMap.screen = resultObj.screen
                                ec.logger.info("BrowseScreens: Compact mode - passing through for ${currentPath}")
                            // Handle ARIA mode - pass through the aria tree directly
                            } else if (actualRenderMode == "aria" && resultObj && resultObj.aria) {
                                resultMap.aria = resultObj.aria
                                if (resultObj.summary) resultMap.summary = resultObj.summary
                                ec.logger.info("BrowseScreens: ARIA mode - passing through aria tree for ${currentPath}")
                            } else if (resultObj && resultObj.semanticState) {
                                resultMap.semanticState = resultObj.semanticState

                                // Build UI narrative for LLM guidance
                                try {
                                    def narrativeBuilder = new org.moqui.mcp.UiNarrativeBuilder()
                                    // Use the screen definition we already resolved
                                    def screenDefForNarrative = resolvedScreenDef

                                    def uiNarrative = narrativeBuilder.buildNarrative(
                                        screenDefForNarrative,
                                        resultObj.semanticState,
                                        currentPath
                                    )
                                    resultMap.uiNarrative = uiNarrative
                                    ec.logger.info("BrowseScreens: Generated UI narrative for ${currentPath}: ${uiNarrative?.keySet()}")
                                } catch (Exception e) {
                                    ec.logger.warn("BrowseScreens: Failed to generate UI narrative: ${e.message}")
                                }
                            }
                        }

                        ec.logger.info("BrowseScreens: Successfully rendered screen ${currentPath}, content length: ${renderedContent?.length() ?: 0}")
                    } catch (Exception e) {
                        renderError = "Screen rendering failed: ${e.message}"
                        ec.logger.warn("BrowseScreens render error for ${currentPath}: ${e.message}")
                    }
                }
                
                if (actionResult) {
                    resultMap.actionResult = actionResult
                }

                // Don't include renderedContent for renderMode "mcp", "aria", or "compact" - structured data is provided instead
                // Including both duplicates data and truncation breaks JSON structure
                if (renderedContent && actualRenderMode != "mcp" && actualRenderMode != "aria" && actualRenderMode != "compact") {
                    resultMap.renderedContent = renderedContent
                }
                
                if (actionError) {
                    resultMap.actionError = actionError
                }

                if (wikiInstructions) {
                    resultMap.wikiInstructions = wikiInstructions
                    // Extract first non-header paragraph as summary
                    def summary = getShortDescription(wikiInstructions)
                    if (summary) {
                        resultMap.summary = summary
                    }
                }

                if (renderError) {
                    resultMap.renderError = renderError
                }
                
                // Return in MCP format - content array as direct child of result
                result = [
                    content: [[type: "text", text: new groovy.json.JsonBuilder(resultMap).toString()]],
                    isError: false
                ]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="SearchScreens" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Search for screens by name, path, or description. Builds an index by walking the screen tree.</description>
        <in-parameters>
            <parameter name="query" required="true"/>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def matches = []
                def queryLower = query.toLowerCase()
                
                // Screen index cache key - use Moqui's cache API properly
                def cacheKey = "MCP_SCREEN_INDEX"
                def mcpCache = ec.cache.getCache("mcp.screen.index")
                def screenIndex = mcpCache.get(cacheKey)
                
                if (!screenIndex) {
                    ec.logger.info("SearchScreens: Building screen index...")
                    screenIndex = []
                    
                    // Helper to load wiki description for a path
                    def loadWikiDescription = { simplePath ->
                        try {
                            def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                                .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                                .condition("pagePath", simplePath)
                                .useCache(true)
                                .one()
                            
                            if (wikiPage) {
                                def dbResource = ec.entity.find("moqui.resource.DbResource")
                                    .condition("parentResourceId", "WIKI_MCP_SCREEN_DOCS")
                                    .condition("filename", wikiPage.pagePath + ".md")
                                    .one()
                                
                                if (dbResource) {
                                    def dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                        .condition("resourceId", dbResource.resourceId)
                                        .one()
                                    
                                    if (dbResourceFile && dbResourceFile.fileData) {
                                        def content = new String(dbResourceFile.fileData.getBytes(1L, dbResourceFile.fileData.length() as int), "UTF-8")
                                        // Extract first line or sentence as description
                                        def lines = content.split('\n')
                                        for (line in lines) {
                                            line = line.trim()
                                            if (line && !line.startsWith('#')) {
                                                return line.length() > 150 ? line.substring(0, 147) + "..." : line
                                            }
                                        }
                                    }
                                }
                            }
                        } catch (Exception e) {
                            ec.logger.debug("SearchScreens: Error loading wiki for ${simplePath}: ${e.message}")
                        }
                        return null
                    }
                    
                    // Recursive function to walk screen tree
                    def walkScreenTree
                    walkScreenTree = { screenDef, basePath, depth ->
                        if (depth > 6 || !screenDef) return  // Limit depth to prevent infinite loops
                        
                        try {
                            screenDef.getSubscreensItemsSorted().each { subItem ->
                                def subName = subItem.getName()
                                def subPath = basePath ? "${basePath}/${subName}" : subName
                                def subLocation = subItem.getLocation()
                                
                                if (subLocation) {
                                    // Get wiki description or generate from name
                                    def description = loadWikiDescription(subPath)
                                    if (!description) {
                                        // Generate description from screen name
                                        def humanName = subName.replaceAll(/([A-Z])/, ' $1').trim()
                                        description = "Screen: ${humanName}"
                                    }
                                    
                                    // Extract screen name for search
                                    def screenName = subName
                                    
                                    screenIndex << [
                                        path: subPath,
                                        name: screenName,
                                        description: description,
                                        depth: depth
                                    ]
                                    
                                    // Recurse into subscreen
                                    try {
                                        def subScreenDef = ec.screen.getScreenDefinition(subLocation)
                                        if (subScreenDef) {
                                            walkScreenTree(subScreenDef, subPath, depth + 1)
                                        }
                                    } catch (Exception e) {
                                        ec.logger.debug("SearchScreens: Could not load subscreen ${subPath}: ${e.message}")
                                    }
                                }
                            }
                        } catch (Exception e) {
                            ec.logger.debug("SearchScreens: Error walking ${basePath}: ${e.message}")
                        }
                    }
                    
                    // Start from webroot
                    def webrootSd = ec.screen.getScreenDefinition("component://webroot/screen/webroot.xml")
                    if (webrootSd) {
                        walkScreenTree(webrootSd, "", 0)
                    }
                    
                    // Cache the index
                    mcpCache.put(cacheKey, screenIndex)
                    ec.logger.info("SearchScreens: Built index with ${screenIndex.size()} screens")
                }
                
                // Search the index
                def scored = []
                for (screen in screenIndex) {
                    def score = 0
                    def nameLower = screen.name?.toLowerCase() ?: ""
                    def pathLower = screen.path?.toLowerCase() ?: ""
                    def descLower = screen.description?.toLowerCase() ?: ""
                    
                    // Exact name match (highest priority)
                    if (nameLower == queryLower) {
                        score += 100
                    }
                    // Name starts with query
                    else if (nameLower.startsWith(queryLower)) {
                        score += 50
                    }
                    // Name contains query
                    else if (nameLower.contains(queryLower)) {
                        score += 30
                    }
                    
                    // Path contains query
                    if (pathLower.contains(queryLower)) {
                        score += 20
                    }
                    
                    // Description contains query
                    if (descLower.contains(queryLower)) {
                        score += 10
                    }
                    
                    // Prefer shallower screens (more likely to be entry points)
                    if (score > 0) {
                        score -= (screen.depth ?: 0) * 2
                        scored << [screen: screen, score: score]
                    }
                }
                
                // Sort by score descending, take top 15
                scored.sort { -it.score }
                def topMatches = scored.take(15)
                
                for (item in topMatches) {
                    matches << [
                        path: item.screen.path,
                        name: item.screen.name,
                        description: item.screen.description
                    ]
                }
                
                // Add hint if no matches
                def hint = null
                if (matches.isEmpty()) {
                    hint = "No screens found matching '${query}'. Try broader terms like 'product', 'order', 'party', or use moqui_browse_screens to explore."
                } else if (matches.size() >= 15) {
                    hint = "Showing top 15 results. Refine your search for more specific matches."
                }
                
                def resultMap = hint ? [matches: matches, hint: hint] : [matches: matches]
                
                // Return in MCP format - content array with JSON text
                result = [
                    content: [[type: "text", text: new groovy.json.JsonBuilder(resultMap).toString()]],
                    isError: false
                ]
            ]]></script>
        </actions>
    </service>

    <service verb="list" noun="Tools" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>List discovery tools and the unified screen renderer.</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                def tools = [
                    [
                        name: "moqui_browse_screens",
                        title: "Browse Screens",
                        description: "Browse Moqui screen hierarchy, process actions, and render screen content. Input 'path' (empty for root). Default renderMode is 'mcp'.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "path": [type: "string", description: "Path to browse (e.g. 'PopCommerce')"],
                                "action": [type: "string", description: "Action to process before rendering: null (browse), 'submit' (form), 'create', 'update', or transition name"],
                                "renderMode": [type: "string", description: "Render mode: compact (default, actionable summary), aria (accessibility tree), mcp (full metadata), text, html, xml, vuet, qvt"],
                                "parameters": [type: "object", description: "Parameters to pass to screen during rendering or action"]
                            ]
                        ]
                    ],
                    [
                        name: "moqui_search_screens",
                        title: "Search Screens",
                        description: "Search for screens by name to find their paths.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "query": [type: "string", description: "Search query"]
                            ],
                            required: ["query"]
                        ]
                     ],
                     [
                        name: "moqui_get_screen_details",
                        title: "Get Screen Details",
                        description: "Get screen field details including dropdown options. Use this to understand available fields and their options before submitting forms.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "path": [type: "string", description: "Screen path to analyze (e.g., 'PopCommerce/PopCommerceAdmin/Party/FindParty')"],
                                "fieldName": [type: "string", description: "Optional specific field name. If not provided, returns all fields."],
                                "parameters": [type: "object", description: "Optional parameters to set in context before rendering (for autocomplete contexts)."]
                            ],
                            required: ["path"]
                        ]
                     ],
                     [
                        name: "moqui_get_help",
                        title: "Get Help",
                        description: "Fetch extended documentation for a screen or service. Use URIs from 'describedby' fields in ARIA responses.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "uri": [type: "string", description: "Help URI (e.g., 'wiki:screen:EditProduct' or 'wiki:service:ProductFeature')"]
                            ],
                            required: ["uri"]
                        ]
                     ],
                     [
                        name: "moqui_batch_operations",
                        title: "Batch Operations",
                        description: "Execute multiple screen operations in sequence. Stops on first error. Returns results for each operation.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "operations": [
                                    type: "array",
                                    description: "Array of operations to execute in sequence",
                                    items: [
                                        type: "object",
                                        properties: [
                                            "id": [type: "string", description: "Optional operation identifier for result tracking"],
                                            "path": [type: "string", description: "Screen path"],
                                            "action": [type: "string", description: "Action/transition to execute"],
                                            "parameters": [type: "object", description: "Parameters for the action"]
                                        ],
                                        required: ["path", "action"]
                                    ]
                                ],
                                "stopOnError": [type: "boolean", description: "Stop execution on first error (default: true)"],
                                "returnLastOnly": [type: "boolean", description: "Return only last operation result (default: false)"]
                            ],
                            required: ["operations"]
                        ]
                     ],
                      [
                        name: "prompts_list",
                        title: "List Prompts",
                        description: "List available MCP prompt templates.",
                        inputSchema: [
                            type: "object",
                            properties: [:]
                        ]
                    ],
                    [
                        name: "prompts_get",
                        title: "Get Prompt",
                        description: "Retrieve and render a specific MCP prompt template.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "name": [type: "string", description: "Prompt name"],
                                "arguments": [type: "object", description: "Arguments for prompt template"]
                            ],
                            required: ["name"]
                        ]
                    ]
                ]
                
                result = [tools: tools]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="GetScreenDetails" authenticate="true" allow-remote="true" transaction-timeout="60">
        <description>Get screen field details including dropdown options. Use this to understand available fields and their options before submitting forms.</description>
        <in-parameters>
            <parameter name="path" required="true"><description>Screen path to analyze (e.g., '/PopCommerce/PopCommerceAdmin/Party/FindParty').</description></parameter>
            <parameter name="fieldName"><description>Optional specific field name. If not provided, returns all fields.</description></parameter>
            <parameter name="parameters" type="Map"><description>Optional parameters to set in context before rendering (for autocomplete contexts).</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                import org.moqui.mcp.McpFieldOptionsService
                
                ExecutionContext ec = context.ec
                
                def serviceResult = McpFieldOptionsService.service(path, fieldName, parameters, ec)
                
                // Return in standard MCP format with content array
                def resultJson = new JsonBuilder(serviceResult).toString()
                result = [
                    content: [[type: "text", text: resultJson]],
                    isError: false
                ]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="GetHelp" authenticate="true" allow-remote="true" transaction-timeout="30">
        <description>Fetch extended documentation for a screen or service. Use URIs from 'describedby' fields in ARIA responses.</description>
        <in-parameters>
            <parameter name="uri" required="true"><description>Help URI (e.g., 'wiki:screen:EditProduct' or 'wiki:service:ProductFeature')</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                def content = null
                def metadata = [uri: uri]
                
                // Parse URI format: wiki:type:name
                // e.g., wiki:screen:EditProduct, wiki:service:ProductFeature
                if (uri?.startsWith("wiki:")) {
                    def parts = uri.split(":", 3)
                    if (parts.length >= 3) {
                        def wikiType = parts[1]  // screen, service
                        def pageName = parts[2]
                        
                        metadata.type = wikiType
                        metadata.name = pageName
                        
                        // Determine wiki space based on type
                        def wikiSpaceId = null
                        def pagePath = null
                        
                        switch (wikiType) {
                            case "screen":
                                wikiSpaceId = "MCP_SCREEN_DOCS"
                                // Try to find by screen name in page path
                                pagePath = pageName
                                break
                            case "service":
                                wikiSpaceId = "MCP_SERVICE_DOCS"
                                pagePath = pageName
                                break
                            default:
                                wikiSpaceId = "MCP_SCREEN_DOCS"
                                pagePath = pageName
                        }
                        
                        // Try to find wiki page by path
                        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                            .condition("wikiSpaceId", wikiSpaceId)
                            .condition("pagePath", pagePath)
                            .useCache(true)
                            .one()
                        
                        // If not found by exact path, try partial match
                        if (!wikiPage) {
                            def allPages = ec.entity.find("moqui.resource.wiki.WikiPage")
                                .condition("wikiSpaceId", wikiSpaceId)
                                .useCache(true)
                                .list()
                            wikiPage = allPages.find { it.pagePath?.endsWith(pagePath) || it.pagePath?.contains(pagePath) }
                        }
                        
                        if (wikiPage) {
                            // Use direct DbResource/DbResourceFile lookup (like BrowseScreens does)
                            def parentResourceId = (wikiType == "service") ? "WIKI_MCP_SERVICE_DOCS" : "WIKI_MCP_SCREEN_DOCS"
                            
                            def dbResource = ec.entity.find("moqui.resource.DbResource")
                                .condition("parentResourceId", parentResourceId)
                                .condition("filename", wikiPage.pagePath + ".md")
                                .one()
                            

                            
                            if (dbResource) {
                                def dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                    .condition("resourceId", dbResource.resourceId)
                                    .condition("versionName", wikiPage.publishedVersionName)
                                    .one()
                                
                                if (!dbResourceFile) {
                                    dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                        .condition("resourceId", dbResource.resourceId)
                                        .one()
                                }
                                
                                if (dbResourceFile && dbResourceFile.fileData) {
                                    content = new String(dbResourceFile.fileData.getBytes(new Long(1).longValue(), new Long(dbResourceFile.fileData.length()).intValue()), "UTF-8")
                                    metadata.found = true
                                    metadata.pagePath = wikiPage.pagePath
                                    metadata.resourceId = dbResource.resourceId
                                }
                            }
                        }
                        
                        if (!content) {
                            metadata.found = false
                            content = "No documentation found for ${wikiType}: ${pageName}. Available documentation can be found in the MCP_SCREEN_DOCS and MCP_SERVICE_DOCS wiki spaces."
                        }
                    }
                } else {
                    metadata.error = "Invalid URI format. Expected 'wiki:type:name' (e.g., 'wiki:service:ProductFeature')"
                    content = metadata.error
                }
                
                def resultData = [
                    content: content,
                    metadata: metadata
                ]
                
                result = [
                    content: [[type: "text", text: new JsonBuilder(resultData).toString()]],
                    isError: false
                ]
            ]]></script>
        </actions>
    </service>

    <!-- NOTE: handle#McpRequest service removed - functionality moved to screen/webapp.xml for unified handling -->

    <service verb="mcp" noun="BatchOperations" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Execute multiple screen operations in sequence. Stops on first error by default. Returns results for each operation.</description>
        <in-parameters>
            <parameter name="operations" type="List" required="true"><description>Array of operations to execute in sequence</description></parameter>
            <parameter name="stopOnError" type="Boolean" default="true"><description>Stop execution on first error (default: true)</description></parameter>
            <parameter name="returnLastOnly" type="Boolean" default="false"><description>Return only last operation result (default: false)</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                import groovy.json.JsonSlurper
                
                ExecutionContext ec = context.ec
                
                def results = []
                def hasError = false
                def lastResult = null
                def executedCount = 0
                
                ec.logger.info("BatchOperations: Starting batch with ${operations?.size()} operations, stopOnError=${stopOnError}")
                
                for (int i = 0; i < operations.size(); i++) {
                    def op = operations[i]
                    def opId = op.id ?: "op_${i + 1}"
                    
                    ec.logger.info("BatchOperations: Executing operation ${opId}: path=${op.path}, action=${op.action}")
                    
                    try {
                        // Call browse screens for each operation
                        def browseResult = ec.service.sync().name("McpServices.mcp#BrowseScreens")
                            .parameters([
                                path: op.path,
                                action: op.action,
                                parameters: op.parameters ?: [:],
                                renderMode: "compact"  // Use compact mode for efficiency
                            ])
                            .call()
                        
                        // Extract the result content
                        def opResult = [
                            id: opId,
                            path: op.path,
                            action: op.action,
                            status: "success"
                        ]
                        
                        // Parse the result to check for errors
                        if (browseResult?.result?.content) {
                            def contentList = browseResult.result.content
                            if (contentList && contentList.size() > 0) {
                                def rawText = contentList[0].text
                                if (rawText && rawText.startsWith("{")) {
                                    try {
                                        def parsed = new JsonSlurper().parseText(rawText)
                                        
                                        // Check if there's an action result with error
                                        if (parsed.result?.status == "error" || parsed.actionResult?.status == "error") {
                                            opResult.status = "error"
                                            opResult.message = parsed.result?.message ?: parsed.actionResult?.message
                                            opResult.validationErrors = parsed.result?.validationErrors ?: parsed.actionResult?.validationErrors
                                            hasError = true
                                        } else {
                                            // Success - extract relevant data
                                            opResult.result = parsed.result ?: parsed.actionResult
                                            if (parsed.result?.result) {
                                                // Copy any IDs for use in subsequent operations
                                                opResult.outputIds = parsed.result.result
                                            }
                                        }
                                    } catch (e) {
                                        // JSON parse failed, treat as success but no parsed data
                                        opResult.rawOutput = rawText
                                    }
                                }
                            }
                        }
                        
                        executedCount++
                        lastResult = opResult
                        results << opResult
                        
                        ec.logger.info("BatchOperations: Operation ${opId} completed with status=${opResult.status}")
                        
                        // Stop on error if requested
                        if (hasError && stopOnError) {
                            ec.logger.info("BatchOperations: Stopping batch due to error in operation ${opId}")
                            break
                        }
                        
                    } catch (Exception e) {
                        def opResult = [
                            id: opId,
                            path: op.path,
                            action: op.action,
                            status: "error",
                            message: "Exception: ${e.message}"
                        ]
                        results << opResult
                        lastResult = opResult
                        hasError = true
                        executedCount++
                        
                        ec.logger.error("BatchOperations: Exception in operation ${opId}: ${e.message}", e)
                        
                        if (stopOnError) {
                            break
                        }
                    }
                }
                
                def summary = [
                    totalOperations: operations.size(),
                    executedOperations: executedCount,
                    successCount: results.count { it.status == "success" },
                    errorCount: results.count { it.status == "error" },
                    hasError: hasError
                ]
                
                def resultData
                if (returnLastOnly) {
                    resultData = [
                        summary: summary,
                        result: lastResult
                    ]
                } else {
                    resultData = [
                        summary: summary,
                        results: results
                    ]
                }
                
                ec.logger.info("BatchOperations: Completed. Summary: ${summary}")
                
                result = [
                    content: [[type: "text", text: new JsonBuilder(resultData).toString()]],
                    isError: hasError
                ]
            ]]></script>
        </actions>
    </service>

</services>