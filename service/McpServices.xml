<?xml version="1.0" encoding="UTF-8"?>
<!-- This software is in the public domain under CC0 1.0 Universal plus a 
     Grant of Patent License.

     To the extent possible under law, the author(s) have dedicated all
     copyright and related and neighboring rights to this software to the
     public domain worldwide. This software is distributed without any warranty.

     You should have received a copy of the CC0 Public Domain Dedication
     along with this software (see the LICENSE.md file). If not, see
     <https://creativecommons.org/publicdomain/zero/1.0/>. -->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- MCP Services using Moqui's built-in JSON-RPC support -->
    
    
    <service verb="mcp" noun="Initialize" authenticate="true" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP initialize request using Moqui authentication</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="protocolVersion" required="true"/>
            <parameter name="capabilities" type="Map"/>
            <parameter name="clientInfo" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Permissions are handled by Moqui's artifact authorization system
                // Users must be in appropriate groups (McpUser, MCP_BUSINESS) with access to McpServices artifact group
                
                // Disable authz to prevent automatic Visit updates during MCP operations
                ec.artifactExecution.disableAuthz()
                
                // Get Visit (session) created by servlet and validate access
                def visit = ec.entity.find("moqui.server.Visit")
                    .condition("visitId", sessionId)
                    .one()
                
                if (!visit) {
                    throw new Exception("Invalid session: ${sessionId}")
                }
                
                if (visit.userId != ec.user.userId) {
                    throw new Exception("Access denied for session: ${sessionId}")
                }
                
                // Update Visit with MCP initialization data
                UserInfo adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def metadata = [:]
                    try {
                        metadata = groovy.json.JsonSlurper().parseText(visit.initialRequest ?: "{}") as Map
                    } catch (Exception e) {
                        ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                    }
                    
                    metadata.mcpInitialized = true
                    metadata.mcpProtocolVersion = protocolVersion
                    metadata.mcpCapabilities = capabilities
                    metadata.mcpClientInfo = clientInfo
                    metadata.mcpInitializedAt = System.currentTimeMillis()
                    
                    // Session metadata stored in memory only - no Visit updates to prevent lock contention
                    ec.logger.info("SESSIONID: ${sessionId} - metadata stored in memory")
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Validate protocol version - support common MCP versions with version negotiation
                def supportedVersions = ["2025-11-25", "2025-06-18", "2024-11-05", "2024-10-07", "2023-06-05"]
                if (!supportedVersions.contains(protocolVersion)) {
                    throw new Exception("Unsupported protocol version: ${protocolVersion}. Supported versions: ${supportedVersions.join(', ')}")
                }
                
                // Get current user context (if authenticated)
                def userId = ec.user.userId
                def userAccountId = userId ? userId : null
                
                // Build server capabilities - don't fetch actual tools/resources during init
                // Tools and resources will be discovered via separate list requests per MCP spec
                def serverCapabilities = [
                    tools: [listChanged: true],
                    resources: [subscribe: true, listChanged: true],
                    logging: [:]
                ]
                
                // Build server info
                def serverInfo = [
                    name: "Moqui MCP Server",
                    version: "2.0.1"
                ]
                
                result = [
                    protocolVersion: "2025-06-18",
                    capabilities: serverCapabilities,
                    serverInfo: serverInfo,
                    sessionId: sessionId,
                    instructions: "This server provides access to Moqui ERP through MCP. For common business queries: Use PopCommerce.PopCommerceAdmin.Catalog.Feature.FindFeature to search by features like color or size. Use PopCommerce.PopCommerceAdmin.Catalog.Product.FindProduct for product catalog, PopCommerce.PopCommerceAdmin.Order.FindOrder for order status, PopCommerce.PopCommerceRoot.Customer for customer management, PopCommerce.PopCommerceAdmin.Catalog.Product.EditPrices to check prices and PopCommerce.PopCommerceAdmin.QuickSearch for general searches. All screens support parameterized queries for filtering results."
                ]
                
                ec.logger.info("MCP Initialize for user ${userId} (session ${sessionId}): capabilities negotiated")
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ToolsCall" authenticate="true" allow-remote="true" transaction-timeout="300">
        <description>Handle MCP tools/call request with direct Moqui service execution</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="name" required="true"/>
            <parameter name="arguments" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                // Start timing for execution metrics
                def startTime = System.currentTimeMillis()
                def isError = false
                
                try {
                    // Consolidated Tool Dispatching
                    
                    if (name == "moqui_render_screen") {
                        def screenPath = arguments?.path
                        def parameters = arguments?.parameters ?: [:]
                        def renderMode = arguments?.renderMode ?: "mcp"
                        def subscreenName = arguments?.subscreenName
    
                        if (!screenPath) throw new Exception("moqui_render_screen requires 'path' parameter")
                        
                        ec.logger.info("MCP ToolsCall: Rendering screen path=${screenPath}, subscreen=${subscreenName}")
                        
                        // Strip query parameters from path if present
                        if (screenPath.contains("?")) {
                            screenPath = screenPath.split("\\?")[0]
                        }
                        
                        // Handle component:// or simple dot notation path
                        def resolvedPath = screenPath
                        def resolvedSubscreen = subscreenName
                        
                        if (!resolvedPath.startsWith("component://")) {
                            // Simple dot notation or path conversion
                            // Longest prefix match for XML screen files
                            def pathParts = resolvedPath.split('\\.')
                            def componentName = pathParts[0]
                            def bestPath = null
                            def bestSubscreen = null
                            
                            // Start from the longest possible XML path and work backwards
                            for (int i = pathParts.size(); i >= 1; i--) {
                                def currentTry = "component://${componentName}/screen/" + (i > 1 ? pathParts[1..<i].join('/') : componentName) + ".xml"
                                if (ec.resource.getLocationReference(currentTry).getExists()) {
                                    bestPath = currentTry
                                    if (i < pathParts.size()) {
                                        bestSubscreen = pathParts[i..-1].join('_')
                                    }
                                    break
                                }
                            }
                            
                            if (bestPath) {
                                resolvedPath = bestPath
                                resolvedSubscreen = bestSubscreen
                            } else {
                                // Fallback to original logic if nothing found
                                resolvedPath = "component://${componentName}/screen/${componentName}.xml"
                                resolvedSubscreen = pathParts.size() > 1 ? pathParts[1..-1].join('_') : null
                            }
                        }

                        def screenCallParams = [
                            screenPath: resolvedPath,
                            parameters: parameters,
                            renderMode: renderMode,
                            sessionId: sessionId
                        ]
                        if (resolvedSubscreen) screenCallParams.subscreenName = resolvedSubscreen
                        
                        def serviceResult = ec.service.sync().name("McpServices.execute#ScreenAsMcpTool")
                            .parameters(screenCallParams).call()
                            
                        // ScreenAsMcpTool returns the final result map directly
                        result = serviceResult
                        return
                    }
                    
                    // Handle internal discovery/utility tools
                    def internalToolMappings = [
                        "moqui_browse_screens": "McpServices.mcp#BrowseScreens",
                        "moqui_search_screens": "McpServices.mcp#SearchScreens",
                        "moqui_get_screen_details": "McpServices.mcp#GetScreenDetails"
                    ]
                    
                    def targetServiceName = internalToolMappings[name]
                    if (targetServiceName) {
                        def serviceResult = ec.service.sync().name(targetServiceName).parameters(arguments ?: [:]).call()
                        def actualRes = serviceResult?.result ?: serviceResult
                        // Ensure standard MCP response format with content array
                        if (actualRes instanceof Map && actualRes.content && actualRes.content instanceof List) {
                            result = actualRes
                        } else {
                            result = [ content: [[type: "text", text: new groovy.json.JsonBuilder(actualRes).toString()]], isError: false ]
                        }
                        return
                     }

                    // Fallback: check if it's a general Moqui service (non-screen-based tools)
                    if (ec.service.isServiceDefined(name)) {
                        // Execute service with current user context
                        def serviceResult = ec.service.sync().name(name).parameters(arguments ?: [:]).call()
                        // Convert result to MCP format for general services
                        result = [content: [[type: "text", text: new JsonBuilder(serviceResult).toString()]], isError: false]
                        return
                    }

                    throw new Exception("Unknown tool name: ${name}")
                } catch (Exception e) {
                    isError = true
                    
                    result = [
                        content: [
                            [
                                type: "text",
                                text: "Error executing tool ${name}: ${e.message}"
                            ]
                        ],
                        isError: true
                    ]
                    
                    ec.logger.error("MCP tool execution error", e)
                } finally {
                    // Send a simple notification about tool execution
                    try {
                        def servlet = ec.web.getServletContext().getAttribute("enhancedMcpServlet")
                        if (servlet && sessionId) {
                            def notification = [
                                method: "notifications/tool_execution",
                                params: [
                                    toolName: name,
                                    executionTime: (System.currentTimeMillis() - startTime) / 1000.0,
                                    success: !isError,
                                    timestamp: System.currentTimeMillis()
                                ]
                            ]
                            //servlet.queueNotification(sessionId, notification)
                        }
                    } catch (Exception e) {
                        ec.logger.warn("Failed to send tool execution notification: ${e.message}")
                    }
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesList" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Handle MCP resources/list request with Moqui entity discovery based on user permissions</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                def availableResources = []
                
                ec.logger.debug("MCP ResourcesList: Discovering entities for user groups: ${userGroups}")
                
                // Use ArtifactAuthzCheckView to find all entities user has permission for
                // This is the "Moqui Way" - rely on the security system to tell us what is accessible
                def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                    .condition("userGroupId", userGroups)
                    .condition("artifactTypeEnumId", "AT_ENTITY")
                    .condition("authzActionEnumId", "AUTHZA_VIEW")
                    .useCache(true)
                    .disableAuthz()
                    .list()
                
                for (def aacv in aacvList) {
                    def entityName = aacv.artifactName
                    // Basic sanity check to ensure entity is actually defined
                    if (ec.entity.isEntityDefined(entityName)) {
                        def description = "Moqui entity: ${entityName}"
                        if (entityName.contains("View")) {
                            description = "Moqui ViewEntity: ${entityName}"
                        }
                        
                        availableResources << [
                            uri: "entity://${entityName}",
                            name: entityName,
                            description: description,
                            mimeType: "application/json"
                        ]
                    }
                }
                
                // Add instructions resource for MCP_USER role
                if (userGroups.contains("McpUser")) {
                    availableResources << [
                        uri: "moqui://mcp/instructions",
                        name: "instructions",
                        description: "MCP server usage instructions",
                        mimeType: "text/plain"
                    ]
                }
                
                result = [resources: availableResources]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesRead" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Handle MCP resources/read request with Moqui entity queries</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                def startTime = System.currentTimeMillis()
                
                // Handle special moqui://mcp/instructions resource
                if (uri == "moqui://mcp/instructions") {
                    result = [
                        content: [[
                            uri: "moqui://mcp/instructions",
                            mimeType: "text/plain",
                            text: "This server provides access to Moqui ERP through MCP. For common business queries: Use PopCommerce.PopCommerceAdmin.Catalog.Feature.FindFeature to search by features like color or size. Use PopCommerce.PopCommerceAdmin.Catalog.Product.FindProduct for product catalog, PopCommerce.PopCommerceAdmin.Order.FindOrder for order status, PopCommerce.PopCommerceRoot.Customer for customer management, PopCommerce.PopCommerceAdmin.Catalog.Product.EditPrices to check prices and PopCommerce.PopCommerceAdmin.QuickSearch for general searches. All screens support parameterized queries for filtering results."
                        ]],
                        isError: false
                    ]
                    return
                }
                
                // Parse entity URI (format: entity://EntityName)
                if (!uri.startsWith("entity://")) {
                    throw new Exception("Invalid resource URI: ${uri}")
                }
                
                def entityName = uri.substring(9)
                
                if (!ec.entity.isEntityDefined(entityName)) {
                    throw new Exception("Entity not found: ${entityName}")
                }
                
                try {
                    def entityDef = null
                    try {
                        def entityInfoList = ec.entity.getAllEntityInfo(-1, true)
                        entityDef = entityInfoList.find { it.entityName == entityName }
                    } catch (Exception e) {
                        ec.logger.debug("Error getting detailed entity info: ${e.message}")
                    }
                    
                    if (!entityDef) {
                        entityDef = [
                            entityName: entityName,
                            packageName: entityName.contains('.') ? entityName.split('\\.')[0] : "",
                            description: "Entity: ${entityName}",
                            isViewEntity: entityName.contains('View'),
                            allFieldInfoList: []
                        ]
                    }
                    
                    // Query entity data
                    def entityList = ec.entity.find(entityName).limit(100).list()
                    
                    // Format response for MCP - create multiple content objects
                    def contentList = []
                    
                    // Add main content with entity data as text
                    contentList << [
                        type: "text",
                        text: new JsonBuilder([
                            entityName: entityName,
                            description: entityDef.description,
                            packageName: entityDef.packageName,
                            recordCount: entityList.size(),
                            data: entityList
                        ]).toString()
                    ]
                    
                    def responseMap = [
                        content: contentList,
                        isError: false
                    ]
                    
                    def jsonOutput = new JsonBuilder(responseMap).toString()
                    
                    // Size protection
                    def maxResponseSize = 1024 * 1024 // 1MB
                    if (jsonOutput.length() > maxResponseSize) {
                         def truncatedList = entityList.take(10)
                         responseMap.data = truncatedList
                         responseMap.truncated = true
                         responseMap.message = "Truncated to 10 records due to size."
                         jsonOutput = new JsonBuilder(responseMap).toString()
                    }
                    
                    result = [
                        content: [[
                            uri: uri,
                            mimeType: "application/json",
                            text: jsonOutput
                        ]],
                        isError: false
                    ]
                    
                } catch (Exception e) {
                    ec.logger.error("Error reading resource ${uri}", e)
                    result = [isError: true, content: [[type:"text", text: e.message]]]
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="Ping" authenticate="true" allow-remote="true" transaction-timeout="10">
        <description>Handle MCP ping request for health check</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
          <script><![CDATA[
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                // Get current user information
                def currentUser = ec.user.username
                def currentUserId = ec.user.userId
                
                // Try to get visit information if sessionId is provided
                def visitInfo = null
                if (sessionId) {
                    try {
                        ec.artifactExecution.disableAuthz()
                        def adminUserInfo = ec.user.pushUser("ADMIN")
                        try {
                            def visit = ec.entity.find("moqui.server.Visit")
                                .condition("visitId", sessionId)
                                .one()
                            
                            if (visit) {
                                visitInfo = [
                                    visitId: visit.visitId,
                                    userId: visit.userId,
                                    fromDate: visit.fromDate,
                                    lastUpdatedStamp: visit.lastUpdatedStamp
                                ]
                            }
                        } finally {
                            ec.user.popUser()
                        }
                        ec.artifactExecution.enableAuthz()
                    } catch (Exception e) {
                        // Log but don't fail the ping
                        ec.logger.warn("Error getting visit info for sessionId ${sessionId}: ${e.message}")
                    }
                }
                
                result = [
                    timestamp: ec.user.getNowTimestamp(),
                    status: "healthy",
                    version: "2.0.2",
                    sessionId: sessionId,
                    currentUser: currentUser,
                    currentUserId: currentUserId,
                    visitInfo: visitInfo,
                    architecture: "Visit-based sessions"
                ]
            ]]></script>
        </actions>
    </service>

    <!-- Debug Service -->
    
    <service verb="debug" noun="ComponentStatus" authenticate="false" allow-remote="true">
        <description>Debug service to verify component is loaded and working</description>
        <in-parameters/>
        <out-parameters>
            <parameter name="status" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                def status = [
                    componentLoaded: true,
                    componentName: "mo-mcp",
                    timestamp: ec.user.getNowTimestamp(),
                    user: ec.user.username,
                    userId: ec.user.userId,
                    serviceNames: ec.service.getKnownServiceNames().findAll { it.contains("Mcp") },
                    entityNames: ec.entity.getAllEntityNames().findAll { it.contains("ArtifactHit") }
                ]
                
                ec.logger.info("=== MCP COMPONENT DEBUG ===")
                ec.logger.info("Component status: ${status}")
                ec.logger.info("All service names count: ${ec.service.getKnownServiceNames().size()}")
                ec.logger.info("All entity names count: ${ec.entity.getAllEntityNames().size()}")
                ec.logger.info("=== END MCP COMPONENT DEBUG ===")
                
                result.status = status
            ]]></script>
        </actions>
    </service>

    <!-- Helper Functions -->
    
    <service verb="validate" noun="Origin" authenticate="false" allow-remote="false">
        <description>Validate Origin header for DNS rebinding protection</description>
        <in-parameters>
            <parameter name="origin" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="isValid" type="boolean"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Allow localhost origins
                if (origin?.startsWith("http://localhost:") || origin?.startsWith("https://localhost:")) {
                    isValid = true
                    return
                }
                
                // Allow 127.0.0.1 origins
                if (origin?.startsWith("http://127.0.0.1:") || origin?.startsWith("https://127.0.0.1:")) {
                    isValid = true
                    return
                }
                
                // Allow same-origin requests (check against current host)
                def currentHost = ec.web?.request?.getServerName()
                def currentScheme = ec.web?.request?.getScheme()
                def currentPort = ec.web?.request?.getServerPort()
                
                def expectedOrigin = "${currentScheme}://${currentHost}"
                if ((currentScheme == "http" && currentPort != 80) || (currentScheme == "https" && currentPort != 443)) {
                    expectedOrigin += ":${currentPort}"
                }
                
                if (origin == expectedOrigin) {
                    isValid = true
                    return
                }
                
                // Check for configured allowed origins (could be from system properties)
                def allowedOrigins = ec.getFactory().getConfiguration().getStringList("moqui.mcp.allowed_origins", [])
                if (allowedOrigins.contains(origin)) {
                    isValid = true
                    return
                }
                
                isValid = false
            ]]></script>
        </actions>
    </service>
    
    <service verb="convert" noun="MoquiTypeToJsonSchemaType" authenticate="false">
        <description>Convert Moqui data types to JSON Schema types</description>
        <in-parameters>
            <parameter name="moquiType" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="jsonSchemaType"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                // Simple type mapping - can be expanded as needed
                def typeMap = [
                    "text-short": "string",
                    "text-medium": "string", 
                    "text-long": "string",
                    "text-very-long": "string",
                    "id": "string",
                    "id-long": "string",
                    "number-integer": "integer",
                    "number-decimal": "number",
                    "number-float": "number",
                    "date": "string",
                    "date-time": "string",
                    "date-time-nano": "string",
                    "boolean": "boolean",
                    "text-indicator": "boolean"
                ]
                
                jsonSchemaType = typeMap[moquiType] ?: "string"
            ]]></script>
        </actions>
    </service>

    <service verb="execute" noun="ScreenAsMcpTool" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Execute a screen as an MCP tool</description>
        <in-parameters>
            <parameter name="screenPath" required="true"/>
            <parameter name="parameters" type="Map"><description>Parameters to pass to screen</description></parameter>
            <parameter name="action"><description>Action being processed: if not null, use real screen rendering instead of test mock</description></parameter>
            <parameter name="renderMode" default="mcp"><description>Render mode: mcp, text, html, xml, vuet, qvt</description></parameter>
            <parameter name="sessionId"><description>Session ID for user context restoration</description></parameter>
            <parameter name="subscreenName"><description>Optional subscreen name for dot notation paths</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
import org.moqui.context.ExecutionContext
import groovy.json.JsonBuilder

ExecutionContext ec = context.ec

def startTime = System.currentTimeMillis()
    
         // Set parameters in context
        if (parameters) {
            ec.context.putAll(parameters)
        }
        
        // Check if action is being processed - use real screen rendering if so
        def isActionExecution = parameters?.action != null
        
        // Try to render screen content for LLM consumption
        def output = null
        def screenUrl = "http://localhost:8080/${screenPath}"
        def isError = false
         
        try {
            ec.logger.info("MCP Screen Execution: Attempting to render screen ${screenPath} using ScreenTest with proper root screen, action=${parameters?.action}")
            
            def testScreenPath = screenPath
            def rootScreen = "component://webroot/screen/webroot.xml"
            
            def targetScreenDef = null
            def isStandalone = false
            
            if (screenPath.startsWith("component://")) {
                def pathAfterComponent = screenPath.substring(12).replace('.xml','') // Remove "component://"
                def pathParts = pathAfterComponent.split("/")
                
                // Check if target screen itself is standalone
                try {
                    targetScreenDef = ec.screen.getScreenDefinition(screenPath)
                    if (targetScreenDef?.screenNode) {
                        def standaloneAttr = targetScreenDef.screenNode.attribute('standalone')
                        isStandalone = standaloneAttr == "true"
                    }
                    
                    if (isStandalone) {
                        rootScreen = screenPath
                        testScreenPath = "" 
                    }
                } catch (Exception e) {
                    ec.logger.warn("MCP Screen Execution: Error checking target screen ${screenPath}: ${e.message}")
                }
                
                if (!isStandalone) {
                    // Check if screen path itself is a valid screen definition
                    try {
                        if (ec.screen.getScreenDefinition(screenPath)) {
                            rootScreen = screenPath
                            testScreenPath = ""
                        } else {
                            // Original component root logic
                            if (pathAfterComponent.startsWith("webroot/screen/")) {
                                rootScreen = "component://webroot/screen/webroot.xml"
                                testScreenPath = pathAfterComponent.substring("webroot/screen/".length())
                                if (testScreenPath.startsWith("webroot/")) {
                                    testScreenPath = testScreenPath.substring("webroot/".length())
                                }
                            } else {
                                rootScreen = screenPath
                                testScreenPath = ""
                            }
                        }
                    } catch (Exception e) {}
                }
                
            } else {
                rootScreen = screenPath
                testScreenPath = ""
            }
            
            // Get final screen definition for MCP data extraction
            def finalScreenDef = rootScreen ? ec.screen.getScreenDefinition(rootScreen) : null
            if (finalScreenDef && testScreenPath) {
                // Navigate to subscreen
                def pathSegments = testScreenPath.split('/')
                for (segment in pathSegments) {
                    if (finalScreenDef) {
                        def subItem = finalScreenDef?.getSubscreensItem(segment)
                        if (subItem && subItem.getLocation()) {
                            finalScreenDef = ec.screen.getScreenDefinition(subItem.getLocation())
                        } else {
                            break
                        }
                    }
                }
            }
            
            // Extract MCP-specific data when renderMode is "mcp" or "json"
            if ((renderMode == "mcp" || renderMode == "json") && finalScreenDef) {
                ec.logger.info("MCP Screen Execution: Extracting MCP data for ${screenPath}")
                
                // Extract parameters
                if (finalScreenDef.parameterByName) {
                    mcpData.parameters = [:]
                    finalScreenDef.parameterByName.each { name, param ->
                        def value = ec.context.get(name) ?: parameters?.get(name)
                        mcpData.parameters[name] = [name: name, value: value, type: "parameter"]
                    }
                }
                
                // Extract forms and their fields
                if (finalScreenDef.formByName) {
                    mcpData.forms = []
                    finalScreenDef.formByName.each { formName, form ->
                        def formInfo = [name: formName, fields: []]
                        def formNode = form.internalFormNode
                        if (formNode) {
                            // Extract field elements
                            def fields = formNode.'field'
                            fields.each { field ->
                                def fieldName = field.attribute('name')
                                if (fieldName) {
                                    def fieldInfo = [name: fieldName, type: field.name()]
                                    def value = ec.context.get(fieldName) ?: parameters?.get(fieldName)
                                    if (value) fieldInfo.value = value
                                    
                                    // Check if it's a widget with options
                                    if (field.'drop-down' || field.'check' || field.'radio') {
                                        fieldInfo.widgetType = "selection"
                                    }
                                    formInfo.fields << fieldInfo
                                }
                            }
                        }
                        if (formInfo.fields) mcpData.forms << formInfo
                    }
                }
                
                // Extract transitions (actions like "Update" buttons)
                ec.logger.info("MCP Data Extraction: renderMode=${renderMode}, hasScreenDef=${finalScreenDef != null}, hasTransition=${finalScreenDef?.hasTransition(null)}")
                if (finalScreenDef.hasTransition(null)) {
                    mcpData.actions = []
                    finalScreenDef.getTransitionList().each { trans ->
                        mcpData.actions << [
                            name: trans.name,
                            service: trans.xmlTransition ? trans.xmlTransition.attribute('service') : null,
                            description: trans.description
                        ]
                    }
                }
            }
        
        // Regular screen rendering with current user context - use our custom ScreenTestImpl
        def screenTest = new org.moqui.mcp.CustomScreenTestImpl(ec.ecfi)
            .rootScreen(rootScreen)
            .renderMode(renderMode ? renderMode : "mcp")
            .auth(ec.user.username)
        
        def renderParams = parameters ?: [:]
        renderParams.userId = ec.user.userId
        renderParams.username = ec.user.username
        
        def relativePath = subscreenName ? subscreenName.replaceAll('_','/') : testScreenPath
        ec.logger.info("TESTRENDER root=${rootScreen} path=${relativePath} params=${renderParams}")
        
        def testRender = screenTest.render(relativePath, renderParams, "POST")
        output = testRender.getOutput()
        ec.logger.info("MCP Screen Execution: Successfully rendered screen ${screenPath}, output length: ${output?.length() ?: 0}")

    } catch (Exception e) {
        isError = true
        ec.logger.error("MCP Screen Execution: Full exception for ${screenPath}", e)
        output = "SCREEN RENDERING ERROR: ${e.message}\n\nTroubleshooting Suggestions:\n1. Check if the screen path is correct\n2. Verify user permissions\n3. Check server logs"
    }
    
    def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
    
            // Build result based on renderMode
            def content = []
            if ((renderMode == "mcp" || renderMode == "json") && mcpData) {
        // Return structured MCP data
        def mcpResult = [
            screenPath: screenPath,
            screenUrl: screenUrl,
            executionTime: executionTime,
            isError: isError
        ]
        if (mcpData.parameters) mcpResult.parameters = mcpData.parameters
        if (mcpData.forms) mcpResult.forms = mcpData.forms
        if (mcpData.actions) mcpResult.actions = mcpData.actions
        if (output) mcpResult.htmlPreview = output.take(2000) + (output.length() > 2000 ? "..." : "")
        
        content << [
            type: "text",
            text: new groovy.json.JsonBuilder(mcpResult).toString()
        ]
    } else {
        // Return raw output for other modes
        content << [
            type: "text",
            text: output,
            screenPath: screenPath,
            screenUrl: screenUrl,
            executionTime: executionTime,
            isError: isError
        ]
    }
    
    result = [
        content: content,
        isError: false
    ]
    
    ec.logger.info("MCP Screen Execution: Returned result for screen ${screenPath} in ${executionTime}s")
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesTemplatesList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/templates/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // For now, return empty templates list - can be extended later
                def templates = []
                
                result = [resourceTemplates: templates]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ResourcesSubscribe" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/subscribe request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"><description>Resource URI to subscribe to</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Resource subscription requested for URI: ${uri}, sessionId: ${sessionId}")
                
                // For now, just return success - actual subscription tracking could be added
                result = [subscribed: true, uri: uri]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ResourcesUnsubscribe" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/unsubscribe request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"><description>Resource URI to unsubscribe from</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Resource unsubscription requested for URI: ${uri}, sessionId: ${sessionId}")
                
                // For now, just return success - actual subscription tracking could be added
                result = [unsubscribed: true, uri: uri]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="PromptsList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP prompts/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonSlurper
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("MCP PromptsList: Listing prompts from wiki space MCP_PROMPTS")
                
                def prompts = []
                
                // Query all wiki pages in MCP_PROMPTS space
                def wikiPageList = ec.entity.find("moqui.resource.wiki.WikiPage")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .useCache(true)
                    .list()
                
                for (def wp in wikiPageList) {
                    // Try to load argument schema from attachment
                    def arguments = []
                    try {
                        def attachment = ec.entity.find("moqui.resource.wiki.WikiPageAttachment")
                            .condition("wikiPageId", wp.wikiPageId)
                            .condition("filename", "arguments.json")
                            .one()
                        if (attachment) {
                            def attachmentRef = ec.resource.getLocationReference(attachment.getLocation())
                            def jsonText = attachmentRef?.getText()
                            if (jsonText) {
                                arguments = new JsonSlurper().parseText(jsonText) ?: []
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not parse arguments for ${wp.pagePath}: ${e.message}")
                    }
                    
                    prompts << [
                        name: wp.pagePath,
                        title: wp.pagePath.split('-').collect { it.capitalize() }.join(' '),
                        description: "MCP prompt template",
                        arguments: arguments
                    ]
                }
                
                result = [prompts: prompts]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="PromptsGet" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP prompts/get request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="name" required="true"><description>Prompt name to retrieve</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.text.GStringTemplateEngine
                import groovy.json.JsonSlurper
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("MCP PromptsGet: Retrieving prompt '${name}' from wiki space MCP_PROMPTS")
                
                // Get the wiki page for this prompt
                def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .condition("pagePath", name)
                    .one()
                
                if (!wikiPage) {
                    throw new Exception("Prompt not found: ${name}")
                }
                
                // Get the wiki space to build the page location
                def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .one()
                
                if (!wikiSpace) {
                    throw new Exception("MCP Prompts wiki space not found")
                }
                
                // Build the resource location for the page (root + page path + .md)
                def pageLocation = wikiSpace.rootPageLocation
                if (!pageLocation.endsWith('/')) {
                    pageLocation += '/'
                }
                pageLocation += name + '.md'
                
                // Get the resource reference and text content
                def pageRef = ec.resource.getLocationReference(pageLocation)
                def templateText = pageRef?.getText()
                
                if (!templateText) {
                    throw new Exception("Prompt template not found: ${name}")
                }
                
                // Render template using Groovy GString engine
                def templateEngine = new GStringTemplateEngine()
                def template = templateEngine.createTemplate(templateText)
                def binding = arguments ?: [:]
                def rendered = template.make(binding).toString()
                
                ec.logger.info("MCP PromptsGet: Rendered prompt '${name}' with ${binding.size()} arguments")
                
                result = [
                    description: "MCP prompt template",
                    messages: [[
                        role: "user",
                        content: [type: "text", text: rendered]
                    ]]
                ]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="RootsList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP roots/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // For now, return empty roots list - can be extended later
                def roots = []
                
                result = [roots: roots]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="SamplingCreateMessage" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP sampling/createMessage request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="messages" type="List"><description>List of messages to sample</description></parameter>
            <parameter name="maxTokens" type="Integer"><description>Maximum tokens to generate</description></parameter>
            <parameter name="temperature" type="BigDecimal"><description>Sampling temperature</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Sampling createMessage requested for sessionId: ${sessionId}")
                
                // For now, return not implemented - can be extended with actual LLM integration
                result = [error: "Sampling not implemented"]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ElicitationCreate" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP elicitation/create request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="prompt"><description>Prompt for elicitation</description></parameter>
            <parameter name="context"><description>Context for elicitation</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Elicitation create requested for sessionId: ${sessionId}")
                
                // For now, return not implemented - can be extended later
                result = [error: "Elicitation not implemented"]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="BrowseScreens" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Browse Moqui screens hierarchically to discover functionality. Renders screen content with renderMode='mcp' by default. Supports action parameter for form submission and transitions.</description>
        <in-parameters>
            <parameter name="path" required="false"><description>Screen path to browse (e.g. 'PopCommerce'). Leave empty for root apps.</description></parameter>
            <parameter name="action"><description>Action to process before rendering: null (browse), 'submit' (form), 'create', 'update', or transition name</description></parameter>
            <parameter name="renderMode" default="mcp"><description>Render mode: mcp (default), text, html, xml, vuet, qvt</description></parameter>
            <parameter name="parameters" type="Map"><description>Parameters to pass to screen during rendering or action</description></parameter>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def subscreens = []
                def currentPath = path ?: "root"
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                
                // Strip query parameters from path for screen resolution
                if (currentPath.contains("?")) {
                    currentPath = currentPath.split("\\?")[0]
                }
                
                // Helper to convert full component path to simple path (PopCommerce/screen/Root.xml -> PopCommerce.Root)
                def convertToSimplePath = { fullPath ->
                    if (!fullPath) return null
                    String cleanPath = fullPath
                    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
                    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
                    List<String> parts = cleanPath.split('/').toList()
                    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
                    return parts.join('.')
                }

                if (currentPath == "root") {
                    // Discover top-level applications
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_XML_SCREEN")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                        
                    def rootScreens = new HashSet()
                    for (def aacv in aacvList) {
                        def name = aacv.artifactName
                        if (name.startsWith("component://") && name.endsWith(".xml")) {
                            def parts = name.substring(12).split('/')
                            if (parts.length >= 3 && parts[1] == "screen") {
                                def filename = parts[parts.length - 1]
                                def componentName = parts[0]
                                if (filename == componentName + ".xml" || filename == componentName + "Admin.xml" || filename == componentName + "Root.xml" || filename == "webroot.xml") {
                                    rootScreens.add(name)
                                }
                            }
                        }
                    }
                    
                    /* Removed hardcoded list - rely on proper user permissions and artifact discovery */

                    for (def screenPath in rootScreens) {
                        def simplePath = convertToSimplePath(screenPath)
                        subscreens << [
                            path: simplePath, 
                            description: "Application: ${simplePath}"
                        ]
                    }
                } else {
                    // Resolve simple path to component path using longest match and traversal
                    def pathParts = currentPath.split('\\.')
                    def componentName = pathParts[0]
                    def baseScreenPath = null
                    def subParts = []
                    
                    for (int i = pathParts.size(); i >= 1; i--) {
                        def currentTry = "component://${componentName}/screen/" + (i > 1 ? pathParts[1..<i].join('/') : componentName) + ".xml"
                        if (ec.resource.getLocationReference(currentTry).getExists()) {
                            baseScreenPath = currentTry
                            if (i < pathParts.size()) subParts = pathParts[i..-1]
                            break
                        }
                    }

                    if (!baseScreenPath) {
                        baseScreenPath = "component://${componentName}/screen/${componentName}.xml"
                        if (pathParts.size() > 1) subParts = pathParts[1..-1]
                    }

                    try {
                        def screenDef = ec.screen.getScreenDefinition(baseScreenPath)
                        // Traverse subscreens to find the target screen
                        for (subName in subParts) {
                            def subItem = screenDef?.getSubscreensItem(subName)
                            if (subItem && subItem.getLocation()) {
                                screenDef = ec.screen.getScreenDefinition(subItem.getLocation())
                            } else {
                                // Subscreen not found or defined in-place
                                break
                            }
                        }

                        if (screenDef) {
                            def subItems = screenDef.getSubscreensItemsSorted()
                            for (subItem in subItems) {
                                def subName = subItem.getName()
                                def subPath = currentPath + "." + subName
                                subscreens << [
                                    path: subPath,
                                    description: "Subscreen: ${subName}"
                                ]
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.warn("Browse error for ${currentPath}: ${e.message}")
                    }
                }
                
                // Process action before rendering - execute transitions directly
                def actionResult = null
                def actionError = null
                
                if (action) {
                    try {
                        ec.logger.info("BrowseScreens: Executing action '${action}' on ${currentPath}")
                        
                        // Resolve screen definition to find transitions
                        def pathParts = currentPath.split('\\.')
                        def componentName = pathParts[0]
                        def screenPath = null
                        def subscreenName = null
                        
                        for (int i = pathParts.size(); i >= 1; i--) {
                            def currentTry = "component://${componentName}/screen/" + (i > 1 ? pathParts[1..<i].join('/') : componentName) + ".xml"
                            if (ec.resource.getLocationReference(currentTry).getExists()) {
                                screenPath = currentTry
                                if (i < pathParts.size()) {
                                    def remainingParts = pathParts[i..-1]
                                    subscreenName = remainingParts.size() > 1 ? remainingParts.join('_') : remainingParts[0]
                                }
                                break
                            }
                        }
                        
                        if (!screenPath) {
                            screenPath = "component://${componentName}/screen/${componentName}.xml"
                            if (pathParts.size() > 1) {
                                subscreenName = pathParts[1..-1].join('_')
                            }
                        }
                        
                        // Get screen definition and look for matching transition
                        def screenDef = ec.screen.getScreenDefinition(screenPath)
                        
                        // Navigate to subscreen if needed
                        if (subscreenName && screenDef) {
                            def subItem = screenDef.getSubscreensItem(subscreenName)
                            if (subItem && subItem.getLocation()) {
                                screenDef = ec.screen.getScreenDefinition(subItem.getLocation())
                            } else if (subscreenName) {
                                def subItems = screenDef.getSubscreensItemsSorted()
                                for (def sub in subItems) {
                                    if (sub.getName() == subscreenName) {
                                        screenDef = ec.screen.getScreenDefinition(sub.getLocation())
                                        break
                                    }
                                }
                            }
                        }
                        
                        def foundTransition = null
                        def actionParams = parameters ?: [:]
                        
                        // Special handling for "submit" action
                        if (action == "submit") {
                            ec.logger.info("BrowseScreens: Submitting form with parameters: ${actionParams}")
                            // Build screen context with parameters
                            actionParams.userId = ec.user.userId
                            actionParams.username = ec.user.username
                            
                            // Submit is handled by passing parameters to screen render
                            actionResult = [
                                action: "submit",
                                status: "success",
                                message: "Form parameters submitted",
                                parametersProcessed: actionParams.keySet()
                            ]
                        } else if (screenDef && screenDef.hasTransitions()) {
                            // Look for matching transition by name
                            for (def transition : screenDef.getAllTransitions()) {
                                if (transition.name == action) {
                                    foundTransition = transition
                                    break
                                }
                            }
                            
                            if (foundTransition) {
                                ec.logger.info("BrowseScreens: Found transition '${action}': ${foundTransition.@service}")
                                
                                // Check if transition calls a service
                                if (foundTransition.@service) {
                                    def serviceName = foundTransition.@service
                                    ec.logger.info("BrowseScreens: Calling service: ${serviceName} with params: ${actionParams}")
                                    
                                    // Call service directly
                                    def serviceCallResult = ec.service.sync().name(serviceName).parameters(actionParams).call()
                                    
                                    actionResult = [
                                        action: action,
                                        status: "executed",
                                        message: "Transition '${action}' executed service: ${serviceName}",
                                        service: serviceName,
                                        result: serviceCallResult
                                    ]
                                } else {
                                    // Screen-only transition (no service), pass to render
                                    actionResult = [
                                        action: action,
                                        status: "queued",
                                        message: "Transition '${action}' will be processed during screen render"
                                    ]
                                }
                            } else {
                                actionResult = [
                                    action: action,
                                    status: "not_found",
                                    message: "Transition '${action}' not found on screen ${currentPath}"
                                ]
                            }
                        } else {
                            actionResult = [
                                action: action,
                                status: "not_found",
                                message: "No screen found or screen has no transitions"
                            ]
                        }
                        
                        ec.logger.info("BrowseScreens: Action result: ${actionResult}")
                    } catch (Exception e) {
                        actionError = "Action execution failed: ${e.message}"
                        ec.logger.warn("BrowseScreens action error for ${currentPath}: ${e.message}")
                    }
                }
                
                // Render current screen if not root browsing
                def renderedContent = null
                def renderError = null
                def actualRenderMode = renderMode ?: "mcp"
                
                if (currentPath != "root") {
                    try {
                        ec.logger.info("BrowseScreens: Rendering screen ${currentPath} with mode=${actualRenderMode}")
                        
                        // Use same resolution logic as browse_screens
                        def pathParts = currentPath.split('\\.')
                        def componentName = pathParts[0]
                        def screenPath = null
                        def subscreenName = null
                        
                        for (int i = pathParts.size(); i >= 1; i--) {
                            def currentTry = "component://${componentName}/screen/" + (i > 1 ? pathParts[1..<i].join('/') : componentName) + ".xml"
                            if (ec.resource.getLocationReference(currentTry).getExists()) {
                                screenPath = currentTry
                                if (i < pathParts.size()) {
                                    def remainingParts = pathParts[i..-1]
                                    subscreenName = remainingParts.size() > 1 ? remainingParts.join('_') : remainingParts[0]
                                }
                                break
                            }
                        }
                        
                        if (!screenPath) {
                            screenPath = "component://${componentName}/screen/${componentName}.xml"
                            if (pathParts.size() > 1) {
                                subscreenName = pathParts[1..-1].join('_')
                            }
                        }
                        
                        // Build render parameters
                        def renderParams = parameters ?: [:]
                        renderParams.userId = ec.user.userId
                        renderParams.username = ec.user.username
                        
                        def screenCallParams = [
                            screenPath: screenPath,
                            parameters: renderParams,
                            renderMode: actualRenderMode,
                            sessionId: sessionId
                        ]
                        if (subscreenName) screenCallParams.subscreenName = subscreenName
                        
                        // Call ScreenAsMcpTool to render
                        def serviceResult = ec.service.sync().name("McpServices.execute#ScreenAsMcpTool")
                            .parameters(screenCallParams)
                            .call()
                        
                        // Extract rendered content from result
                        // ScreenAsMcpTool returns {content: [{type: "text", text: "...", ...}]}
                        ec.logger.info("BrowseScreens: serviceResult keys: ${serviceResult?.keySet()}, has content: ${serviceResult?.containsKey('content')}, has result: ${serviceResult?.containsKey('result')}")
                        if (serviceResult) {
                            if (serviceResult.containsKey('content') && serviceResult.content && serviceResult.content.size() > 0) {
                                renderedContent = serviceResult.content[0].text
                                ec.logger.info("BrowseScreens: Extracted content from serviceResult.content[0].text")
                            } else if (serviceResult.containsKey('result') && serviceResult.result && serviceResult.result.content && serviceResult.result.content.size() > 0) {
                                renderedContent = serviceResult.result.content[0].text
                                ec.logger.info("BrowseScreens: Extracted content from serviceResult.result.content[0].text")
                            } else {
                                ec.logger.info("BrowseScreens: serviceResult structure: ${serviceResult}, result content size: ${serviceResult?.result?.content?.size()}")
                            }
                        }
                        
                        ec.logger.info("BrowseScreens: Successfully rendered screen ${currentPath}, content length: ${renderedContent?.length() ?: 0}")
                    } catch (Exception e) {
                        renderError = "Screen rendering failed: ${e.message}"
                        ec.logger.warn("BrowseScreens render error for ${currentPath}: ${e.message}")
                    }
                }
                
                // Build result - return in MCP format with content array
                def resultMap = [
                    currentPath: currentPath,
                    subscreens: subscreens,
                    renderMode: actualRenderMode
                ]
                
                if (actionResult) {
                    resultMap.actionResult = actionResult
                }
                
                if (actionError) {
                    resultMap.actionError = actionError
                }
                
                if (renderedContent) {
                    resultMap.renderedContent = renderedContent
                }
                
                if (renderError) {
                    resultMap.renderError = renderError
                }
                
                // Return in MCP format - content array as direct child of result
                result = [
                    content: [[type: "text", text: new groovy.json.JsonBuilder(resultMap).toString()]],
                    isError: false
                ]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="SearchScreens" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Search for screens by name or path.</description>
        <in-parameters>
            <parameter name="query" required="true"/>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def matches = []
                
                // Strip query parameters from path if present
                if (query.contains("?")) {
                    query = query.split("\\?")[0]
                }
                
                // Helper to convert full component path to simple path
                def convertToSimplePath = { fullPath ->
                    if (!fullPath) return null
                    String cleanPath = fullPath
                    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
                    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
                    List<String> parts = cleanPath.split('/').toList()
                    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
                    return parts.join('.')
                }

                // Search all screens known to the system
                def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                    .condition("artifactTypeEnumId", "AT_XML_SCREEN")
                    .condition("artifactName", "like", "%${query}%")
                    .selectField("artifactName")
                    .distinct(true)
                    .disableAuthz()
                    .limit(20)
                    .list()
                
                for (hit in aacvList) {
                    def simplePath = convertToSimplePath(hit.artifactName)
                    if (simplePath) {
                        matches << [
                            path: simplePath,
                            description: "Screen: ${hit.artifactName}"
                        ]
                    }
                }
                
                result = [matches: matches]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="GetScreenDetails" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Get detailed schema and usage info for a specific screen path.</description>
        <in-parameters>
            <parameter name="path" required="true"><description>Screen path (e.g. PopCommerce.Catalog)</description></parameter>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // Strip query parameters from path if present
                if (path.contains("?")) {
                    path = path.split("\\?")[0]
                }
                
                // Resolve simple path to component path using longest match and traversal
                def pathParts = path.split('\\.')
                def componentName = pathParts[0]
                def baseScreenPath = null
                def subParts = []
                
                for (int i = pathParts.size(); i >= 1; i--) {
                    def currentTry = "component://${componentName}/screen/" + (i > 1 ? pathParts[1..<i].join('/') : componentName) + ".xml"
                    if (ec.resource.getLocationReference(currentTry).getExists()) {
                        baseScreenPath = currentTry
                        if (i < pathParts.size()) subParts = pathParts[i..-1]
                        break
                    }
                }

                if (!baseScreenPath) {
                    baseScreenPath = "component://${componentName}/screen/${componentName}.xml"
                    if (pathParts.size() > 1) subParts = pathParts[1..-1]
                }

                def toolDef = null
                
                if (ec.resource.getLocationReference(baseScreenPath).getExists()) {
                    try {
                        def screenDef = ec.screen.getScreenDefinition(baseScreenPath)
                        
                        // Traverse to final subscreen
                        for (subName in subParts) {
                            def subItem = screenDef?.getSubscreensItem(subName)
                            if (subItem && subItem.getLocation()) {
                                screenDef = ec.screen.getScreenDefinition(subItem.getLocation())
                            } else {
                                break 
                            }
                        }

                        if (screenDef && screenDef.screenNode) {
                            def properties = [:]
                            def required = []
                            def getJsonType = { moquiType ->
                                def typeRes = ec.service.sync().name("McpServices.convert#MoquiTypeToJsonSchemaType")
                                    .parameter("moquiType", moquiType).call()
                                return typeRes?.jsonSchemaType ?: "string"
                            }

                        }

                        if (screenDef) {
                            def properties = [:]
                            def required = []
                            def getJsonType = { moquiType ->
                                def typeRes = ec.service.sync().name("McpServices.convert#MoquiTypeToJsonSchemaType")
                                    .parameter("moquiType", moquiType).call()
                                return typeRes?.jsonSchemaType ?: "string"
                            }

                            // Extract parameters from screen definition (using protected field access in Groovy)
                            if (screenDef.parameterByName) {
                                screenDef.parameterByName.each { name, param ->
                                    properties[name] = [type: "string", description: "Screen Parameter"]
                                }
                            }
                            
                            // Try to get forms and their entities
                            if (screenDef.formByName) {
                                screenDef.formByName.each { name, form ->
                                    def formNode = form.internalFormNode
                                    if (!formNode) return
                                    
                                    def entityName = formNode.attribute("entity-name")
                                    if (!entityName) {
                                        def entityFind = formNode.first("entity-find")
                                        if (entityFind) entityName = entityFind.attribute("entity-name")
                                    }
                                    
                                    if (entityName && ec.entity.isEntityDefined(entityName)) {
                                        def entityDef = ec.entity.getEntityDefinition(entityName)
                                        entityDef.getAllFieldNames().each { fieldName ->
                                            if (!properties[fieldName]) {
                                                def fieldInfo = entityDef.getFieldNode(fieldName)
                                                properties[fieldName] = [
                                                    type: getJsonType(fieldInfo.attribute("type")),
                                                    description: "Inferred from entity ${entityName} (form ${name})"
                                                ]
                                            }
                                        }
                                    }
                                }
                            }
                            
                            toolDef = [
                                path: path,
                                description: "Details for screen ${path}",
                                inputSchema: [
                                    type: "object",
                                    properties: properties,
                                    required: required
                                ]
                            ]
                        }
                    } catch (Exception e) {
                        ec.logger.warn("Error getting screen details for ${path}: ${e.message}")
                    }
                }
                
                result = [details: toolDef]
            ]]></script>
        </actions>
    </service>

    <service verb="list" noun="Tools" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>List discovery tools and the unified screen renderer.</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                def tools = [
                    [
                        name: "moqui_render_screen",
                        title: "Render Screen",
                        description: "Execute and render a Moqui screen. Use discovery tools to find paths.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "path": [type: "string", description: "Screen path (e.g. 'PopCommerce.Catalog.Product')"],
                                "parameters": [type: "object", description: "Parameters for the screen"],
                                "renderMode": [type: "string", description: "mcp, text, html, xml, vuet, qvt", default: "mcp"]
                            ],
                            required: ["path"]
                        ]
                    ],
                    [
                        name: "moqui_browse_screens",
                        title: "Browse Screens",
                        description: "Browse Moqui screen hierarchy, process actions, and render screen content. Input 'path' (empty for root). Default renderMode is 'mcp'.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "path": [type: "string", description: "Path to browse (e.g. 'PopCommerce')"],
                                "action": [type: "string", description: "Action to process before rendering: null (browse), 'submit' (form), 'create', 'update', or transition name"],
                                "renderMode": [type: "string", description: "Render mode: mcp (default), text, html, xml, vuet, qvt"],
                                "parameters": [type: "object", description: "Parameters to pass to screen during rendering or action"]
                            ]
                        ]
                    ],
                    [
                        name: "moqui_search_screens",
                        title: "Search Screens",
                        description: "Search for screens by name to find their paths.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "query": [type: "string", description: "Search query"]
                            ],
                            required: ["query"]
                        ]
                    ],
                     [
                        name: "moqui_get_screen_details",
                        title: "Get Screen Details",
                        description: "Get detailed schema for a specific screen path.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "path": [type: "string", description: "Screen path"]
                            ],
                            required: ["path"]
                        ]
                    ],
                    [
                        name: "prompts_list",
                        title: "List Prompts",
                        description: "List available MCP prompt templates.",
                        inputSchema: [
                            type: "object",
                            properties: [:]
                        ]
                    ],
                    [
                        name: "prompts_get",
                        title: "Get Prompt",
                        description: "Retrieve and render a specific MCP prompt template.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "name": [type: "string", description: "Prompt name"],
                                "arguments": [type: "object", description: "Arguments for prompt template"]
                            ],
                            required: ["name"]
                        ]
                    ]
                ]
                
                result = [tools: tools]
            ]]></script>
        </actions>
    </service>

    <!-- NOTE: handle#McpRequest service removed - functionality moved to screen/webapp.xml for unified handling -->

</services>
