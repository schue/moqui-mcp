<?xml version="1.0" encoding="UTF-8"?>
<!-- This software is in the public domain under CC0 1.0 Universal plus a 
     Grant of Patent License.

     To the extent possible under law, the author(s) have dedicated all
     copyright and related and neighboring rights to this software to the
     public domain worldwide. This software is distributed without any warranty.

     You should have received a copy of the CC0 Public Domain Dedication
     along with this software (see the LICENSE.md file). If not, see
     <https://creativecommons.org/publicdomain/zero/1.0/>. -->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- MCP Services using Moqui's built-in JSON-RPC support -->
    
    
    <service verb="mcp" noun="Initialize" authenticate="true" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP initialize request using Moqui authentication</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="protocolVersion" required="true"/>
            <parameter name="capabilities" type="Map"/>
            <parameter name="clientInfo" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Permissions are handled by Moqui's artifact authorization system
                // Users must be in appropriate groups (McpUser, MCP_BUSINESS) with access to McpServices artifact group
                
                // Get Visit (session) created by servlet and validate access
                def visit = ec.entity.find("moqui.server.Visit")
                    .condition("visitId", sessionId)
                    .disableAuthz()
                    .one()
                
                if (!visit) {
                    throw new Exception("Invalid session: ${sessionId}")
                }
                
                if (visit.userId != ec.user.userId) {
                    throw new Exception("Access denied for session: ${sessionId}")
                }
                
                // Update Visit with MCP initialization data
                UserInfo adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def metadata = [:]
                    try {
                        metadata = groovy.json.JsonSlurper().parseText(visit.initialRequest ?: "{}") as Map
                    } catch (Exception e) {
                        ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                    }
                    
                    metadata.mcpInitialized = true
                    metadata.mcpProtocolVersion = protocolVersion
                    metadata.mcpCapabilities = capabilities
                    metadata.mcpClientInfo = clientInfo
                    metadata.mcpInitializedAt = System.currentTimeMillis()
                    
                    visit.initialRequest = groovy.json.JsonOutput.toJson(metadata)
                    ec.artifactExecution.disableAuthz()
                    ec.logger.info("SESSIONID: ${sessionId}")
                    sessionId ? visit.update() : visit.store()
                    ec.artifactExecution.enableAuthz()
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Validate protocol version - support common MCP versions
                def supportedVersions = ["2025-06-18", "2024-11-05", "2024-10-07", "2023-06-05"]
                if (!supportedVersions.contains(protocolVersion)) {
                    throw new Exception("Unsupported protocol version: ${protocolVersion}. Supported versions: ${supportedVersions.join(', ')}")
                }
                
                // Get current user context (if authenticated)
                def userId = ec.user.userId
                def userAccountId = userId ? userId : null
                
                // Get user-specific tools and resources in SAME transaction context
                def toolsResult = ec.service.sync().name("McpServices.mcp#ToolsList")
                    .parameters([sessionId: visit.visitId])
                    .requireNewTransaction(false)  // Use current transaction
                    .disableAuthz()  // Disable authz for internal call
                    .call()
                def resourcesResult = ec.service.sync().name("McpServices.mcp#ResourcesList")
                    .parameters([sessionId: visit.visitId])
                    .requireNewTransaction(false)  // Use current transaction
                    .disableAuthz()  // Disable authz for internal call
                    .call()
                
                // Build server capabilities based on what user can access
                def serverCapabilities = [
                    tools: toolsResult?.result?.tools ? [listChanged: true] : [:],
                    resources: resourcesResult?.result?.resources ? [subscribe: true, listChanged: true] : [:],
                    logging: [:]
                ]
                
                // Build server info
                def serverInfo = [
                    name: "Moqui MCP Server",
                    version: "2.0.1"
                ]
                
                result = [
                    protocolVersion: "2025-06-18",
                    capabilities: serverCapabilities,
                    serverInfo: serverInfo,
                    instructions: "This server provides access to Moqui ERP services and entities through MCP. Tools and resources are filtered based on your permissions.",
                    sessionId: visit.visitId
                ]
                
                ec.logger.info("MCP Initialize for user ${userId} (session ${sessionId}): ${toolsResult?.result?.tools?.size() ?: 0} tools, ${resourcesResult?.result?.resources?.size() ?: 0} resources")
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ToolsList" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Handle MCP tools/list request with admin discovery but user permission filtering</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import java.util.UUID
                
                ExecutionContext ec = context.ec
                
                // Permissions are handled by Moqui's artifact authorization system
                // Users must be in appropriate groups (McpUser, MCP_BUSINESS) with access to McpServices artifact group
                
                // Validate session if provided
                /*
                if (sessionId) {
                    def visit = ec.entity.find("moqui.server.Visit")
                        .condition("visitId", sessionId)
                        .disableAuthz()
                        .one()
                    
                    if (!visit || visit.userId != ec.user.userId) {
                        //throw new Exception("Invalid session: ${sessionId}")
                    }
                }
                
                // Update session activity
                if (sessionId) {
                    def visitObj = ec.entity.find("moqui.server.Visit")
                        .condition("visitId", sessionId)
                        .disableAuthz()
                        .one()
                    
                    if (visitObj) {
                        def metadata = [:]
                        try {
                            metadata = groovy.json.JsonSlurper().parseText(visitObj.initialRequest ?: "{}") as Map
                        } catch (Exception e) {
                            ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                        }
                        
                        metadata.mcpLastActivity = System.currentTimeMillis()
                        metadata.mcpLastOperation = "tools/list"
                        
                        // Update Visit - need admin context for Visit updates
                        adminUserInfo = null
                        try {
                            adminUserInfo = ec.user.pushUser("ADMIN")
                            visitObj.initialRequest = groovy.json.JsonOutput.toJson(metadata)
                            ec.artifactExecution.disableAuthz()
                            visitObj.update()
                            ec.artifactExecution.enableAuthz()
                        } finally {
                            if (adminUserInfo != null) {
                                ec.user.popUser()
                            }
                        }
                    }
                }
                */
                
                // Store original user context before switching to ADMIN
                def originalUsername = ec.user.username
                def originalUserId = ec.user.userId
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                
                // Get user's accessible services using Moqui's optimized ArtifactAuthzCheckView
                def userAccessibleServices = null as Set<String>
                adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_SERVICE")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                    userAccessibleServices = aacvList.collect { it.artifactName } as Set<String>
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Helper function to check if user has permission to a service
                def userHasPermission = { serviceName ->
                    // Use pre-computed accessible services set for O(1) lookup
                    return userAccessibleServices != null && userAccessibleServices.contains(serviceName.toString())
                }
                
                try {
                    def availableTools = []
                    
                    // Get only services user has access to via artifact groups
                    def accessibleServiceNames = []
                    for (serviceName in userAccessibleServices) {
                        // Handle wildcard patterns like "McpServices.*"
                        if (serviceName.contains("*")) {
                            def pattern = serviceName.replace("*", ".*")
                            def allServiceNames = ec.service.getKnownServiceNames()
                            def matchingServices = allServiceNames.findAll { it.matches(pattern) }
                            // Only add services that actually exist
                            accessibleServiceNames.addAll(matchingServices.findAll { ec.service.isServiceDefined(it) })
                        } else {
                            // Only add if service actually exists
                            if (ec.service.isServiceDefined(serviceName)) {
                                accessibleServiceNames << serviceName
                            }
                        }
                    }
                    accessibleServiceNames = accessibleServiceNames.unique()
                    
                    ec.logger.info("MCP ToolsList: Found ${accessibleServiceNames.size()} accessible services for user ${originalUsername} (${originalUserId})${sessionId ? ' (session: ' + sessionId + ')' : ''}")
                    
                    // Helper function to convert service to MCP tool
                    def convertServiceToTool = { serviceName ->
                        try {
                            def serviceDefinition = ec.service.getServiceDefinition(serviceName)
                            if (!serviceDefinition) return null
                            
                            def serviceNode = serviceDefinition.serviceNode
                            
                            // Convert service to MCP tool format
                            def tool = [
                                name: serviceName,
                                title: serviceNode.first("description")?.text ?: serviceName,
                                description: serviceNode.first("description")?.text ?: "Moqui service: ${serviceName}",
                                inputSchema: [
                                    type: "object",
                                    properties: [:],
                                    required: []
                                ]
                            ]
                            
                            // Add service metadata to help LLM
                            if (serviceDefinition.verb && serviceDefinition.noun) {
                                tool.description += " (${serviceDefinition.verb}:${serviceDefinition.noun})"
                            }
                            
                            // Convert service parameters to JSON Schema
                            def inParamNames = serviceDefinition.getInParameterNames()
                            for (paramName in inParamNames) {
                                def paramNode = serviceDefinition.getInParameter(paramName)
                                def paramDesc = paramNode.first("description")?.text ?: ""
                                
                                // Add type information to description for LLM
                                def paramType = paramNode?.attribute('type') ?: 'String'
                                if (!paramDesc) {
                                    paramDesc = "Parameter of type ${paramType}"
                                } else {
                                    paramDesc += " (type: ${paramType})"
                                }
                                
                                // Convert Moqui type to JSON Schema type
                                def typeMap = [
                                    "text-short": "string",
                                    "text-medium": "string", 
                                    "text-long": "string",
                                    "text-very-long": "string",
                                    "id": "string",
                                    "id-long": "string",
                                    "number-integer": "integer",
                                    "number-decimal": "number",
                                    "number-float": "number",
                                    "date": "string",
                                    "date-time": "string",
                                    "date-time-nano": "string",
                                    "boolean": "boolean",
                                    "text-indicator": "boolean"
                                ]
                                def jsonSchemaType = typeMap[paramType] ?: "string"
                                
                                tool.inputSchema.properties[paramName] = [
                                    type: jsonSchemaType,
                                    description: paramDesc
                                ]
                                
                                if (paramNode?.attribute('required') == "true") {
                                    tool.inputSchema.required << paramName
                                }
                            }
                            
                            return tool
                        } catch (Exception e) {
                            ec.logger.warn("Error converting service ${serviceName} to tool: ${e.message}")
                            return null
                        }
                    }
                    
                    // Add all accessible services as tools
                    for (serviceName in accessibleServiceNames) {
                        def tool = convertServiceToTool(serviceName)
                        if (tool) {
                            availableTools << tool
                        }
                    }
                    
                    // Add screen-based tools
                    try {
                        def screenToolsResult = ec.service.sync().name("McpServices.discover#ScreensAsMcpTools")
                            .parameters([sessionId: sessionId])
                            .requireNewTransaction(false)  // Use current transaction
                            .call()
                        
                        if (screenToolsResult?.tools) {
                            availableTools.addAll(screenToolsResult.tools)
                            ec.logger.info("MCP ToolsList: Added ${screenToolsResult.tools.size()} screen-based tools")
                        }
                    } catch (Exception e) {
                        ec.logger.warn("Error discovering screen tools: ${e.message}")
                    }
                    
                // Implement pagination according to MCP spec
                def pageSize = 50  // Reasonable page size for tool lists
                def startIndex = 0
                
                if (cursor) {
                    try {
                        // Parse cursor to get start index (simple approach: cursor is the start index)
                        startIndex = Integer.parseInt(cursor)
                    } catch (Exception e) {
                        ec.logger.warn("Invalid cursor format: ${cursor}, starting from beginning")
                        startIndex = 0
                    }
                }
                
                // Get paginated subset of tools
                def endIndex = Math.min(startIndex + pageSize, availableTools.size())
                def paginatedTools = availableTools.subList(startIndex, endIndex)
                
                result = [tools: paginatedTools]
                
                // Add nextCursor if there are more tools
                if (endIndex < availableTools.size()) {
                    result.nextCursor = String.valueOf(endIndex)
                }
                    
                    ec.logger.info("MCP ToolsList: Returning ${availableTools.size()} tools for user ${originalUsername}")
                    
                } finally {
                    // Always restore original user context
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ToolsCall" authenticate="true" allow-remote="true" transaction-timeout="300">
        <description>Handle MCP tools/call request with direct Moqui service execution</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="name" required="true"/>
            <parameter name="arguments" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                // Start timing for execution metrics
                def startTime = System.currentTimeMillis()
                
                // Check if this is a screen-based tool or a service-based tool
                def isScreenTool = name.startsWith("screen_")
                
                if (isScreenTool) {
                    // For screen tools, we need to extract the original screen path from the tool description
                    // The tool name is encoded but the description contains the original path
                    def toolName = name.substring(7)  // Remove "screen_" prefix
                    
                    // Find the tool in our available tools to get the original screen path from description
                    def originalScreenPath = null
                    def toolsResult = ec.service.sync().name("McpServices.mcp#ToolsList")
                        .parameters([sessionId: sessionId])
                        .disableAuthz()
                        .call()
                    
                    // The internal service call returns tools list directly, not wrapped in MCP format
                    if (toolsResult?.result?.tools) {
                        def matchingTool = toolsResult.result.tools.find { it.name == name }
                        if (matchingTool?.description?.startsWith("Moqui screen: ")) {
                            originalScreenPath = matchingTool.description.substring("Moqui screen: ".length())
                        }
                    }
                    
                    def screenPath = originalScreenPath
                    
                    // If we couldn't find the original path, try the old method as fallback
                    if (!screenPath) {
                        screenPath = toolName.replace('_', '/').replace('component///', 'component://').replace('/xml','.xml')
                        ec.logger.warn("Could not find original screen path for tool ${name}, using fallback reconstruction: ${screenPath}")
                    } else {
                        ec.logger.info("Found original screen path for tool ${name}: ${screenPath}")
                    }

                    // Restore user context from sessionId before calling screen tool
                    def serviceResult = null
                    def visit = null
                    UserInfo restoredUserInfo = null
                    try {
                        // Get Visit to find the actual user who created this session
                        visit = ec.entity.find("moqui.server.Visit")
                            .condition("visitId", sessionId)
                            .disableAuthz()
                            .one()
                        
                        if (!visit) {
                            throw new Exception("Invalid session for screen tool execution: ${sessionId}")
                        }
                        
                        // Restore user context - handle special MCP case where Visit was created with ADMIN
                        if (visit.userId && visit.userId != ec.user.userId) {
                            // Restore the actual user who created the session
                            def userAccount = ec.entity.find("moqui.security.UserAccount")
                                .condition("userId", visit.userId)
                                .disableAuthz()
                                .one()
                            if (userAccount) {
                                restoredUserInfo = ec.user.pushUser(userAccount.username)
                                ec.logger.info("Screen tool execution: Restored user context for ${userAccount.username}")
                            }
                        }
                        
                        // Now call the screen tool with proper user context
                        def screenParams = arguments ?: [:]
                        serviceResult = ec.service.sync().name("McpServices.execute#ScreenAsMcpTool")
                            .parameters([screenPath: screenPath, parameters: screenParams, renderMode: "html", sessionId: sessionId])
                            .call()
                            
                    } finally {
                        // Always restore original user context
                        if (restoredUserInfo != null) {
                            ec.user.popUser()
                            ec.logger.info("Screen tool execution: Restored original user context ${ec.user.username}")
                        }
                    }
                    
                    def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                    
                    // Convert result to MCP format
                    def content = []
                    
                    if (serviceResult?.result) {
                        // Handle screen execution result which has type, text, screenPath, screenUrl, executionTime
                        if (serviceResult.result.type == "text" && serviceResult.result.text) {
                            content << [
                                type: "text", 
                                text: serviceResult.result.text
                            ]
                        } else {
                            content << [
                                type: "text", 
                                text: serviceResult.result.toString() ?: "Screen executed successfully"
                            ]
                        }
                    }
                    
                    result.result = [
                        content: content,
                        isError: false
                    ]
                    return
                }
                
                // For service tools, validate service exists
                if (!ec.service.isServiceDefined(name)) {
                    throw new Exception("Tool not found: ${name}")
                }
                
                // Capture original user for permission context
                def originalUsername = ec.user.username
                UserInfo adminUserInfo = null
                
                try {
                    // Execute service with elevated privileges for system access
                    // but maintain audit context with actual user
                    def serviceResult
                    adminUserInfo = null
                    try {
                        serviceResult = ec.service.sync().name(name).parameters(arguments ?: [:]).call()
                    } finally {
                        if (adminUserInfo != null) {
                                ec.user.popUser()
                            }
                    }
                    def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                    
                    // Convert result to MCP format
                    def content = []
                    if (serviceResult) {
                        content << [
                            type: "text",
                            text: new JsonBuilder(serviceResult).toString()
                        ]
                    }
                    
                    result.result = [
                        content: content,
                        isError: false
                    ]
                } catch (Exception e) {
                    def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                    
                    result = [
                        content: [
                            [
                                type: "text",
                                text: "Error executing tool ${name}: ${e.message}"
                            ]
                        ],
                        isError: true
                    ]
                    
                    ec.logger.error("MCP tool execution error", e)
                } finally {
                    // Always restore original user context
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesList" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Handle MCP resources/list request with Moqui entity discovery</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Build list of available entities as resources
                def resources = []
                
                UserInfo adminUserInfo = null
                
                // Update session activity
                def metadata = [:]
                try {
                   metadata = groovy.json.JsonSlurper().parseText(visit.initialRequest ?: "{}") as Map
                } catch (Exception e) {
                   ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                }
                    
                // Store original user context before switching to ADMIN
                def originalUsername = ec.user.username
                def originalUserId = ec.user.userId
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                
                // Use curated list of commonly used entities instead of discovering all entities
                def availableResources = []
                
                ec.logger.info("MCP ResourcesList: Starting permissions-based entity discovery ${userGroups}")
                
                // Get user's accessible entities using Moqui's optimized ArtifactAuthzCheckView
                def userAccessibleEntities = null as Set<String>
                adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_ENTITY")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                    userAccessibleEntities = aacvList.collect { it.artifactName } as Set<String>
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Helper function to check if user has permission to an entity
                def userHasEntityPermission = { entityName ->
                    // Use pre-computed accessible entities set for O(1) lookup
                    return userAccessibleEntities != null && userAccessibleEntities.contains(entityName.toString())
                }
                
                // Add all permitted entities including ViewEntities for LLM convenience
                def allEntityNames = ec.entity.getAllEntityNames()
                def allViewNames = [] as Set<String>
                
                // Get ViewEntities by checking entity definitions for view entities
                def entityInfoList = ec.entity.getAllEntityInfo(0, true) // includeViewEntities=true
                for (entityInfo in entityInfoList) {
                    if (entityInfo.isViewEntity) {
                        allViewNames.add(entityInfo.entityName)
                    }
                }
                
                // Combine real entities and ViewEntities
                def allAccessibleEntities = allEntityNames + allViewNames
                
                for (entityName in allAccessibleEntities) {
                    if (userHasEntityPermission(entityName)) {
                        def description = "Moqui entity: ${entityName}"
                        if (entityName.contains("View")) {
                            description = "Moqui ViewEntity: ${entityName} (pre-joined data for LLM convenience)"
                        }
                        
                        ec.logger.info("MCP ResourcesList: Adding entity: ${entityName}")
                        availableResources << [
                            uri: "entity://${entityName}",
                            name: entityName,
                            description: description,
                            mimeType: "application/json"
                        ]
                    }
                }
                
                result = [resources: availableResources]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesRead" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Handle MCP resources/read request with Moqui entity queries</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                // Parse entity URI (format: entity://EntityName)
                if (!uri.startsWith("entity://")) {
                    throw new Exception("Invalid resource URI: ${uri}")
                }
                
                def entityName = uri.substring(9) // Remove "entity://" prefix
                
                // Validate entity exists
                if (!ec.entity.isEntityDefined(entityName)) {
                    throw new Exception("Entity not found: ${entityName}")
                }
                
                // Permission checking is handled by Moqui's artifact authorization system through artifact groups
                
try {
                 // Try to get entity definition - handle both real entities and view entities
                      def entityDef = null
                      try {
                          // First try getAllEntityInfo for detailed info
                          def entityInfoList = ec.entity.getAllEntityInfo(-1, true) // all entities, include view entities
                          entityDef = entityInfoList.find { it.entityName == entityName }
                          
                          if (!entityDef) {
                              // If not found in detailed list, try basic entity check
                              if (ec.entity.isEntityDefined(entityName)) {
                                  // Create minimal entity definition for basic query
                                  entityDef = [
                                      entityName: entityName,
                                      packageName: entityName.split('\\.')[0],
                                      description: "Entity: ${entityName}",
                                      isViewEntity: entityName.contains('View'),
                                      allFieldInfoList: []
                                  ]
                              }
                          }
                      } catch (Exception e) {
                          ec.logger.warn("ResourcesRead: Error getting entity info for ${entityName}: ${e.message}")
                          // Fallback: try basic entity check
                          if (ec.entity.isEntityDefined(entityName)) {
                              entityDef = [
                                  entityName: entityName,
                                  packageName: entityName.split('\\.')[0],
                                  description: "Entity: ${entityName}",
                                  isViewEntity: entityName.contains('View'),
                                  allFieldInfoList: []
                              ]
                          }
                      }
                      
                      if (!entityDef) {
                          throw new Exception("Entity not found: ${entityName}")
                      }
                      
                      ec.logger.info("ResourcesRead: Found entity ${entityName}, isViewEntity=${entityDef.isViewEntity}")
                     
                     // Query entity data (limited to prevent large responses)
                     def entityList = ec.entity.find(entityName)
                         .limit(100)
                         .list()
                     
                     def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                     
                     // SIZE PROTECTION: Check response size before returning
                     def jsonOutput = new JsonBuilder([
                         entityName: entityName,
                         description: entityDef.description ?: "",
                         packageName: entityDef.packageName,
                         recordCount: entityList.size(),
                         fields: fieldInfo,
                         data: entityList
                     ]).toString()
                     
                     def maxResponseSize = 1024 * 1024  // 1MB limit
                     if (jsonOutput.length() > maxResponseSize) {
                         ec.logger.warn("ResourcesRead: Response too large for ${entityName}: ${jsonOutput.length()} bytes (limit: ${maxResponseSize} bytes)")
                         
                         // Create truncated response with fewer records
                         def truncatedList = entityList.take(10)  // Keep only first 10 records
                         def truncatedOutput = new JsonBuilder([
                             entityName: entityName,
                             description: entityDef.description ?: "",
                             packageName: entityDef.packageName,
                             recordCount: entityList.size(),
                             fields: fieldInfo,
                             data: truncatedList,
                             truncated: true,
                             originalSize: entityList.size(),
                             truncatedSize: truncatedList.size(),
                             message: "Response truncated due to size limits. Original data has ${entityList.size()} records, showing first ${truncatedList.size()}."
                         ]).toString()
                         
                         contents = [
                             [
                                 uri: uri,
                                 mimeType: "application/json",
                                 text: truncatedOutput
                             ]
                         ]
                     } else {
                         // Normal response
                         contents = [
                             [
                                 uri: uri,
                                 mimeType: "application/json",
                                 text: jsonOutput
                             ]
                         ]
                     }
                     
                 } catch (Exception e) {
                      def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                      ec.logger.warn("Error reading resource ${uri}: ${e.message}")
                      result = [error: "Error reading resource ${uri}: ${e.message}"]
                  }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="Ping" authenticate="true" allow-remote="true" transaction-timeout="10">
        <description>Handle MCP ping request for health check</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
          <script><![CDATA[
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                // Get current user information
                def currentUser = ec.user.username
                def currentUserId = ec.user.userId
                
                // Try to get visit information if sessionId is provided
                def visitInfo = null
                if (sessionId) {
                    try {
                        def adminUserInfo = ec.user.pushUser("ADMIN")
                        try {
                            def visit = ec.entity.find("moqui.server.Visit")
                                .condition("visitId", sessionId)
                                .disableAuthz()
                                .one()
                            
                            if (visit) {
                                visitInfo = [
                                    visitId: visit.visitId,
                                    userId: visit.userId,
                                    fromDate: visit.fromDate,
                                    lastUpdatedStamp: visit.lastUpdatedStamp
                                ]
                            }
                        } finally {
                            ec.user.popUser()
                        }
                    } catch (Exception e) {
                        // Log but don't fail the ping
                        ec.logger.warn("Error getting visit info for sessionId ${sessionId}: ${e.message}")
                    }
                }
                
                result = [
                    timestamp: ec.user.getNowTimestamp(),
                    status: "healthy",
                    version: "2.0.2",
                    sessionId: sessionId,
                    currentUser: currentUser,
                    currentUserId: currentUserId,
                    visitInfo: visitInfo,
                    architecture: "Visit-based sessions"
                ]
            ]]></script>
        </actions>
    </service>

    <!-- Debug Service -->
    
    <service verb="debug" noun="ComponentStatus" authenticate="false" allow-remote="true">
        <description>Debug service to verify component is loaded and working</description>
        <in-parameters/>
        <out-parameters>
            <parameter name="status" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                def status = [
                    componentLoaded: true,
                    componentName: "mo-mcp",
                    timestamp: ec.user.getNowTimestamp(),
                    user: ec.user.username,
                    userId: ec.user.userId,
                    serviceNames: ec.service.getKnownServiceNames().findAll { it.contains("Mcp") },
                    entityNames: ec.entity.getAllEntityNames().findAll { it.contains("ArtifactHit") }
                ]
                
                ec.logger.info("=== MCP COMPONENT DEBUG ===")
                ec.logger.info("Component status: ${status}")
                ec.logger.info("All service names count: ${ec.service.getKnownServiceNames().size()}")
                ec.logger.info("All entity names count: ${ec.entity.getAllEntityNames().size()}")
                ec.logger.info("=== END MCP COMPONENT DEBUG ===")
                
                result.status = status
            ]]></script>
        </actions>
    </service>

    <!-- Helper Functions -->
    
    <service verb="validate" noun="Origin" authenticate="false" allow-remote="false">
        <description>Validate Origin header for DNS rebinding protection</description>
        <in-parameters>
            <parameter name="origin" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="isValid" type="boolean"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Allow localhost origins
                if (origin?.startsWith("http://localhost:") || origin?.startsWith("https://localhost:")) {
                    isValid = true
                    return
                }
                
                // Allow 127.0.0.1 origins
                if (origin?.startsWith("http://127.0.0.1:") || origin?.startsWith("https://127.0.0.1:")) {
                    isValid = true
                    return
                }
                
                // Allow same-origin requests (check against current host)
                def currentHost = ec.web?.request?.getServerName()
                def currentScheme = ec.web?.request?.getScheme()
                def currentPort = ec.web?.request?.getServerPort()
                
                def expectedOrigin = "${currentScheme}://${currentHost}"
                if ((currentScheme == "http" && currentPort != 80) || (currentScheme == "https" && currentPort != 443)) {
                    expectedOrigin += ":${currentPort}"
                }
                
                if (origin == expectedOrigin) {
                    isValid = true
                    return
                }
                
                // Check for configured allowed origins (could be from system properties)
                def allowedOrigins = ec.getFactory().getConfiguration().getStringList("moqui.mcp.allowed_origins", [])
                if (allowedOrigins.contains(origin)) {
                    isValid = true
                    return
                }
                
                isValid = false
            ]]></script>
        </actions>
    </service>
    
    <service verb="convert" noun="MoquiTypeToJsonSchemaType" authenticate="false">
        <description>Convert Moqui data types to JSON Schema types</description>
        <in-parameters>
            <parameter name="moquiType" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="jsonSchemaType"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                // Simple type mapping - can be expanded as needed
                def typeMap = [
                    "text-short": "string",
                    "text-medium": "string", 
                    "text-long": "string",
                    "text-very-long": "string",
                    "id": "string",
                    "id-long": "string",
                    "number-integer": "integer",
                    "number-decimal": "number",
                    "number-float": "number",
                    "date": "string",
                    "date-time": "string",
                    "date-time-nano": "string",
                    "boolean": "boolean",
                    "text-indicator": "boolean"
                ]
                
                jsonSchemaType = typeMap[moquiType] ?: "string"
            ]]></script>
        </actions>
    </service>




    <!-- Screen-based MCP Services -->
    
    <service verb="discover" noun="ScreensAsMcpTools" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Discover screens accessible to user and convert them to MCP tools</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="screenPathPattern" required="false"><description>Optional pattern to filter screen paths (supports wildcards)</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="tools" type="List"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                import org.moqui.impl.screen.ScreenDefinition
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("=== SCREEN DISCOVERY SERVICE CALLED ===")
                
                def originalUsername = ec.user.username
                def originalUserId = ec.user.userId
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                
                ec.logger.info("MCP Screen Discovery: Starting for user ${originalUsername} (${originalUserId}) with groups ${userGroups}")
                
                def tools = []
                
// Discover screens that user can actually access
                def accessibleScreens = [] as Set<String>
                adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    
                    // Get all user's accessible screens using ArtifactAuthzCheckView
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_XML_SCREEN")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                    accessibleScreens = aacvList.collect { it.artifactName } as Set<String>
                    
                    ec.logger.info("MCP Screen Discovery: Found ${accessibleScreens.size()} accessible screens for user ${originalUsername}")
                    
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Helper function to check if user has permission to a screen
                def userHasScreenPermission = { screenName ->
                    return accessibleScreens.contains(screenName.toString())
                }
                
                // Helper function to convert screen path to MCP tool name
                def screenPathToToolName = { screenPath ->
                    // Create a safe tool name but we'll store the original path in description
                    return "screen_" + screenPath.replaceAll("[^a-zA-Z0-9]", "_")
                }
                
                // Helper function to create MCP tool from screen
                def createScreenTool = { screenPath, title, description, parameters = [:] ->
                    def toolName = screenPathToToolName(screenPath)
                    return [
                        name: toolName,
                        title: title,
                        description: "Moqui screen: ${screenPath}",  // Store original path in description
                        inputSchema: [
                            type: "object",
                            properties: parameters,
                            required: []
                        ]
                    ]
                }
                
                // Use discovered screens instead of hardcoded list
                for (screenPath in accessibleScreens) {
                    try {
                        ec.logger.info("MCP Screen Discovery: Processing screen ${screenPath}")
                        
                        // For MCP, include all accessible screens - LLMs can decide what's useful
                        // Skip only obviously problematic patterns
                        if (screenPath.contains("/error/") || screenPath.contains("/system/")) {
                            ec.logger.info("MCP Screen Discovery: Skipping system screen ${screenPath}")
                            continue
                        }
                        
                        // Try to get screen definition, but don't require it for MCP
                        def screenDefinition = null
                        def title = screenPath.split("/")[-1]
                        def description = "Moqui screen: ${screenPath}"
                        
                        try {
                            screenDefinition = ec.screen.getScreenDefinition(screenPath)
                            // Screen XML doesn't have description elements, so use screen path as description
                            // We could potentially use default-menu-title attribute if available
                            if (screenDefinition?.screenNode?.attribute('default-menu-title')) {
                                title = screenDefinition.screenNode.attribute('default-menu-title')
                                description = "Moqui screen: ${screenPath} (${title})"
                            }
                        } catch (Exception e) {
                            ec.logger.info("MCP Screen Discovery: No screen definition for ${screenPath}, using basic info")
                            // Continue anyway - the screen might still be useful for MCP
                        }
                        
                        // Get screen parameters from transitions
                        def parameters = [:]
                        try {
                            def screenInfo = ec.screen.getScreenInfo(screenPath)
                            if (screenInfo?.transitionInfoByName) {
                                for (transitionEntry in screenInfo.transitionInfoByName) {
                                    def transitionInfo = transitionEntry.value
                                    // Add path parameters
                                    transitionInfo.ti?.getPathParameterList()?.each { param ->
                                        parameters[param] = [
                                            type: "string",
                                            description: "Path parameter for transition: ${param}"
                                        ]
                                    }
                                    // Add request parameters
                                    transitionInfo.ti?.getRequestParameterList()?.each { param ->
                                        parameters[param.name] = [
                                            type: "string",
                                            description: "Request parameter: ${param.name}"
                                        ]
                                    }
                                }
                            }
                        } catch (Exception e) {
                            ec.logger.debug("Could not extract parameters from screen ${screenPath}: ${e.message}")
                        }
                        
                        ec.logger.info("MCP Screen Discovery: Adding accessible screen ${screenPath}")
                        tools << createScreenTool(screenPath, title, description, parameters)
                        
                    } catch (Exception e) {
                        ec.logger.warn("Error processing screen ${screenPath}: ${e.message}")
                    }
                }
                
                ec.logger.info("MCP Screen Discovery: Created ${tools.size()} hardcoded screen tools for user ${originalUsername}")
                
                result.tools = tools
                
            ]]></script>
        </actions>
    </service>
    

    
    <service verb="convert" noun="ScreenToMcpTool" authenticate="false">
        <description>Convert a screen path to MCP tool format</description>
        <in-parameters>
            <parameter name="screenPath" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="tool" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("=== SCREEN TO MCP TOOL: ${screenPath} ===")
                
                tool = null
                try {
                    // Try to get screen definition
                    def screenDef = null
                    try {
                        ec.logger.info("SCREEN TO MCP: Getting screen definition for ${screenPath}")
                        screenDef = ec.screen.getScreenDefinition(screenPath)
                        ec.logger.info("SCREEN TO MCP: Got screen definition: ${screenDef ? 'YES' : 'NO'}")
                    } catch (Exception e) {
                        ec.logger.warn("SCREEN TO MCP: Error getting screen definition: ${e.message}")
                        // Screen might not exist or be accessible
                        return
                    }
                    
                    if (!screenDef) {
                        return
                    }
                    
                    // Extract screen information
                    def screenName = screenPath.replaceAll("[^a-zA-Z0-9]", "_")
                    def title = screenPath.split("/")[-1]
                    def description = "Moqui screen: ${screenPath}"
                    
                    // Safely get screen description - screen XML doesn't have description elements
                    try {
                        if (screenDef?.screenNode?.attribute('default-menu-title')) {
                            description = screenDef.screenNode.attribute('default-menu-title')
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not get screen title: ${e.message}")
                    }
                    
                    // Get screen parameters from transitions and forms
                    def parameters = [:]
                    def required = []
                    
                    try {
                        // Get transitions for parameter discovery
                        def transitions = screenDef.getTransitionMap()
                        transitions.each { transitionName, transition ->
                            transition.getPathParameterList().each { param ->
                                parameters[param] = [
                                    type: "string",
                                    description: "Path parameter: ${param}"
                                ]
                                required << param
                            }
                            
                            // Get single service parameters if transition calls a service
                            def serviceName = transition.getSingleServiceName()
                            if (serviceName) {
                                try {
                                    def serviceDef = ec.service.getServiceDefinition(serviceName)
                                    if (serviceDef) {
                                        def inParamNames = serviceDef.getInParameterNames()
                                        for (paramName in inParamNames) {
                                            def paramNode = serviceDef.getInParameter(paramName)
                                            def paramType = paramNode?.attribute('type') ?: 'String'
                                            def paramDesc = paramNode.first("description")?.text ?: "Parameter from service ${serviceName}"
                                            
                                            // Convert Moqui type to JSON Schema type
                                            def typeMap = [
                                                "text-short": "string",
                                                "text-medium": "string", 
                                                "text-long": "string",
                                                "text-very-long": "string",
                                                "id": "string",
                                                "id-long": "string",
                                                "number-integer": "integer",
                                                "number-decimal": "number",
                                                "number-float": "number",
                                                "date": "string",
                                                "date-time": "string",
                                                "date-time-nano": "string",
                                                "boolean": "boolean",
                                                "text-indicator": "boolean"
                                            ]
                                            def jsonSchemaType = typeMap[paramType] ?: "string"
                                            
                                            parameters[paramName] = [
                                                type: jsonSchemaType,
                                                description: paramDesc
                                            ]
                                            
                                            if (paramNode?.attribute('required') == "true") {
                                                required << paramName
                                            }
                                        }
                                    }
                                } catch (Exception e) {
                                    ec.logger.debug("Error getting service definition for ${serviceName}: ${e.message}")
                                }
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Error getting transitions for screen ${screenPath}: ${e.message}")
                    }
                    
                    // Build MCP tool
                    tool = [
                        name: "screen_${screenName}",
                        title: title,
                        description: "${description}. This tool renders the Moqui screen '${screenPath}' and returns the output.",
                        inputSchema: [
                            type: "object",
                            properties: parameters,
                            required: required.unique()
                        ]
                    ]
                    
                    // Add screen metadata
                    tool.screenPath = screenPath
                    tool.toolType = "screen"
                    
                    // Add screen structure metadata
                    try {
                        def screenInfo = ec.screen.getScreenInfo(screenPath)
                        if (screenInfo) {
                            tool.screenInfo = [
                                name: screenInfo.name,
                                level: screenInfo.level,
                                hasTransitions: screenInfo.transitions > 0,
                                hasForms: screenInfo.forms > 0,
                                subscreens: screenInfo.subscreens
                            ]
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not get screen info for metadata: ${e.message}")
                    }
                    
                } catch (Exception e) {
                    ec.logger.warn("Error converting screen ${screenPath} to MCP tool: ${e.message}")
                }
            ]]></script>
        </actions>
    </service>
    
    <service verb="execute" noun="ScreenAsMcpTool" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Execute a screen as an MCP tool</description>
        <in-parameters>
            <parameter name="screenPath" required="true"/>
            <parameter name="parameters" type="Map"><description>Parameters to pass to the screen</description></parameter>
            <parameter name="renderMode" default="html"><description>Render mode: text, html, xml, vuet, qvt</description></parameter>
            <parameter name="sessionId"><description>Session ID for user context restoration</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
import org.moqui.context.ExecutionContext
import groovy.json.JsonBuilder

ExecutionContext ec = context.ec

def startTime = System.currentTimeMillis()
    // Note: Screen validation will happen during render
    // if (!ec.screen.isScreenDefined(screenPath)) {
    //     throw new Exception("Screen not found: ${screenPath}")
    // }
    
    // Set parameters in context
    if (parameters) {
        ec.context.putAll(parameters)
    }
    
    // Try to render screen content for LLM consumption
    def output = null
    def screenUrl = "http://localhost:8080/${screenPath}"
    
    try {
        ec.logger.info("MCP Screen Execution: Attempting to render screen ${screenPath} using ScreenTest with proper root screen")
        
        // For ScreenTest to work properly, we need to use the correct root screen
        // The screenPath should be relative to the appropriate root screen
        def testScreenPath = screenPath
        def rootScreen = "component://webroot/screen/webroot.xml"
        
        // Initialize standalone flag outside the if block
        def targetScreenDef = null
        def isStandalone = false
        
                // If the screen path is already a full component:// path, we need to handle it differently
        if (screenPath.startsWith("component://")) {
            // For component:// paths, we need to use the component's root screen, not webroot
            // Extract the component name and use its root screen
            def pathAfterComponent = screenPath.substring(12) // Remove "component://"
            def pathParts = pathAfterComponent.split("/")
            if (pathParts.length >= 2) {
                def componentName = pathParts[0]
                def remainingPath = pathParts[1..-1].join("/")
                
                // Check if the target screen itself is standalone FIRST
                try {
                    targetScreenDef = ec.screen.getScreenDefinition(screenPath)
                    ec.logger.info("MCP Screen Execution: Target screen def for ${screenPath}: ${targetScreenDef?.getClass()?.getSimpleName()}")
                    if (targetScreenDef?.screenNode) {
                        def standaloneAttr = targetScreenDef.screenNode.attribute('standalone')
                        ec.logger.info("MCP Screen Execution: Target screen ${screenPath} standalone attribute: '${standaloneAttr}'")
                        isStandalone = standaloneAttr == "true"
                    } else {
                        ec.logger.warn("MCP Screen Execution: Target screen ${screenPath} has no screenNode")
                    }
                    ec.logger.info("MCP Screen Execution: Target screen ${screenPath} standalone=${isStandalone}")
                    
                    if (isStandalone) {
                        // For standalone screens, try to render with minimal context or fall back to URL
                        ec.logger.info("MCP Screen Execution: Standalone screen detected, will try direct rendering")
                        rootScreen = screenPath
                        testScreenPath = ""  // Empty path for standalone screens
                        // We'll handle standalone screens specially below
                    }
                } catch (Exception e) {
                    ec.logger.warn("MCP Screen Execution: Error checking target screen ${screenPath}: ${e.message}")
                    ec.logger.error("MCP Screen Execution: Full exception", e)
                }
                
                // Only look for component root if target is not standalone
                if (!isStandalone) {
                    // For component://webroot/screen/... paths, always use webroot as root
                    if (pathAfterComponent.startsWith("webroot/screen/")) {
                        // This is a webroot screen, use webroot as root and the rest as path
                        rootScreen = "component://webroot/screen/webroot.xml"
                        testScreenPath = pathAfterComponent.substring("webroot/screen/".length())
                        // Remove any leading "webroot/" from the path since we're already using webroot as root
                        if (testScreenPath.startsWith("webroot/")) {
                            testScreenPath = testScreenPath.substring("webroot/".length())
                        }
                        ec.logger.info("MCP Screen Execution: Using webroot root for webroot screen: ${rootScreen} with path: ${testScreenPath}")
                    } else {
                        // For other component screens, check if this is a direct screen path (not a subscreen path)
                        def pathSegments = remainingPath.split("/")
                        def isDirectScreenPath = false
                        
                        // Try to check if the full path is a valid screen
                        try {
                            def directScreenDef = ec.screen.getScreenDefinition(screenPath)
                            if (directScreenDef) {
                                isDirectScreenPath = true
                                ec.logger.info("MCP Screen Execution: Found direct screen path: ${screenPath}")
                            }
                        } catch (Exception e) {
                            ec.logger.debug("MCP Screen Execution: Direct screen check failed for ${screenPath}: ${e.message}")
                        }
                        
                        if (isDirectScreenPath) {
                            // For direct screen paths, use the screen itself as root
                            rootScreen = screenPath
                            testScreenPath = ""
                            ec.logger.info("MCP Screen Execution: Using direct screen as root: ${rootScreen}")
                        } else {
                            // Try to find the actual root screen for this component
                            def componentRootScreen = null
                            def possibleRootScreens = [
                                "${componentName}.xml",
                                "${componentName}Root.xml", 
                                "${componentName}Admin.xml"
                            ]
                            
                            for (rootScreenName in possibleRootScreens) {
                                def candidateRoot = "component://${componentName}/screen/${rootScreenName}"
                                try {
                                    def testDef = ec.screen.getScreenDefinition(candidateRoot)
                                    if (testDef) {
                                        componentRootScreen = candidateRoot
                                        ec.logger.info("MCP Screen Execution: Found component root screen: ${componentRootScreen}")
                                        break
                                    }
                                } catch (Exception e) {
                                    ec.logger.debug("MCP Screen Execution: Root screen ${candidateRoot} not found: ${e.message}")
                                }
                            }
                            
                            if (componentRootScreen) {
                                rootScreen = componentRootScreen
                                testScreenPath = remainingPath
                                ec.logger.info("MCP Screen Execution: Using component root ${rootScreen} for path ${testScreenPath}")
                            } else {
                                // For mantle and other components, try using the component's screen directory as root
                                // This is a better fallback than webroot
                                def componentScreenRoot = "component://${componentName}/screen/"
                                if (pathAfterComponent.startsWith("${componentName}/screen/")) {
                                    // Extract the screen file name from the path
                                    def screenFileName = pathAfterComponent.substring("${componentName}/screen/".length())
                                    rootScreen = screenPath  // Use the full path as root
                                    testScreenPath = ""     // Empty path for direct screen access
                                    ec.logger.info("MCP Screen Execution: Using component screen as direct root: ${rootScreen}")
                                } else {
                                    // Final fallback: try webroot
                                    rootScreen = "component://webroot/screen/webroot.xml"
                                    testScreenPath = pathAfterComponent
                                    ec.logger.warn("MCP Screen Execution: Could not find component root for ${componentName}, using webroot fallback: ${testScreenPath}")
                                }
                            }
                        }
                    }
                }
            } else {
                // Fallback for malformed component paths
                testScreenPath = pathAfterComponent
                ec.logger.warn("MCP Screen Execution: Malformed component path, using fallback: ${testScreenPath}")
            }
        }
        
        // User context should already be correct from MCP servlet restoration
        // CustomScreenTestImpl will capture current user context automatically
        ec.logger.info("MCP Screen Execution: Current user context - userId: ${ec.user.userId}, username: ${ec.user.username}")
        
        // Regular screen rendering with current user context - use our custom ScreenTestImpl
        def screenTest = new org.moqui.mcp.CustomScreenTestImpl(ec.ecfi)
            .rootScreen(rootScreen)
            .renderMode(renderMode ? renderMode : "html")
        
        ec.logger.info("MCP Screen Execution: ScreenTest object created: ${screenTest?.getClass()?.getSimpleName()}")
            
                if (screenTest) {
                    def renderParams = parameters ?: [:]
                    
                    // Add current user info to render context to maintain authentication
                    renderParams.userId = ec.user.userId
                    renderParams.username = ec.user.username
                    
                    // Set user context in ScreenTest to maintain authentication
                    // Note: ScreenTestImpl may not have direct userAccountId property, 
                    // the user context should be inherited from the current ExecutionContext
                    ec.logger.info("MCP Screen Execution: Current user context - userId: ${ec.user.userId}, username: ${ec.user.username}")
                    
                    // Regular screen rendering with timeout
                    def future = java.util.concurrent.Executors.newSingleThreadExecutor().submit({
                        return screenTest.render(testScreenPath, renderParams, null)
                    } as java.util.concurrent.Callable)
                    
                    try {
                        def testRender = future.get(30, java.util.concurrent.TimeUnit.SECONDS)  // 30 second timeout
                        output = testRender.output
                        def outputLength = output?.length() ?: 0
                        
                        // SIZE PROTECTION: Check response size before returning
                        def maxResponseSize = 1024 * 1024  // 1MB limit
                        if (outputLength > maxResponseSize) {
                            ec.logger.warn("MCP Screen Execution: Response too large for ${screenPath}: ${outputLength} bytes (limit: ${maxResponseSize} bytes)")
                            
                            // Create truncated response with clear indication
                            def truncatedOutput = output.substring(0, Math.min(maxResponseSize / 2, outputLength))
                            output = """SCREEN RESPONSE TRUNCATED

The screen '${screenPath}' generated a response that is too large for MCP processing:
- Original size: ${outputLength} bytes
- Size limit: ${maxResponseSize} bytes
- Truncated to: ${truncatedOutput.length()} bytes

TRUNCATED CONTENT:
${truncatedOutput}

[Response truncated due to size limits. Consider using more specific screen parameters or limiting data ranges.]"""
                        }
                        
                        ec.logger.info("MCP Screen Execution: Successfully rendered screen ${screenPath}, output length: ${output?.length() ?: 0}")
                    } catch (java.util.concurrent.TimeoutException e) {
                        future.cancel(true)
                        throw new Exception("Screen rendering timed out after 30 seconds for ${screenPath}")
                    } finally {
                        future.cancel(true)
                    }
                } else {
                    throw new Exception("ScreenTest object is null")
                }
    } catch (Exception e) {
        ec.logger.warn("MCP Screen Execution: Could not render screen ${screenPath}, exposing error details: ${e.message}")
        ec.logger.warn("MCP Screen Execution: Exception details: ${e.getClass()?.getSimpleName()}: ${e.getMessage()}")
        ec.logger.error("MCP Screen Execution: Full exception for ${screenPath}", e)
        
        // Expose detailed error information instead of URL fallback
        def errorDetails = []
        errorDetails << "SCREEN RENDERING ERROR"
        errorDetails << "======================"
        errorDetails << "Screen Path: ${screenPath}"
        errorDetails << "Error Type: ${e.getClass()?.getSimpleName()}"
        errorDetails << "Error Message: ${e.getMessage()}"
        errorDetails << ""
        
        // Add stack trace for debugging (limited depth for readability)
        if (e.getStackTrace()) {
            errorDetails << "Stack Trace (top 10 frames):"
            e.getStackTrace().take(10).eachWithIndex { stackTrace, index ->
                errorDetails << "  ${index + 1}. ${stackTrace.toString()}"
            }
            if (e.getStackTrace().size() > 10) {
                errorDetails << "  ... and ${e.getStackTrace().size() - 10} more frames"
            }
        }
        
        // Add cause information if available
        def cause = e.getCause()
        if (cause) {
            errorDetails << ""
            errorDetails << "Root Cause: ${cause.getClass()?.getSimpleName()}: ${cause.getMessage()}"
        }
        
        // Add context information
        errorDetails << ""
        errorDetails << "Context Information:"
        errorDetails << "- User: ${ec.user.username} (${ec.user.userId})"
        errorDetails << "- Render Mode: ${renderMode}"
        errorDetails << "- Parameters: ${parameters ?: 'none'}"
        errorDetails << "- Execution Time: ${((System.currentTimeMillis() - startTime) / 1000.0)}s"
        
        // Add troubleshooting suggestions
        errorDetails << ""
        errorDetails << "Troubleshooting Suggestions:"
        errorDetails << "1. Check if the screen path is correct and the screen exists"
        errorDetails << "2. Verify user has permission to access this screen"
        errorDetails << "3. Check if all required parameters are provided"
        errorDetails << "4. Verify screen dependencies and data access"
        errorDetails << "5. Check server logs for more detailed error information"
        
        output = errorDetails.join("\n")
    }
    
    def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
    
    // Return just the rendered screen content for MCP wrapper to handle
    result = [
        type: "text",
        text: output,
        screenPath: screenPath,
        screenUrl: screenUrl,
        executionTime: executionTime
    ]
    
    ec.logger.info("MCP Screen Execution: Generated URL for screen ${screenPath} in ${executionTime}s")
            ]]></script>
        </actions>
    </service>

    <!-- NOTE: handle#McpRequest service removed - functionality moved to screen/webapp.xml for unified handling -->

</services>