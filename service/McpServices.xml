<?xml version="1.0" encoding="UTF-8"?>
<!-- This software is in the public domain under CC0 1.0 Universal plus a 
     Grant of Patent License.

     To the extent possible under law, the author(s) have dedicated all
     copyright and related and neighboring rights to this software to the
     public domain worldwide. This software is distributed without any warranty.

     You should have received a copy of the CC0 Public Domain Dedication
     along with this software (see the LICENSE.md file). If not, see
     <https://creativecommons.org/publicdomain/zero/1.0/>. -->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- MCP Services using Moqui's built-in JSON-RPC support -->
    
    
    <service verb="mcp" noun="Initialize" authenticate="true" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP initialize request using Moqui authentication</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="protocolVersion" required="true"/>
            <parameter name="capabilities" type="Map"/>
            <parameter name="clientInfo" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Permissions are handled by Moqui's artifact authorization system
                // Users must be in appropriate groups (McpUser, MCP_BUSINESS) with access to McpServices artifact group
                
                // Disable authz to prevent automatic Visit updates during MCP operations
                ec.artifactExecution.disableAuthz()
                
                // Get Visit (session) created by servlet and validate access
                def visit = ec.entity.find("moqui.server.Visit")
                    .condition("visitId", sessionId)
                    .one()
                
                if (!visit) {
                    throw new Exception("Invalid session: ${sessionId}")
                }
                
                if (visit.userId != ec.user.userId) {
                    throw new Exception("Access denied for session: ${sessionId}")
                }
                
                // Update Visit with MCP initialization data
                UserInfo adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def metadata = [:]
                    try {
                        metadata = groovy.json.JsonSlurper().parseText(visit.initialRequest ?: "{}") as Map
                    } catch (Exception e) {
                        ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                    }
                    
                    metadata.mcpInitialized = true
                    metadata.mcpProtocolVersion = protocolVersion
                    metadata.mcpCapabilities = capabilities
                    metadata.mcpClientInfo = clientInfo
                    metadata.mcpInitializedAt = System.currentTimeMillis()
                    
                    // Session metadata stored in memory only - no Visit updates to prevent lock contention
                    ec.logger.info("SESSIONID: ${sessionId} - metadata stored in memory")
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Validate protocol version - support common MCP versions with version negotiation
                def supportedVersions = ["2025-11-25", "2025-06-18", "2024-11-05", "2024-10-07", "2023-06-05"]
                if (!supportedVersions.contains(protocolVersion)) {
                    throw new Exception("Unsupported protocol version: ${protocolVersion}. Supported versions: ${supportedVersions.join(', ')}")
                }

                // Get current user context (if authenticated)
                def userId = ec.user.userId
                def userAccountId = userId ? userId : null

                // Try to load root instructions from wiki
                def instructions = null
                try {
                    def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                        .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                        .condition("pagePath", "root")
                        .useCache(true)
                        .one()

                    if (wikiPage) {
                        def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                            .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                            .one()

                        if (wikiSpace) {
                            def pageLocation = wikiSpace.rootPageLocation
                            if (!pageLocation.endsWith('/')) pageLocation += '/'
                            pageLocation += wikiPage.pagePath + '.md'

                            def pageRef = ec.resource.getLocationReference(pageLocation)
                            def wikiText = pageRef?.getText()
                            if (wikiText) {
                                instructions = wikiText
                                ec.logger.info("MCP Initialize: Loaded root instructions from wiki")
                            }
                        }
                    }
                } catch (Exception e) {
                    ec.logger.debug("Could not load root instructions from wiki: ${e.message}")
                }

                // Fallback to hardcoded instructions if wiki not available
                if (!instructions) {
                    instructions = "This server provides access to Moqui ERP through MCP. Use moqui_browse_screens(path='/PopCommerce') to begin. Key screens include: /PopCommerce/Catalog/Product/FindProduct for products, /PopCommerce/Order/FindOrder for orders, and /PopCommerce/Customer for customer management. All screens support parameterized queries for filtering results."
                }
                
                // Build server capabilities - don't fetch actual tools/resources during init
                // Tools and resources will be discovered via separate list requests per MCP spec
                def serverCapabilities = [
                    tools: [listChanged: true],
                    resources: [subscribe: true, listChanged: true],
                    logging: [:]
                ]
                
                // Build server info
                def serverInfo = [
                    name: "Moqui MCP Server",
                    version: "2.0.1"
                ]
                
                result = [
                    protocolVersion: "2025-06-18",
                    capabilities: serverCapabilities,
                    serverInfo: serverInfo,
                    sessionId: sessionId,
                    instructions: instructions
                ]
                
                ec.logger.info("MCP Initialize for user ${userId} (session ${sessionId}): capabilities negotiated")
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ToolsCall" authenticate="true" allow-remote="true" transaction-timeout="300">
        <description>Handle MCP tools/call request with direct Moqui service execution</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="name" required="true"/>
            <parameter name="arguments" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                // Start timing for execution metrics
                def startTime = System.currentTimeMillis()
                def isError = false
                
                try {
                    // Consolidated Tool Dispatching

                    ec.logger.info("MCP ToolsCall: Dispatching tool name=${name}, arguments=${arguments}")
                    ec.logger.info("MCP ToolsCall: CODE VERSION: 2025-01-09 - FIXED NULL CHECK")

                    if (name == "moqui_render_screen" || name == "moqui_browse_screens") {
                        def targetServiceName = name == "moqui_browse_screens" ? "McpServices.mcp#BrowseScreens" : "McpServices.execute#ScreenAsMcpTool"
                        def serviceResult = ec.service.sync().name(targetServiceName).parameters(arguments ?: [:]).call()
                        
                        // Ensure standard MCP response format with content array
                        def actualRes = serviceResult?.result ?: serviceResult
                        if (actualRes instanceof Map && actualRes.content && actualRes.content instanceof List) {
                            result = actualRes
                        } else {
                            result = [ content: [[type: "text", text: new groovy.json.JsonBuilder(actualRes).toString()]], isError: false ]
                        }
                        return
                    }
                    
                    // Handle internal discovery/utility tools
                    def internalToolMappings = [
                        "moqui_search_screens": "McpServices.mcp#SearchScreens",
                        "moqui_get_screen_details": "McpServices.mcp#GetScreenDetails"
                    ]
                    
                    def targetServiceName = internalToolMappings[name]
                    if (targetServiceName) {
                        def serviceResult = ec.service.sync().name(targetServiceName).parameters(arguments ?: [:]).call()
                        def actualRes = serviceResult?.result ?: serviceResult
                        // Ensure standard MCP response format with content array
                        if (actualRes instanceof Map && actualRes.content && actualRes.content instanceof List) {
                            result = actualRes
                        } else {
                            result = [ content: [[type: "text", text: new groovy.json.JsonBuilder(actualRes).toString()]], isError: false ]
                        }
                        return
                     }

                    // Fallback: check if it's a general Moqui service (non-screen-based tools)
                    if (ec.service.isServiceDefined(name)) {
                        // Execute service with current user context
                        def serviceResult = ec.service.sync().name(name).parameters(arguments ?: [:]).call()
                        // Convert result to MCP format for general services
                        result = [content: [[type: "text", text: new JsonBuilder(serviceResult).toString()]], isError: false]
                        return
                    }

                    throw new Exception("Unknown tool name: ${name}")
                } catch (Exception e) {
                    isError = true
                    
                    result = [
                        content: [
                            [
                                type: "text",
                                text: "Error executing tool ${name}: ${e.message}"
                            ]
                        ],
                        isError: true
                    ]
                    
                    ec.logger.error("MCP tool execution error", e)
                } finally {
                    // Send a simple notification about tool execution
                    try {
                        def servlet = ec.web.getServletContext().getAttribute("enhancedMcpServlet")
                        if (servlet && sessionId) {
                            def notification = [
                                method: "notifications/tool_execution",
                                params: [
                                    toolName: name,
                                    executionTime: (System.currentTimeMillis() - startTime) / 1000.0,
                                    success: !isError,
                                    timestamp: System.currentTimeMillis()
                                ]
                            ]
                            //servlet.queueNotification(sessionId, notification)
                        }
                    } catch (Exception e) {
                        ec.logger.warn("Failed to send tool execution notification: ${e.message}")
                    }
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesList" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Handle MCP resources/list request with Moqui entity discovery based on user permissions</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                def availableResources = []
                
                ec.logger.debug("MCP ResourcesList: Discovering entities for user groups: ${userGroups}")
                
                // Use ArtifactAuthzCheckView to find all entities user has permission for
                // This is the "Moqui Way" - rely on the security system to tell us what is accessible
                def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                    .condition("userGroupId", userGroups)
                    .condition("artifactTypeEnumId", "AT_ENTITY")
                    .condition("authzActionEnumId", "AUTHZA_VIEW")
                    .useCache(true)
                    .disableAuthz()
                    .list()
                
                for (def aacv in aacvList) {
                    def entityName = aacv.artifactName
                    // Basic sanity check to ensure entity is actually defined
                    if (ec.entity.isEntityDefined(entityName)) {
                        def description = "Moqui entity: ${entityName}"
                        if (entityName.contains("View")) {
                            description = "Moqui ViewEntity: ${entityName}"
                        }
                        
                        availableResources << [
                            uri: "entity://${entityName}",
                            name: entityName,
                            description: description,
                            mimeType: "application/json"
                        ]
                    }
                }
                
                // Add instructions resource for MCP_USER role
                if (userGroups.contains("McpUser")) {
                    availableResources << [
                        uri: "moqui://mcp/instructions",
                        name: "instructions",
                        description: "MCP server usage instructions",
                        mimeType: "text/plain"
                    ]
                }
                
                result = [resources: availableResources]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesRead" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Handle MCP resources/read request with Moqui entity queries</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                def startTime = System.currentTimeMillis()
                
                // Handle special moqui://mcp/instructions resource
                if (uri == "moqui://mcp/instructions") {
                    // Try to load from wiki
                    def instructionsText = null
                    try {
                        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                            .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                            .condition("pagePath", "root")
                            .useCache(true)
                            .one()

                        if (wikiPage) {
                            def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                                .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                                .one()

                            if (wikiSpace) {
                                def pageLocation = wikiSpace.rootPageLocation
                                if (!pageLocation.endsWith('/')) pageLocation += '/'
                                pageLocation += wikiPage.pagePath + '.md'

                                def pageRef = ec.resource.getLocationReference(pageLocation)
                                instructionsText = pageRef?.getText()
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not load instructions from wiki: ${e.message}")
                    }

                    // Fallback to hardcoded instructions
                    if (!instructionsText) {
                        instructionsText = "This server provides access to Moqui ERP through MCP. Use moqui_browse_screens(path='/PopCommerce') to begin. Key screens include: /PopCommerce/Catalog/Product/FindProduct for products, /PopCommerce/Order/FindOrder for orders, and /PopCommerce/Customer for customer management. All screens support parameterized queries for filtering results."
                    }

                    result = [
                        content: [[
                            uri: "moqui://mcp/instructions",
                            mimeType: "text/plain",
                            text: instructionsText
                        ]],
                        isError: false
                    ]
                    return
                }
                
                // Parse entity URI (format: entity://EntityName)
                if (!uri.startsWith("entity://")) {
                    throw new Exception("Invalid resource URI: ${uri}")
                }
                
                def entityName = uri.substring(9)
                
                if (!ec.entity.isEntityDefined(entityName)) {
                    throw new Exception("Entity not found: ${entityName}")
                }
                
                try {
                    def entityDef = null
                    try {
                        def entityInfoList = ec.entity.getAllEntityInfo(-1, true)
                        entityDef = entityInfoList.find { it.entityName == entityName }
                    } catch (Exception e) {
                        ec.logger.debug("Error getting detailed entity info: ${e.message}")
                    }
                    
                    if (!entityDef) {
                        entityDef = [
                            entityName: entityName,
                            packageName: entityName.contains('.') ? entityName.split('\\.')[0] : "",
                            description: "Entity: ${entityName}",
                            isViewEntity: entityName.contains('View'),
                            allFieldInfoList: []
                        ]
                    }
                    
                    // Query entity data
                    def entityList = ec.entity.find(entityName).limit(100).list()
                    
                    // Format response for MCP - create multiple content objects
                    def contentList = []
                    
                    // Add main content with entity data as text
                    contentList << [
                        type: "text",
                        text: new JsonBuilder([
                            entityName: entityName,
                            description: entityDef.description,
                            packageName: entityDef.packageName,
                            recordCount: entityList.size(),
                            data: entityList
                        ]).toString()
                    ]
                    
                    def responseMap = [
                        content: contentList,
                        isError: false
                    ]
                    
                    def jsonOutput = new JsonBuilder(responseMap).toString()
                    
                    // Size protection
                    def maxResponseSize = 1024 * 1024 // 1MB
                    if (jsonOutput.length() > maxResponseSize) {
                         def truncatedList = entityList.take(10)
                         responseMap.data = truncatedList
                         responseMap.truncated = true
                         responseMap.message = "Truncated to 10 records due to size."
                         jsonOutput = new JsonBuilder(responseMap).toString()
                    }
                    
                    result = [
                        content: [[
                            uri: uri,
                            mimeType: "application/json",
                            text: jsonOutput
                        ]],
                        isError: false
                    ]
                    
                } catch (Exception e) {
                    ec.logger.error("Error reading resource ${uri}", e)
                    result = [isError: true, content: [[type:"text", text: e.message]]]
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="Ping" authenticate="true" allow-remote="true" transaction-timeout="10">
        <description>Handle MCP ping request for health check</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
          <script><![CDATA[
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                // Get current user information
                def currentUser = ec.user.username
                def currentUserId = ec.user.userId
                
                // Try to get visit information if sessionId is provided
                def visitInfo = null
                if (sessionId) {
                    try {
                        ec.artifactExecution.disableAuthz()
                        def adminUserInfo = ec.user.pushUser("ADMIN")
                        try {
                            def visit = ec.entity.find("moqui.server.Visit")
                                .condition("visitId", sessionId)
                                .one()
                            
                            if (visit) {
                                visitInfo = [
                                    visitId: visit.visitId,
                                    userId: visit.userId,
                                    fromDate: visit.fromDate,
                                    lastUpdatedStamp: visit.lastUpdatedStamp
                                ]
                            }
                        } finally {
                            ec.user.popUser()
                        }
                        ec.artifactExecution.enableAuthz()
                    } catch (Exception e) {
                        // Log but don't fail the ping
                        ec.logger.warn("Error getting visit info for sessionId ${sessionId}: ${e.message}")
                    }
                }
                
                result = [
                    timestamp: ec.user.getNowTimestamp(),
                    status: "healthy",
                    version: "2.0.2",
                    sessionId: sessionId,
                    currentUser: currentUser,
                    currentUserId: currentUserId,
                    visitInfo: visitInfo,
                    architecture: "Visit-based sessions"
                ]
            ]]></script>
        </actions>
    </service>

    <!-- Debug Service -->
    
    <service verb="debug" noun="ComponentStatus" authenticate="false" allow-remote="true">
        <description>Debug service to verify component is loaded and working</description>
        <in-parameters/>
        <out-parameters>
            <parameter name="status" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                def status = [
                    componentLoaded: true,
                    componentName: "mo-mcp",
                    timestamp: ec.user.getNowTimestamp(),
                    user: ec.user.username,
                    userId: ec.user.userId,
                    serviceNames: ec.service.getKnownServiceNames().findAll { it.contains("Mcp") },
                    entityNames: ec.entity.getAllEntityNames().findAll { it.contains("ArtifactHit") }
                ]
                
                ec.logger.info("=== MCP COMPONENT DEBUG ===")
                ec.logger.info("Component status: ${status}")
                ec.logger.info("All service names count: ${ec.service.getKnownServiceNames().size()}")
                ec.logger.info("All entity names count: ${ec.entity.getAllEntityNames().size()}")
                ec.logger.info("=== END MCP COMPONENT DEBUG ===")
                
                result.status = status
            ]]></script>
        </actions>
    </service>

    <service verb="execute" noun="ScreenAsMcpTool" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Execute a screen as an MCP tool</description>
        <in-parameters>
            <parameter name="path" required="true"/>
            <parameter name="parameters" type="Map"><description>Parameters to pass to screen</description></parameter>
            <parameter name="action"><description>Action being processed: if not null, use real screen rendering instead of test mock</description></parameter>
            <parameter name="renderMode" default="compact"><description>Render mode: compact (default, actionable summary), aria (accessibility tree), mcp (full metadata), text, html, xml, vuet, qvt</description></parameter>
            <parameter name="sessionId"><description>Session ID for user context restoration</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
import org.moqui.context.ExecutionContext
import groovy.json.JsonBuilder

ExecutionContext ec = context.ec

def startTime = System.currentTimeMillis()

// Set parameters in context
if (parameters) {
    ec.context.putAll(parameters)
}

// Map path parameter to screenPath for consistency
def screenPath = path

// Helper function to get simple path from component path
def getSimplePath = { fullPath ->
    if (!fullPath || fullPath == "root") return "root"
    String cleanPath = fullPath
    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
    List<String> parts = cleanPath.split('/').toList()
    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
    return parts.join('/')
}

// Helper to extract short description/summary from wiki content
def extractSummary = { wikiText ->
    if (!wikiText) return null
    def textString = wikiText instanceof String ? wikiText : new String(wikiText, "UTF-8")
    def lines = textString.split('\n')
    for (def line : lines) {
        def trimmed = line.trim()
        // Skip empty lines and headers
        if (trimmed && !trimmed.startsWith('#')) {
            return trimmed.take(200)
        }
    }
    return null
}

// Helper function to load wiki instructions for a screen
def getWikiInstructions = { lookupPath ->
    try {
        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
            .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
            .condition("pagePath", lookupPath)
            .useCache(true)
            .one()

        if (!wikiPage) return null

        def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
            .condition("wikiSpaceId", wikiPage.wikiSpaceId)
            .one()

        if (!wikiSpace) return null

        // Build the resource location for the page
        def pageLocation = wikiSpace.rootPageLocation
        if (!pageLocation.endsWith('/')) {
            pageLocation += '/'
        }
        pageLocation += wikiPage.pagePath + '.md'

        // Get the resource reference and text content
        def pageRef = ec.resource.getLocationReference(pageLocation)
        def wikiText = pageRef?.getText()

        if (wikiText) {
            return wikiText
        }
    } catch (Exception e) {
        ec.logger.debug("Could not load wiki instructions for ${screenPath}: ${e.message}")
    }
    return null
}

// Recursive serializer for Moqui/Java objects to JSON-friendly Map/List
// Applies reasonable safety limits to prevent massive payloads
def serializeMoquiObject
serializeMoquiObject = { obj, depth = 0 ->
    if (depth > 8) return "..." // Prevent deep recursion
    
    if (obj == null) return null
    if (obj instanceof Map) {
        def newMap = [:]
        obj.each { k, v ->
            def keyStr = k.toString()
            // Skip internal framework keys and metadata fields
            if (keyStr.startsWith("_") || keyStr == "ec" || keyStr == "sri") return
            // Skip audit fields to reduce payload
            if (keyStr in ["lastUpdatedStamp", "lastUpdatedTxStamp", "createdDate", "createdTxStamp", "createdByUserLogin"]) return
            def value = serializeMoquiObject(v, depth + 1)
            if (value != null) newMap[keyStr] = value
        }
        return newMap
    }
    if (obj instanceof Iterable) {
        def list = obj.collect()
        // Safety limit: truncate very large lists (10000+ items)
        def maxItems = 10000
        if (list.size() > maxItems) {
            ec.logger.info("serializeMoquiObject: Truncating large list from ${list.size()} to ${maxItems} items")
            def truncated = list.take(maxItems)
            def resultList = truncated.collect { serializeMoquiObject(it, depth + 1) }
            return [
                _items: resultList,
                _totalCount: list.size(),
                _truncated: true,
                _hasMore: true,
                _message: "Showing first ${maxItems} of ${list.size()} items. Use pagination for more."
            ]
        }
        return list.collect { serializeMoquiObject(it, depth + 1) }
    }
    if (obj instanceof org.moqui.entity.EntityValue) {
        return serializeMoquiObject(obj.getMap(), depth + 1)
    }
    if (obj instanceof java.sql.Timestamp || obj instanceof java.util.Date) {
        return obj.toString()
    }
    if (obj instanceof Number || obj instanceof Boolean) {
        return obj
    }
    if (obj instanceof String) {
        // Safety limit: truncate very large strings (1MB+)
        if (obj.length() > 1000000) {
            return [
                _value: obj.substring(0, 1000000) + "...",
                _fullLength: obj.length(),
                _truncated: true,
                _message: "Truncated to 1MB for safety."
            ]
        }
        return obj
    }
    if (obj.getClass().getName().startsWith("org.moqui.impl.screen.ScreenDefinition")) {
        return [location: obj.location]
    }
    // Skip EntityFind objects entirely - they're query definitions, not actual data
    if (obj instanceof org.moqui.entity.EntityFind) {
        return null
    }
    // Fallback for unknown types
    def str = obj.toString()
    if (str.length() > 10000) {
        return [
            _value: str.substring(0, 10000) + "...",
            _fullLength: str.length(),
            _truncated: true
        ]
    }
    return str
}

// Convert MCP semantic state to ARIA accessibility tree format
// This produces a compact, standard representation matching W3C ARIA roles
def convertToAriaTree = { semanticState, targetScreenPath ->
    if (!semanticState) return null
    
    def data = semanticState.data
    if (!data) return [role: "document", name: targetScreenPath, children: []]
    
    def children = []
    def formMetadata = data.formMetadata ?: [:]
    
    // Map Moqui field types to ARIA roles
    def fieldToAriaRole = { field ->
        switch (field.type) {
            case "dropdown": return "combobox"
            case "text": return "textbox"
            case "textarea": return "textbox"
            case "checkbox": return "checkbox"
            case "radio": return "radio"
            case "date": return "textbox"  // with date semantics
            case "date-time": return "textbox"
            case "number": return "spinbutton"
            case "password": return "textbox"
            case "hidden": return null  // skip hidden fields
            default: return "textbox"
        }
    }
    
    // Convert a field to ARIA node
    def fieldToAriaNode = { field ->
        def role = fieldToAriaRole(field)
        if (!role) return null
        
        def node = [
            role: role,
            name: field.title ?: field.name
        ]
        
        // Add required attribute
        if (field.required) node.required = true
        
        // For dropdowns, show option count instead of all options
        if (field.type == "dropdown") {
            def optionCount = field.options?.size() ?: 0
            if (field.totalOptions) optionCount = field.totalOptions
            if (optionCount > 0) {
                node.options = optionCount
                if (field.optionsTruncated) {
                    node.fetchHint = field.fetchHint
                }
            }
            // Check for dynamic options
            if (field.dynamicOptions) {
                node.autocomplete = true
            }
        }
        
        return node
    }
    
    // Process forms (form-single types become form landmarks)
    formMetadata.each { formName, formData ->
        if (formData.type == "form-list") return  // Handle separately
        
        def formNode = [
            role: "form",
            name: formData.name ?: formName,
            children: []
        ]
        
        // Add fields
        formData.fields?.each { field ->
            def fieldNode = fieldToAriaNode(field)
            if (fieldNode) formNode.children << fieldNode
        }
        
        // Find submit button by matching form name pattern
        // e.g., CreatePersonForm -> createPerson action
        def formBaseName = formName.replaceAll(/Form$/, "")
        def expectedActionName = formBaseName.substring(0,1).toLowerCase() + formBaseName.substring(1)
        def submitAction = semanticState.actions?.find { a -> 
            a.name == expectedActionName || a.name?.equalsIgnoreCase(expectedActionName)
        }
        if (submitAction) {
            formNode.children << [role: "button", name: submitAction.name]
        }
        
        if (formNode.children) children << formNode
    }
    
    // Process form-lists (become grids)
    formMetadata.findAll { k, v -> v.type == "form-list" }.each { formName, formData ->
        def listData = data[formName]
        def itemCount = 0
        if (listData instanceof List) {
            itemCount = listData.size()
        } else if (listData?._totalCount) {
            itemCount = listData._totalCount
        }
        
        def gridNode = [
            role: "grid",
            name: formData.name ?: formName,
            rowcount: itemCount
        ]
        
        // Add column info
        def columns = formData.fields?.collect { it.title ?: it.name }
        if (columns) gridNode.columns = columns
        
        // Add sample rows (first 3)
        if (listData instanceof List && listData.size() > 0) {
            gridNode.children = []
            listData.take(3).each { row ->
                def rowNode = [role: "row"]
                // Extract key identifying info
                def name = row.combinedName ?: row.name ?: row.productName ?: row.pseudoId ?: row.id
                if (name) rowNode.name = name
                gridNode.children << rowNode
            }
            if (listData.size() > 3) {
                gridNode.moreRows = listData.size() - 3
            }
        }
        
        children << gridNode
    }
    
    // Process navigation links
    def navLinks = semanticState.data?.links?.findAll { it.type == "navigation" }
    if (navLinks && navLinks.size() > 0) {
        def navNode = [
            role: "navigation",
            name: "Links",
            children: navLinks.take(10).collect { link ->
                [role: "link", name: link.text, path: link.path]
            }
        ]
        if (navLinks.size() > 10) {
            navNode.moreLinks = navLinks.size() - 10
        }
        children << navNode
    }
    
    // Process actions as a toolbar
    def serviceActions = semanticState.actions?.findAll { it.type == "service-action" }
    if (serviceActions && serviceActions.size() > 0) {
        def toolbarNode = [
            role: "toolbar",
            name: "Actions",
            children: serviceActions.take(10).collect { action ->
                [role: "button", name: action.name]
            }
        ]
        if (serviceActions.size() > 10) {
            toolbarNode.moreActions = serviceActions.size() - 10
        }
        children << toolbarNode
    }
    
    return [
        role: "main",
        name: targetScreenPath?.split('/')?.last() ?: "Screen",
        children: children
    ]
}

// Convert MCP semantic state to compact actionable format
// Designed for LLM efficiency: enough info to act without fetching more
def convertToCompactFormat = { semanticState, targetScreenPath ->
    if (!semanticState) return null
    
    def data = semanticState.data
    def formMetadata = data?.formMetadata ?: [:]
    def actions = semanticState.actions ?: []
    
    def result = [
        screen: targetScreenPath?.split('/')?.last() ?: "Screen"
    ]
    
    // Build summary
    def formCount = formMetadata.count { k, v -> v.type != "form-list" }
    def listCount = formMetadata.count { k, v -> v.type == "form-list" }
    def actionNames = actions.findAll { it.type == "service-action" }.collect { it.name }.take(5)
    
    def summaryParts = []
    if (formCount > 0) summaryParts << "${formCount} form${formCount > 1 ? 's' : ''}"
    if (listCount > 0) {
        // Get total row count
        def totalRows = 0
        formMetadata.findAll { k, v -> v.type == "form-list" }.each { formName, formData ->
            def listData = data[formName]
            if (listData instanceof List) totalRows += listData.size()
        }
        summaryParts << "${totalRows} result${totalRows != 1 ? 's' : ''}"
    }
    if (actionNames) summaryParts << "actions: ${actionNames.join(', ')}"
    result.summary = summaryParts.join(". ")
    
    // Process forms (non-list)
    def forms = [:]
    formMetadata.findAll { k, v -> v.type != "form-list" }.each { formName, formData ->
        def formInfo = [:]
        def fields = []
        
        formData.fields?.each { field ->
            if (field.type == "hidden") return
            
            def fieldInfo
            def fieldName = field.name
            def displayName = field.title ?: field.name
            
            if (field.type == "dropdown") {
                def optionCount = field.totalOptions ?: field.options?.size() ?: 0
                if (optionCount > 0) {
                    fieldInfo = [(fieldName): [type: "dropdown", options: optionCount]]
                    // Include first few options as examples
                    if (field.options && field.options.size() > 0) {
                        def examples = field.options.take(3).collect { it.value }
                        fieldInfo[fieldName].examples = examples
                    }
                    if (field.dynamicOptions) {
                        fieldInfo[fieldName].autocomplete = true
                    }
                } else {
                    fieldInfo = [(fieldName): [type: "dropdown"]]
                }
                if (displayName != fieldName) fieldInfo[fieldName].label = displayName
            } else {
                // Simple field - just use name, add label if different
                if (displayName != fieldName) {
                    fieldInfo = [(fieldName): displayName]
                } else {
                    fieldInfo = fieldName
                }
            }
            
            if (field.required) {
                if (fieldInfo instanceof String) {
                    fieldInfo = [(fieldName): [required: true]]
                } else if (fieldInfo instanceof Map && fieldInfo[fieldName] instanceof String) {
                    fieldInfo[fieldName] = [label: fieldInfo[fieldName], required: true]
                } else if (fieldInfo instanceof Map && fieldInfo[fieldName] instanceof Map) {
                    fieldInfo[fieldName].required = true
                }
            }
            
            fields << fieldInfo
        }
        
        formInfo.fields = fields
        
        // Find matching action for this form
        def formBaseName = formName.replaceAll(/Form$/, "")
        def expectedActionName = formBaseName.substring(0,1).toLowerCase() + formBaseName.substring(1)
        def submitAction = actions.find { a -> 
            a.name == expectedActionName || a.name?.equalsIgnoreCase(expectedActionName)
        }
        if (submitAction) {
            formInfo.submit = submitAction.name
            if (submitAction.service) {
                formInfo.service = submitAction.service
            }
        }
        
        forms[formName] = formInfo
    }
    if (forms) result.forms = forms
    
    // Process grids (form-lists)
    def grids = [:]
    formMetadata.findAll { k, v -> v.type == "form-list" }.each { formName, formData ->
        def listData = data[formName]
        def gridInfo = [:]
        
        // Column names
        def columns = formData.fields?.findAll { it.type != "hidden" }?.collect { it.title ?: it.name }
        if (columns) gridInfo.columns = columns
        
        // Rows with key data and links
        if (listData instanceof List && listData.size() > 0) {
            gridInfo.rowCount = listData.size()
            gridInfo.rows = listData.take(10).collect { row ->
                def rowInfo = [:]
                
                // Get identifying info
                def id = row.pseudoId ?: row.partyId ?: row.productId ?: row.orderId ?: row.id
                def name = row.combinedName ?: row.productName ?: row.name
                
                if (id) rowInfo.id = id
                if (name && name != id) rowInfo.name = name
                
                // Find link for this row
                def rowLinks = data.links?.findAll { link ->
                    link.path?.contains(id?.toString()) && link.type == "navigation"
                }
                if (rowLinks && rowLinks.size() > 0) {
                    // Pick the most relevant link (edit/view)
                    def editLink = rowLinks.find { it.path?.contains("Edit") }
                    rowInfo.link = (editLink ?: rowLinks[0]).path
                }
                
                rowInfo
            }
            if (listData.size() > 10) {
                gridInfo.more = listData.size() - 10
            }
        } else {
            gridInfo.rowCount = 0
        }
        
        grids[formName] = gridInfo
    }
    if (grids) result.grids = grids
    
    // Actions with parameter hints
    def actionMap = [:]
    actions.findAll { it.type == "service-action" && it.service }.each { action ->
        def actionInfo = [service: action.service]
        
        // Find form that uses this action to get parameter hints
        def matchingForm = forms.find { k, v -> v.submit == action.name }
        if (matchingForm) {
            def requiredFields = matchingForm.value.fields?.findAll { f ->
                (f instanceof Map && f.values().any { v -> 
                    (v instanceof Map && v.required) || v == "required"
                })
            }?.collect { f ->
                f instanceof Map ? f.keySet()[0] : f
            }
            if (requiredFields) actionInfo.required = requiredFields
        }
        
        actionMap[action.name] = actionInfo
    }
    if (actionMap) result.actions = actionMap
    
    // Navigation - only external/important links
    def navLinks = data?.links?.findAll { link ->
        link.type == "navigation" && link.path && !link.path.contains("?")
    }?.take(5)?.collect { [name: it.text, path: it.path] }
    if (navLinks) result.nav = navLinks
    
    return result
}

// Resolve input screen path to simple path for lookup
def inputScreenPath = screenPath
if (screenPath.startsWith("component://")) {
    inputScreenPath = getSimplePath(screenPath)
}
ec.logger.info("MCP Screen Execution: Looking up wiki docs for ${inputScreenPath}")

// Try to get wiki instructions
def wikiInstructions = getWikiInstructions(inputScreenPath)
        
        // Try to render screen content for LLM consumption
        def output = null
        def screenUrl = "http://localhost:8080/${screenPath}"
        def isError = false
        def resolvedScreenDef = null
         
        try {
            ec.logger.info("MCP Screen Execution: Attempting to render screen ${screenPath}")
            
            def rootScreen = "component://webroot/screen/webroot.xml"
            def testScreenPath = screenPath
            
            if (screenPath.startsWith("component://")) {
                // Component path handling
                resolvedScreenDef = ec.screen.getScreenDefinition(screenPath)
                rootScreen = screenPath
                testScreenPath = ""
            } else {
                // Forward slash path handling (e.g. /PopCommerce/Catalog)
                def testPath = screenPath.startsWith('/') ? screenPath : "/" + screenPath
                def pathSegments = []
                testPath.split('/').each { if (it && it.trim()) pathSegments.add(it) }
                
                // 1. Try literal resolution from webroot
                rootScreen = "component://webroot/screen/webroot.xml"
                def webrootSd = ec.screen.getScreenDefinition(rootScreen)
                def screenPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                    webrootSd, webrootSd, pathSegments, testPath, [:], ec.screenFacade
                )
                
                def currentSd = webrootSd
                def reachedIndex = -1
                if (screenPathList) {
                    for (int i = 0; i < screenPathList.size(); i++) {
                        def screenName = screenPathList[i]
                        def ssi = currentSd?.getSubscreensItem(screenName)
                        if (ssi && ssi.getLocation()) {
                            currentSd = ec.screen.getScreenDefinition(ssi.getLocation())
                            reachedIndex = i
                        } else {
                            break
                        }
                    }
                }
                
                // 2. If literal resolution failed, try Component-based resolution
                if (reachedIndex == -1 && pathSegments.size() >= 2) {
                    def componentName = pathSegments[0]
                    def rootScreenName = pathSegments[1]
                    def compRootLoc = "component://${componentName}/screen/${rootScreenName}.xml"
                    
                    if (ec.resource.getLocationReference(compRootLoc).exists) {
                        ec.logger.info("MCP Path Resolution: Found component root at ${compRootLoc}")
                        rootScreen = compRootLoc
                        testScreenPath = pathSegments.size() > 2 ? pathSegments[2..-1].join('/') : ""
                        resolvedScreenDef = ec.screen.getScreenDefinition(rootScreen)
                        
                        // Resolve further if there are remaining segments
                        if (testScreenPath) {
                            def remainingSegments = pathSegments[2..-1]
                            def compPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                                resolvedScreenDef, resolvedScreenDef, remainingSegments, testScreenPath, [:], ec.screenFacade
                            )
                            if (compPathList) {
                                for (String screenName in compPathList) {
                                    def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                    if (ssi && ssi.getLocation()) {
                                        resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                    } else {
                                        break
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 3. Fallback to double-slash search if still not found
                if (reachedIndex == -1 && !resolvedScreenDef && pathSegments.size() > 0 && !testPath.startsWith("//")) {
                    def searchPath = "//" + pathSegments.join('/')
                    ec.logger.info("MCP Path Resolution: Fallback to search path ${searchPath}")
                    
                    rootScreen = "component://webroot/screen/webroot.xml"
                    def searchPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                        webrootSd, webrootSd, pathSegments, searchPath, [:], ec.screenFacade
                    )
                    
                    if (searchPathList) {
                        testScreenPath = searchPath
                        resolvedScreenDef = webrootSd
                        for (String screenName in searchPathList) {
                            def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                            if (ssi && ssi.getLocation()) {
                                resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                            } else {
                                break
                            }
                        }
                    }
                }
                
                // If we found a specific target, we're good. 
                // If not, default to webroot with full path (original behavior, but now we know it failed)
                if (!resolvedScreenDef) {
                    rootScreen = "component://webroot/screen/webroot.xml"
                    resolvedScreenDef = webrootSd
                    testScreenPath = testPath
                }
            }

            // Regular screen rendering with current user context - use our custom ScreenTestImpl
            // For compact/ARIA modes, we still render with MCP to get semantic data, then convert
            def actualScreenRenderMode = (renderMode == "aria" || renderMode == "compact" || renderMode == null) ? "mcp" : renderMode
            def screenTest = new org.moqui.mcp.CustomScreenTestImpl(ec.ecfi)
                .rootScreen(rootScreen)
                .renderMode(actualScreenRenderMode)
                .auth(ec.user.username)

            def renderParams = parameters ?: [:]
            renderParams.userId = ec.user.userId
            renderParams.username = ec.user.username

            // Build the screen path - append action/transition if specified
            // This lets the framework handle transition execution properly (inheritance, pre/post actions, etc.)
            def relativePath = testScreenPath
            def actionResult = [:]
            
            if (action && resolvedScreenDef) {
                // Verify the transition exists
                def transition = resolvedScreenDef.getAllTransitions().find { it.getName() == action }
                if (transition) {
                    // Append transition to path - framework will execute it via recursiveRunTransition
                    relativePath = "${testScreenPath}/${action}"
                    def serviceName = transition.getSingleServiceName()
                    actionResult = [
                        action: action,
                        service: serviceName,
                        status: "pending"  // Will be updated after render based on errors
                    ]
                    ec.logger.info("MCP Screen Execution: Will execute transition '${action}' via framework (service: ${serviceName ?: 'none'})")
                } else {
                    ec.logger.warn("MCP Screen Execution: Action '${action}' not found in screen transitions")
                    actionResult = [
                        action: action,
                        status: "error",
                        message: "Transition '${action}' not found on screen"
                    ]
                }
            }
            
            // Clear entity cache before rendering to ensure fresh data
            ec.cache.clearAllCaches()
            ec.logger.info("MCP Screen Execution: Entity cache cleared before rendering")
            
            ec.logger.info("TESTRENDER root=${rootScreen} path=${relativePath} params=${renderParams}")
            
            def testRender = screenTest.render(relativePath, renderParams, "POST")
            output = testRender.getOutput()
            
            // --- Capture Action Result from Framework Execution ---
            def postContext = testRender.getPostRenderContext()
            
            if (action && actionResult.status == "pending") {
                // Check for errors from transition execution
                def errorMessages = testRender.getErrorMessages()
                def hasError = errorMessages && errorMessages.size() > 0
                
                if (hasError) {
                    actionResult.status = "error"
                    actionResult.message = errorMessages.join("; ")
                    ec.logger.error("MCP Screen Execution: Transition '${action}' completed with errors: ${actionResult.message}")
                } else {
                    actionResult.status = "executed"
                    actionResult.message = "Transition '${action}' executed successfully"
                    
                    // Try to extract result from context (services often put results in context)
                    // Common patterns: result, serviceResult, *Id (for create operations)
                    def result = [:]
                    if (postContext) {
                        // Look for common result patterns
                        ['result', 'serviceResult', 'createResult'].each { key ->
                            if (postContext.containsKey(key)) {
                                result[key] = postContext.get(key)
                            }
                        }
                        // Look for created IDs (common pattern: partyId, productId, orderId, etc.)
                        postContext.each { key, value ->
                            if (key.toString().endsWith('Id') && value && !key.toString().startsWith('_')) {
                                // Only include if it looks like a created/returned ID
                                def keyStr = key.toString()
                                if (!['userId', 'username', 'sessionId', 'requestId'].contains(keyStr)) {
                                    result[keyStr] = value
                                }
                            }
                        }
                    }
                    if (result) {
                        actionResult.result = result
                    }
                    ec.logger.info("MCP Screen Execution: Transition '${action}' executed successfully, result: ${result}")
                }
            }

            // --- Semantic State Extraction ---
            def semanticState = [:]

            // Get final screen definition using resolved screen location
            def finalScreenDef = resolvedScreenDef

            if (finalScreenDef && postContext) {
                semanticState.screenPath = inputScreenPath
                semanticState.data = [:]
                
                // Use the explicit semantic data captured by macros if available
                def explicitData = postContext.get("mcpSemanticData")
                if (explicitData instanceof Map) {
                    explicitData.each { k, v ->
                        semanticState.data[k] = serializeMoquiObject(v, 0)
                    }
                }
                
                // Extract transitions (Actions) with type classification and metadata
                semanticState.actions = []
                finalScreenDef.getAllTransitions().each { trans ->
                    def transName = trans.getName()
                    def service = trans.getSingleServiceName()
                    
                    // Classify action type
                    def actionType = "screen-transition"
                    def transNameLower = transName?.toString()?.toLowerCase() ?: ''
                    
                    if (service) {
                        actionType = "service-action"
                    } else if (transNameLower.contains('delete')) {
                        actionType = "delete-action"
                    } else if (transNameLower.startsWith('form') || transNameLower == 'find' || transNameLower == 'search') {
                        actionType = "form-action"
                    }
                    
                    def actionInfo = [
                        name: transName,
                        service: service,
                        type: actionType
                    ]
                    
                    semanticState.actions << actionInfo
                }
                
                // 3. Extract parameters with metadata
                semanticState.parameters = [:]
                if (finalScreenDef.parameterByName) {
                    finalScreenDef.parameterByName.each { name, param ->
                        def value = postContext.get(name) ?: parameters?.get(name)
                        
                        // Build parameter metadata
                        def paramInfo = [:]
                        
                        // Add value if exists
                        if (value != null) {
                            paramInfo.value = serializeMoquiObject(value, 0)
                        }
                        
                        // Extract parameter type - try multiple approaches
                        def type = "string"
                        try {
                            // Try to get type via reflection or known properties
                            if (param.hasProperty('type')) {
                                def typeObj = param.type
                                if (typeObj != null) type = typeObj.toString().toLowerCase()
                            } else if (param.hasProperty('parameterType')) {
                                def typeObj = param.parameterType
                                if (typeObj != null) type = typeObj.toString().toLowerCase()
                            }
                        } catch (Exception e) {
                            // Fall back to type inference from value
                        }
                        
                        // Infer type from value if type couldn't be extracted
                        if (type == "string" && value != null) {
                            if (value instanceof Number) {
                                type = (value instanceof Integer || value instanceof Long) ? "long" : "decimal"
                            } else if (value instanceof Boolean) {
                                type = "boolean"
                            } else if (value instanceof Collection || value instanceof Map) {
                                type = (value instanceof Collection) ? "list" : "map"
                            }
                        }
                        paramInfo.type = type
                        
                        // Extract required flag - defensive check
                        paramInfo.required = false
                        try {
                            if (param.hasProperty('required')) {
                                paramInfo.required = (param.required == true)
                            }
                        } catch (Exception e) {
                            // Skip if property doesn't exist
                        }
                        
                        // Extract default value - defensive check
                        try {
                            if (param.hasProperty('defaultValue') && param.defaultValue != null) {
                                paramInfo.defaultValue = param.defaultValue.toString()
                            }
                        } catch (Exception e) {
                            // Skip if property doesn't exist
                        }
                        
                        semanticState.parameters[name] = paramInfo
                    }
                }
                
                // Log semantic state size for optimization tracking
                def semanticStateJson = new groovy.json.JsonBuilder(semanticState).toString()
                def semanticStateSize = semanticStateJson.length()
                ec.logger.info("MCP Screen Execution: Semantic state size: ${semanticStateSize} bytes, data keys: ${semanticState.data.keySet()}, actions count: ${semanticState.actions.size()}")
            }
            
            ec.logger.info("MCP Screen Execution: Successfully rendered screen ${screenPath}, output length: ${output?.length() ?: 0}")

            def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
            
            // Build result based on renderMode
            def content = []
            if ((renderMode == null || renderMode == "compact") && semanticState) {
                // Return compact actionable format (default)
                def compactData = convertToCompactFormat(semanticState, screenPath)
                
                // Include wiki summary if available
                if (wikiInstructions) {
                    def wikiSummary = extractSummary(wikiInstructions)
                    if (wikiSummary) compactData.help = wikiSummary
                }
                
                // Add action result if an action was executed
                if (actionResult) {
                    compactData.result = actionResult
                }
                
                content << [
                    type: "text",
                    text: new groovy.json.JsonBuilder(compactData).toString()
                ]
            } else if (renderMode == "aria" && semanticState) {
                // Return ARIA accessibility tree format
                def ariaTree = convertToAriaTree(semanticState, screenPath)
                def ariaResult = [
                    screenPath: screenPath,
                    aria: ariaTree
                ]
                
                // Include summary if available
                if (wikiInstructions) {
                    def summary = extractSummary(wikiInstructions)
                    if (summary) ariaResult.summary = summary
                }
                
                // Add action result if an action was executed
                if (actionResult) {
                    ariaResult.actionResult = actionResult
                }
                
                content << [
                    type: "text",
                    text: new groovy.json.JsonBuilder(ariaResult).toString()
                ]
            } else if ((renderMode == "mcp" || renderMode == "json") && semanticState) {
                // Return structured MCP data
                def mcpResult = [
                    screenPath: screenPath,
                    screenUrl: screenUrl,
                    executionTime: executionTime,
                    isError: isError,
                    semanticState: semanticState
                ]
                
                // Add action result if an action was executed
                if (actionResult) {
                    mcpResult.actionResult = actionResult
                }
                
                // Include text output preview (truncated for readability)
                if (output) {
                    mcpResult.textPreview = output.take(2000) + (output.length() > 2000 ? "..." : "")
                }
                if (wikiInstructions) {
                    mcpResult.wikiInstructions = wikiInstructions
                    def summary = extractSummary(wikiInstructions)
                    if (summary) mcpResult.summary = summary
                }
                
                content << [
                    type: "text",
                    text: new groovy.json.JsonBuilder(mcpResult).toString()
                ]
            } else {
                // Return raw output for other modes (text, html, etc)
                def textOutput = output
                if (wikiInstructions) {
                    textOutput = "--- Wiki Instructions ---\n\n${wikiInstructions}\n\n--- Screen Output ---\n\n${output}"
                }
                content << [
                    type: "text",
                    text: textOutput,
                    screenPath: screenPath,
                    screenUrl: screenUrl,
                    executionTime: executionTime,
                    isError: isError
                ]
            }
            
            result = [
                content: content,
                isError: false
            ]
            return // Success!

        } catch (Exception e) {
            isError = true
            ec.logger.error("MCP Screen Execution: Full exception for ${screenPath}", e)
            output = "SCREEN RENDERING ERROR: ${e.message}"
            result = [
                isError: true,
                content: [[type: "text", text: output]]
            ]
        }
    ]]></script>
</actions>
</service>

    <service verb="mcp" noun="ResourcesTemplatesList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/templates/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // For now, return empty templates list - can be extended later
                def templates = []
                
                result = [resourceTemplates: templates]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ResourcesSubscribe" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/subscribe request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"><description>Resource URI to subscribe to</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Resource subscription requested for URI: ${uri}, sessionId: ${sessionId}")
                
                // For now, just return success - actual subscription tracking could be added
                result = [subscribed: true, uri: uri]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ResourcesUnsubscribe" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/unsubscribe request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"><description>Resource URI to unsubscribe from</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Resource unsubscription requested for URI: ${uri}, sessionId: ${sessionId}")
                
                // For now, just return success - actual subscription tracking could be added
                result = [unsubscribed: true, uri: uri]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="PromptsList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP prompts/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonSlurper
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("MCP PromptsList: Listing prompts from wiki space MCP_PROMPTS")
                
                def prompts = []
                
                // Query all wiki pages in MCP_PROMPTS space
                def wikiPageList = ec.entity.find("moqui.resource.wiki.WikiPage")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .useCache(true)
                    .list()
                
                for (def wp in wikiPageList) {
                    // Try to load argument schema from attachment
                    def arguments = []
                    try {
                        def attachment = ec.entity.find("moqui.resource.wiki.WikiPageAttachment")
                            .condition("wikiPageId", wp.wikiPageId)
                            .condition("filename", "arguments.json")
                            .one()
                        if (attachment) {
                            def attachmentRef = ec.resource.getLocationReference(attachment.getLocation())
                            def jsonText = attachmentRef?.getText()
                            if (jsonText) {
                                arguments = new JsonSlurper().parseText(jsonText) ?: []
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not parse arguments for ${wp.pagePath}: ${e.message}")
                    }
                    
                    prompts << [
                        name: wp.pagePath,
                        title: wp.pagePath.split('-').collect { it.capitalize() }.join(' '),
                        description: "MCP prompt template",
                        arguments: arguments
                    ]
                }
                
                result = [prompts: prompts]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="PromptsGet" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP prompts/get request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="name" required="true"><description>Prompt name to retrieve</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.text.GStringTemplateEngine
                import groovy.json.JsonSlurper
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("MCP PromptsGet: Retrieving prompt '${name}' from wiki space MCP_PROMPTS")
                
                // Get the wiki page for this prompt
                def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .condition("pagePath", name)
                    .one()
                
                if (!wikiPage) {
                    throw new Exception("Prompt not found: ${name}")
                }
                
                // Get the wiki space to build the page location
                def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .one()
                
                if (!wikiSpace) {
                    throw new Exception("MCP Prompts wiki space not found")
                }
                
                // Build the resource location for the page (root + page path + .md)
                def pageLocation = wikiSpace.rootPageLocation
                if (!pageLocation.endsWith('/')) {
                    pageLocation += '/'
                }
                pageLocation += name + '.md'
                
                // Get the resource reference and text content
                def pageRef = ec.resource.getLocationReference(pageLocation)
                def templateText = pageRef?.getText()
                
                if (!templateText) {
                    throw new Exception("Prompt template not found: ${name}")
                }
                
                // Render template using Groovy GString engine
                def templateEngine = new GStringTemplateEngine()
                def template = templateEngine.createTemplate(templateText)
                def binding = arguments ?: [:]
                def rendered = template.make(binding).toString()
                
                ec.logger.info("MCP PromptsGet: Rendered prompt '${name}' with ${binding.size()} arguments")
                
                result = [
                    description: "MCP prompt template",
                    messages: [[
                        role: "user",
                        content: [type: "text", text: rendered]
                    ]]
                ]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="RootsList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP roots/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // For now, return empty roots list - can be extended later
                def roots = []
                
                result = [roots: roots]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="SamplingCreateMessage" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP sampling/createMessage request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="messages" type="List"><description>List of messages to sample</description></parameter>
            <parameter name="maxTokens" type="Integer"><description>Maximum tokens to generate</description></parameter>
            <parameter name="temperature" type="BigDecimal"><description>Sampling temperature</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Sampling createMessage requested for sessionId: ${sessionId}")
                
                // For now, return not implemented - can be extended with actual LLM integration
                result = [error: "Sampling not implemented"]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ElicitationCreate" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP elicitation/create request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="prompt"><description>Prompt for elicitation</description></parameter>
            <parameter name="context"><description>Context for elicitation</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Elicitation create requested for sessionId: ${sessionId}")
                
                // For now, return not implemented - can be extended later
                result = [error: "Elicitation not implemented"]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="BrowseScreens" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Browse Moqui screens hierarchically to discover functionality. Renders screen content with renderMode='mcp' by default. Supports action parameter for form submission and transitions.</description>
        <in-parameters>
            <parameter name="path" required="false"><description>Screen path to browse (e.g. 'PopCommerce'). Leave empty for root apps.</description></parameter>
            <parameter name="action"><description>Action to process before rendering: null (browse), 'submit' (form), 'create', 'update', or transition name</description></parameter>
            <parameter name="renderMode" default="compact"><description>Render mode: compact (default, actionable summary), aria (accessibility tree), mcp (full metadata), text, html, xml, vuet, qvt</description></parameter>
            <parameter name="parameters" type="Map"><description>Parameters to pass to screen during rendering or action</description></parameter>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext

                ExecutionContext ec = context.ec
                ec.logger.info("BrowseScreens: SERVICE STARTED")
                def subscreens = []
                def currentPath = path ?: "root"
                def userGroups = ec.user.getUserGroupIdSet().collect { it }

                // Strip query parameters from path for screen resolution
                if (currentPath.contains("?")) {
                    currentPath = currentPath.split("\\?")[0]
                }
                
                // Helper function to load wiki content
                def loadWikiContent = { path ->
                    ec.logger.info("BrowseScreens: loadWikiContent CALLED for ${path}")
                    try {
                        def simplePath = (path == "root") ? "root" : path
                        if (simplePath.contains("?")) {
                            simplePath = simplePath.split("\\?")[0]
                        }

                        ec.logger.info("BrowseScreens: Looking up wiki instructions for ${simplePath}")

                        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                            .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                            .condition("pagePath", simplePath)
                            .useCache(true)
                            .one()

                        if (wikiPage) {
                            ec.logger.info("BrowseScreens: Found wikiPage: ${wikiPage.pagePath}")
                            def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                                .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                                .one()

                            if (wikiSpace) {
                                ec.logger.info("BrowseScreens: Found wikiSpace: ${wikiSpace.wikiSpaceId}")

                                def dbResource = ec.entity.find("moqui.resource.DbResource")
                                    .condition("parentResourceId", "WIKI_MCP_SCREEN_DOCS")
                                    .condition("filename", wikiPage.pagePath + ".md")
                                    .one()

                                if (dbResource) {
                                    ec.logger.info("BrowseScreens: Found dbResource: ${dbResource.resourceId}")
                                    def dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                        .condition("resourceId", dbResource.resourceId)
                                        .condition("versionName", wikiPage.publishedVersionName)
                                        .one()

                                    ec.logger.info("BrowseScreens: dbResourceFile query result: ${dbResourceFile ? 'found' : 'null'}")

                                    if (!dbResourceFile) {
                                        dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                            .condition("resourceId", dbResource.resourceId)
                                            .one()
                                        ec.logger.info("BrowseScreens: dbResourceFile fallback query result: ${dbResourceFile ? 'found' : 'null'}")
                                    }

                                    if (dbResourceFile) {
                                        ec.logger.info("BrowseScreens: dbResourceFile.fileData: ${dbResourceFile.fileData ? 'exists, size=' + dbResourceFile.fileData.length() : 'null'}")
                                    }

                                    if (dbResourceFile && dbResourceFile.fileData) {
                                        def content = new String(dbResourceFile.fileData.getBytes(new Long(1).longValue(), new Long(dbResourceFile.fileData.length()).intValue()), "UTF-8")
                                        ec.logger.info("BrowseScreens: Found wiki instructions for ${simplePath}, length: ${content?.length()}")
                                        return content
                                    }
                                } else {
                                    ec.logger.warn("BrowseScreens: No dbResource found for ${wikiPage.pagePath}.md")
                                }
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.warn("BrowseScreens: Error getting wiki instructions: ${e.message}")
                    }
                    return null
                }

                // Helper to convert full component path to simple path (PopCommerce/screen/Root.xml -> PopCommerce/Root)
                def convertToSimplePath = { fullPath ->
                    if (!fullPath) return null
                    String cleanPath = fullPath
                    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
                    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
                    List<String> parts = cleanPath.split('/').toList()
                    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
                    return parts.join('/')
                }

                // Helper to extract short description from wiki content
                def getShortDescription = { wikiText ->
                    if (!wikiText) return null
                    def textString = wikiText instanceof String ? wikiText : new String(wikiText, "UTF-8")
                    def lines = textString.split('\n')
                    for (def line : lines) {
                        if (line.trim() && !line.trim().startsWith('#')) {
                            return line.trim().take(200)
                        }
                    }
                    return null
                }

                def resolvedScreenDef = null
                if (currentPath == "root") {
                    // Discover top-level applications
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_XML_SCREEN")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                        
                    def rootScreens = new HashSet()
                    for (def aacv in aacvList) {
                        def name = aacv.artifactName
                        if (name.startsWith("component://") && name.endsWith(".xml")) {
                            def parts = name.substring(12).split('/')
                            if (parts.length >= 3 && parts[1] == "screen") {
                                def filename = parts[parts.length - 1]
                                def componentName = parts[0]
                                if (filename == componentName + ".xml" || filename == componentName + "Admin.xml" || filename == componentName + "Root.xml" || filename == "webroot.xml") {
                                    rootScreens.add(name)
                                }
                            }
                        }
                    }
                    
                    for (def screenPath in rootScreens) {
                        def simplePath = convertToSimplePath(screenPath)
                        def wikiContent = loadWikiContent(simplePath)
                        def description = wikiContent ? getShortDescription(wikiContent) : "Application: ${simplePath}"
                        subscreens << [
                            path: simplePath,
                            description: description
                        ]
                    }
                } else {
                    // Forward slash path resolution using Moqui standard with robust component-based fallback
                    def webrootSd = ec.screen.getScreenDefinition("component://webroot/screen/webroot.xml")
                    def pathSegments = []
                    currentPath.split('/').each { if (it && it.trim()) pathSegments.add(it) }
                    
                    // 1. Try literal resolution from webroot
                    def screenPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                        webrootSd, webrootSd, pathSegments, currentPath, [:], ec.screenFacade
                    )
                    
                    def currentSd = webrootSd
                    def reachedIndex = -1
                    if (screenPathList) {
                        for (int i = 0; i < screenPathList.size(); i++) {
                            def screenName = screenPathList[i]
                            def ssi = currentSd?.getSubscreensItem(screenName)
                            if (ssi && ssi.getLocation()) {
                                currentSd = ec.screen.getScreenDefinition(ssi.getLocation())
                                reachedIndex = i
                            } else {
                                break
                            }
                        }
                    }
                    
                    resolvedScreenDef = currentSd

                    // 2. If literal resolution failed, try Component-based resolution
                    if (reachedIndex == -1 && pathSegments.size() >= 2) {
                        def componentName = pathSegments[0]
                        def rootScreenName = pathSegments[1]
                        def compRootLoc = "component://${componentName}/screen/${rootScreenName}.xml"
                        
                        if (ec.resource.getLocationReference(compRootLoc).exists) {
                            ec.logger.info("BrowseScreens Path Resolution: Found component root at ${compRootLoc}")
                            resolvedScreenDef = ec.screen.getScreenDefinition(compRootLoc)
                            def subScreenPath = pathSegments.size() > 2 ? pathSegments[2..-1].join('/') : ""
                            
                            // Resolve further if there are remaining segments
                            if (subScreenPath) {
                                def remainingSegments = pathSegments[2..-1]
                                def compPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                                    resolvedScreenDef, resolvedScreenDef, remainingSegments, subScreenPath, [:], ec.screenFacade
                                )
                                if (compPathList) {
                                    for (String screenName in compPathList) {
                                        def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                        if (ssi && ssi.getLocation()) {
                                            resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                        } else {
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // 3. Fallback to double-slash search if still not found
                    if (reachedIndex == -1 && resolvedScreenDef == webrootSd && pathSegments.size() > 0 && !currentPath.startsWith("//")) {
                        def searchPath = "//" + pathSegments.join('/')
                        ec.logger.info("BrowseScreens Path Resolution: Fallback to search path ${searchPath}")
                        
                        def searchPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                            webrootSd, webrootSd, pathSegments, searchPath, [:], ec.screenFacade
                        )
                        
                        if (searchPathList) {
                            resolvedScreenDef = webrootSd
                            for (String screenName in searchPathList) {
                                def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                if (ssi && ssi.getLocation()) {
                                    resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                } else {
                                    break
                                }
                            }
                        }
                    }

                    if (resolvedScreenDef) {
                        resolvedScreenDef.getSubscreensItemsSorted().each { subItem ->
                            def subName = subItem.getName()
                            def subPath = currentPath + "/" + subName
                            def wikiContent = loadWikiContent(subPath)
                            subscreens << [
                                path: subPath,
                                description: wikiContent ? getShortDescription(wikiContent) : "Subscreen: ${subName}"
                            ]
                        }
                    }
                }
                
                // Process action before rendering
                // Action execution is now handled by ScreenAsMcpTool via framework's transition handling
                // Just log that we're passing the action through
                if (action) {
                    ec.logger.info("BrowseScreens: Passing action '${action}' to ScreenAsMcpTool for framework execution")
                }
                
                // Try to get wiki instructions for screen
                def wikiInstructions = null

                ec.logger.info("BrowseScreens: About to check wiki instructions, currentPath='${currentPath}', isRoot=${currentPath == 'root'}")

                wikiInstructions = loadWikiContent(currentPath)

                // Render current screen if not root browsing
                def renderedContent = null
                def renderError = null
                def actualRenderMode = renderMode ?: "compact"

                def resultMap = [
                    currentPath: currentPath,
                    subscreens: subscreens,
                    renderMode: actualRenderMode
                ]

                if (currentPath != "root") {
                    try {
                        ec.logger.info("BrowseScreens: Rendering screen ${currentPath} with mode=${actualRenderMode}")

                        // Pass forward-slash path directly to ScreenAsMcpTool
                        // ScreenAsMcpTool will use Moqui's ScreenUrlInfo.parseSubScreenPath to navigate through screen hierarchy
                        // Action is passed through for framework-based transition execution
                        def browseScreenCallParams = [
                            path: path,
                            parameters: parameters ?: [:],
                            action: action,  // Let ScreenAsMcpTool handle via framework
                            renderMode: actualRenderMode,
                            sessionId: sessionId
                        ]

                        // Call ScreenAsMcpTool to render
                        def browseResult = ec.service.sync().name("McpServices.execute#ScreenAsMcpTool")
                            .parameters(browseScreenCallParams)
                            .call()

                        // Extract rendered content and semantic state from result
                        if (browseResult) {
                            def resultObj = null
                            // ScreenAsMcpTool returns {result: {content: [...]}}
                            if (browseResult.result) {
                                def contentList = browseResult.result.content
                                if (contentList && contentList.size() > 0) {
                                    def rawText = contentList[0].text
                                    if (rawText && rawText.startsWith("{")) {
                                        try { resultObj = new groovy.json.JsonSlurper().parseText(rawText) } catch(e) {}
                                    }
                                    renderedContent = rawText
                                }
                            }

                            // Handle compact mode - pass through compact data directly
                            if ((actualRenderMode == "compact" || actualRenderMode == null) && resultObj && resultObj.screen) {
                                // Compact mode returns flat structure, merge it into resultMap
                                resultObj.each { k, v -> if (k != "screen") resultMap[k] = v }
                                resultMap.screen = resultObj.screen
                                ec.logger.info("BrowseScreens: Compact mode - passing through for ${currentPath}")
                            // Handle ARIA mode - pass through the aria tree directly
                            } else if (actualRenderMode == "aria" && resultObj && resultObj.aria) {
                                resultMap.aria = resultObj.aria
                                if (resultObj.summary) resultMap.summary = resultObj.summary
                                ec.logger.info("BrowseScreens: ARIA mode - passing through aria tree for ${currentPath}")
                            } else if (resultObj && resultObj.semanticState) {
                                resultMap.semanticState = resultObj.semanticState

                                // Build UI narrative for LLM guidance
                                try {
                                    def narrativeBuilder = new org.moqui.mcp.UiNarrativeBuilder()
                                    // Use the screen definition we already resolved
                                    def screenDefForNarrative = resolvedScreenDef

                                    def uiNarrative = narrativeBuilder.buildNarrative(
                                        screenDefForNarrative,
                                        resultObj.semanticState,
                                        currentPath
                                    )
                                    resultMap.uiNarrative = uiNarrative
                                    ec.logger.info("BrowseScreens: Generated UI narrative for ${currentPath}: ${uiNarrative?.keySet()}")
                                } catch (Exception e) {
                                    ec.logger.warn("BrowseScreens: Failed to generate UI narrative: ${e.message}")
                                }
                            }
                        }

                        ec.logger.info("BrowseScreens: Successfully rendered screen ${currentPath}, content length: ${renderedContent?.length() ?: 0}")
                    } catch (Exception e) {
                        renderError = "Screen rendering failed: ${e.message}"
                        ec.logger.warn("BrowseScreens render error for ${currentPath}: ${e.message}")
                    }
                }
                
                if (actionResult) {
                    resultMap.actionResult = actionResult
                }

                // Don't include renderedContent for renderMode "mcp", "aria", or "compact" - structured data is provided instead
                // Including both duplicates data and truncation breaks JSON structure
                if (renderedContent && actualRenderMode != "mcp" && actualRenderMode != "aria" && actualRenderMode != "compact") {
                    resultMap.renderedContent = renderedContent
                }
                
                if (actionError) {
                    resultMap.actionError = actionError
                }

                if (wikiInstructions) {
                    resultMap.wikiInstructions = wikiInstructions
                    // Extract first non-header paragraph as summary
                    def summary = getShortDescription(wikiInstructions)
                    if (summary) {
                        resultMap.summary = summary
                    }
                }

                if (renderError) {
                    resultMap.renderError = renderError
                }
                
                // Return in MCP format - content array as direct child of result
                result = [
                    content: [[type: "text", text: new groovy.json.JsonBuilder(resultMap).toString()]],
                    isError: false
                ]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="SearchScreens" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Search for screens by name or path.</description>
        <in-parameters>
            <parameter name="query" required="true"/>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def matches = []
                
                // Helper to convert full component path to simple forward-slash path
                def convertToSimplePath = { fullPath ->
                    if (!fullPath) return null
                    String cleanPath = fullPath
                    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
                    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
                    List<String> parts = cleanPath.split('/').toList()
                    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
                    return parts.join('/')
                }

                // Search all screens known to the system
                def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                    .condition("artifactTypeEnumId", "AT_XML_SCREEN")
                    .condition("artifactName", "like", "%${query}%")
                    .selectField("artifactName")
                    .distinct(true)
                    .disableAuthz()
                    .limit(20)
                    .list()
                
                for (hit in aacvList) {
                    def simplePath = convertToSimplePath(hit.artifactName)
                    if (simplePath) {
                        matches << [
                            path: simplePath,
                            description: "Screen: ${hit.artifactName}"
                        ]
                    }
                }
                
                result = [matches: matches]
            ]]></script>
        </actions>
    </service>

    <service verb="list" noun="Tools" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>List discovery tools and the unified screen renderer.</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                def tools = [
                    [
                        name: "moqui_browse_screens",
                        title: "Browse Screens",
                        description: "Browse Moqui screen hierarchy, process actions, and render screen content. Input 'path' (empty for root). Default renderMode is 'mcp'.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "path": [type: "string", description: "Path to browse (e.g. 'PopCommerce')"],
                                "action": [type: "string", description: "Action to process before rendering: null (browse), 'submit' (form), 'create', 'update', or transition name"],
                                "renderMode": [type: "string", description: "Render mode: compact (default, actionable summary), aria (accessibility tree), mcp (full metadata), text, html, xml, vuet, qvt"],
                                "parameters": [type: "object", description: "Parameters to pass to screen during rendering or action"]
                            ]
                        ]
                    ],
                    [
                        name: "moqui_search_screens",
                        title: "Search Screens",
                        description: "Search for screens by name to find their paths.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "query": [type: "string", description: "Search query"]
                            ],
                            required: ["query"]
                        ]
                     ],
                     [
                        name: "moqui_get_screen_details",
                        title: "Get Screen Details",
                        description: "Get screen field details including dropdown options. Use this to understand available fields and their options before submitting forms.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "path": [type: "string", description: "Screen path to analyze (e.g., 'PopCommerce/PopCommerceAdmin/Party/FindParty')"],
                                "fieldName": [type: "string", description: "Optional specific field name. If not provided, returns all fields."],
                                "parameters": [type: "object", description: "Optional parameters to set in context before rendering (for autocomplete contexts)."]
                            ],
                            required: ["path"]
                        ]
                     ],
                      [
                        name: "prompts_list",
                        title: "List Prompts",
                        description: "List available MCP prompt templates.",
                        inputSchema: [
                            type: "object",
                            properties: [:]
                        ]
                    ],
                    [
                        name: "prompts_get",
                        title: "Get Prompt",
                        description: "Retrieve and render a specific MCP prompt template.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "name": [type: "string", description: "Prompt name"],
                                "arguments": [type: "object", description: "Arguments for prompt template"]
                            ],
                            required: ["name"]
                        ]
                    ]
                ]
                
                result = [tools: tools]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="GetScreenDetails" authenticate="true" allow-remote="true" transaction-timeout="60">
        <description>Get screen field details including dropdown options. Use this to understand available fields and their options before submitting forms.</description>
        <in-parameters>
            <parameter name="path" required="true"><description>Screen path to analyze (e.g., '/PopCommerce/PopCommerceAdmin/Party/FindParty').</description></parameter>
            <parameter name="fieldName"><description>Optional specific field name. If not provided, returns all fields.</description></parameter>
            <parameter name="parameters" type="Map"><description>Optional parameters to set in context before rendering (for autocomplete contexts).</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                import org.moqui.mcp.McpFieldOptionsService
                
                ExecutionContext ec = context.ec
                
                def serviceResult = McpFieldOptionsService.service(path, fieldName, parameters, ec)
                
                // Return in standard MCP format with content array
                def resultJson = new JsonBuilder(serviceResult).toString()
                result = [
                    content: [[type: "text", text: resultJson]],
                    isError: false
                ]
            ]]></script>
        </actions>
    </service>

    <!-- NOTE: handle#McpRequest service removed - functionality moved to screen/webapp.xml for unified handling -->

</services>