<?xml version="1.0" encoding="UTF-8"?>
<!-- This software is in the public domain under CC0 1.0 Universal plus a 
     Grant of Patent License.

     To the extent possible under law, the author(s) have dedicated all
     copyright and related and neighboring rights to this software to the
     public domain worldwide. This software is distributed without any warranty.

     You should have received a copy of the CC0 Public Domain Dedication
     along with this software (see the LICENSE.md file). If not, see
     <https://creativecommons.org/publicdomain/zero/1.0/>. -->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- MCP Services using Moqui's built-in JSON-RPC support -->
    
    
    <service verb="mcp" noun="Initialize" authenticate="true" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP initialize request using Moqui authentication</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="protocolVersion" required="true"/>
            <parameter name="capabilities" type="Map"/>
            <parameter name="clientInfo" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Permissions are handled by Moqui's artifact authorization system
                // Users must be in appropriate groups (McpUser, MCP_BUSINESS) with access to McpServices artifact group
                
                // Get Visit (session) created by servlet and validate access
                def visit = ec.entity.find("moqui.server.Visit")
                    .condition("visitId", sessionId)
                    .disableAuthz()
                    .one()
                
                if (!visit) {
                    throw new Exception("Invalid session: ${sessionId}")
                }
                
                if (visit.userId != ec.user.userId) {
                    throw new Exception("Access denied for session: ${sessionId}")
                }
                
                // Update Visit with MCP initialization data
                UserInfo adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def metadata = [:]
                    try {
                        metadata = groovy.json.JsonSlurper().parseText(visit.initialRequest ?: "{}") as Map
                    } catch (Exception e) {
                        ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                    }
                    
                    metadata.mcpInitialized = true
                    metadata.mcpProtocolVersion = protocolVersion
                    metadata.mcpCapabilities = capabilities
                    metadata.mcpClientInfo = clientInfo
                    metadata.mcpInitializedAt = System.currentTimeMillis()
                    
                    visit.initialRequest = groovy.json.JsonOutput.toJson(metadata)
                    ec.artifactExecution.disableAuthz()
                    ec.logger.info("SESSIONID: ${sessionId}")
                    sessionId ? visit.update() : visit.store()
                    ec.artifactExecution.enableAuthz()
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Validate protocol version - support common MCP versions
                def supportedVersions = ["2025-06-18", "2024-11-05", "2024-10-07", "2023-06-05"]
                if (!supportedVersions.contains(protocolVersion)) {
                    throw new Exception("Unsupported protocol version: ${protocolVersion}. Supported versions: ${supportedVersions.join(', ')}")
                }
                
                // Get current user context (if authenticated)
                def userId = ec.user.userId
                def userAccountId = userId ? userId : null
                
                // Get user-specific tools and resources in SAME transaction context
                def toolsResult = ec.service.sync().name("McpServices.mcp#ToolsList")
                    .parameters([sessionId: visit.visitId])
                    .requireNewTransaction(false)  // Use current transaction
                    .call()
                def resourcesResult = ec.service.sync().name("McpServices.mcp#ResourcesList")
                    .parameters([sessionId: visit.visitId])
                    .requireNewTransaction(false)  // Use current transaction
                    .call()
                
                // Build server capabilities based on what user can access
                def serverCapabilities = [
                    tools: toolsResult?.result?.tools ? [listChanged: true] : [:],
                    resources: resourcesResult?.result?.resources ? [subscribe: true, listChanged: true] : [:],
                    logging: [:]
                ]
                
                // Build server info
                def serverInfo = [
                    name: "Moqui MCP Server",
                    version: "2.0.1"
                ]
                
                result = [
                    protocolVersion: "2025-06-18",
                    capabilities: serverCapabilities,
                    serverInfo: serverInfo,
                    instructions: "This server provides access to Moqui ERP services and entities through MCP. Tools and resources are filtered based on your permissions.",
                    sessionId: visit.visitId
                ]
                
                ec.logger.info("MCP Initialize for user ${userId} (session ${sessionId}): ${toolsResult?.result?.tools?.size() ?: 0} tools, ${resourcesResult?.result?.resources?.size() ?: 0} resources")
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ToolsList" authenticate="true" allow-remote="true" transaction-timeout="60">
        <description>Handle MCP tools/list request with admin discovery but user permission filtering</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import java.util.UUID
                
                ExecutionContext ec = context.ec
                
                // Permissions are handled by Moqui's artifact authorization system
                // Users must be in appropriate groups (McpUser, MCP_BUSINESS) with access to McpServices artifact group
                
                // Validate session if provided
                /*
                if (sessionId) {
                    def visit = ec.entity.find("moqui.server.Visit")
                        .condition("visitId", sessionId)
                        .disableAuthz()
                        .one()
                    
                    if (!visit || visit.userId != ec.user.userId) {
                        //throw new Exception("Invalid session: ${sessionId}")
                    }
                }
                
                // Update session activity
                if (sessionId) {
                    def visitObj = ec.entity.find("moqui.server.Visit")
                        .condition("visitId", sessionId)
                        .disableAuthz()
                        .one()
                    
                    if (visitObj) {
                        def metadata = [:]
                        try {
                            metadata = groovy.json.JsonSlurper().parseText(visitObj.initialRequest ?: "{}") as Map
                        } catch (Exception e) {
                            ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                        }
                        
                        metadata.mcpLastActivity = System.currentTimeMillis()
                        metadata.mcpLastOperation = "tools/list"
                        
                        // Update Visit - need admin context for Visit updates
                        adminUserInfo = null
                        try {
                            adminUserInfo = ec.user.pushUser("ADMIN")
                            visitObj.initialRequest = groovy.json.JsonOutput.toJson(metadata)
                            ec.artifactExecution.disableAuthz()
                            visitObj.update()
                            ec.artifactExecution.enableAuthz()
                        } finally {
                            if (adminUserInfo != null) {
                                ec.user.popUser()
                            }
                        }
                    }
                }
                */
                
                // Store original user context before switching to ADMIN
                def originalUsername = ec.user.username
                def originalUserId = ec.user.userId
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                
                // Get user's accessible services using Moqui's optimized ArtifactAuthzCheckView
                def userAccessibleServices = null as Set<String>
                adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_SERVICE")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                    userAccessibleServices = aacvList.collect { it.artifactName } as Set<String>
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Helper function to check if user has permission to a service
                def userHasPermission = { serviceName ->
                    // Use pre-computed accessible services set for O(1) lookup
                    return userAccessibleServices != null && userAccessibleServices.contains(serviceName.toString())
                }
                
                // Switch to admin context for service discovery (to access all service definitions)
                adminUserInfo = ec.user.pushUser("ADMIN")
                
                try {
                    def availableTools = []
                    
                    // Get only services user has access to via artifact groups
                    def accessibleServiceNames = []
                    for (serviceName in userAccessibleServices) {
                        // Handle wildcard patterns like "McpServices.*"
                        if (serviceName.contains("*")) {
                            def pattern = serviceName.replace("*", ".*")
                            def allServiceNames = ec.service.getKnownServiceNames()
                            def matchingServices = allServiceNames.findAll { it.matches(pattern) }
                            // Only add services that actually exist
                            accessibleServiceNames.addAll(matchingServices.findAll { ec.service.isServiceDefined(it) })
                        } else {
                            // Only add if service actually exists
                            if (ec.service.isServiceDefined(serviceName)) {
                                accessibleServiceNames << serviceName
                            }
                        }
                    }
                    accessibleServiceNames = accessibleServiceNames.unique()
                    
                    ec.logger.info("MCP ToolsList: Found ${accessibleServiceNames.size()} accessible services for user ${originalUsername} (${originalUserId})${sessionId ? ' (session: ' + sessionId + ')' : ''}")
                    
                    // Helper function to convert service to MCP tool
                    def convertServiceToTool = { serviceName ->
                        try {
                            def serviceDefinition = ec.service.getServiceDefinition(serviceName)
                            if (!serviceDefinition) return null
                            
                            def serviceNode = serviceDefinition.serviceNode
                            
                            // Convert service to MCP tool format
                            def tool = [
                                name: serviceName,
                                title: serviceNode.first("description")?.text ?: serviceName,
                                description: serviceNode.first("description")?.text ?: "Moqui service: ${serviceName}",
                                inputSchema: [
                                    type: "object",
                                    properties: [:],
                                    required: []
                                ]
                            ]
                            
                            // Add service metadata to help LLM
                            if (serviceDefinition.verb && serviceDefinition.noun) {
                                tool.description += " (${serviceDefinition.verb}:${serviceDefinition.noun})"
                            }
                            
                            // Convert service parameters to JSON Schema
                            def inParamNames = serviceDefinition.getInParameterNames()
                            for (paramName in inParamNames) {
                                def paramNode = serviceDefinition.getInParameter(paramName)
                                def paramDesc = paramNode.first("description")?.text ?: ""
                                
                                // Add type information to description for LLM
                                def paramType = paramNode?.attribute('type') ?: 'String'
                                if (!paramDesc) {
                                    paramDesc = "Parameter of type ${paramType}"
                                } else {
                                    paramDesc += " (type: ${paramType})"
                                }
                                
                                // Convert Moqui type to JSON Schema type
                                def typeMap = [
                                    "text-short": "string",
                                    "text-medium": "string", 
                                    "text-long": "string",
                                    "text-very-long": "string",
                                    "id": "string",
                                    "id-long": "string",
                                    "number-integer": "integer",
                                    "number-decimal": "number",
                                    "number-float": "number",
                                    "date": "string",
                                    "date-time": "string",
                                    "date-time-nano": "string",
                                    "boolean": "boolean",
                                    "text-indicator": "boolean"
                                ]
                                def jsonSchemaType = typeMap[paramType] ?: "string"
                                
                                tool.inputSchema.properties[paramName] = [
                                    type: jsonSchemaType,
                                    description: paramDesc
                                ]
                                
                                if (paramNode?.attribute('required') == "true") {
                                    tool.inputSchema.required << paramName
                                }
                            }
                            
                            return tool
                        } catch (Exception e) {
                            ec.logger.warn("Error converting service ${serviceName} to tool: ${e.message}")
                            return null
                        }
                    }
                    
                    // Add all accessible services as tools
                    for (serviceName in accessibleServiceNames) {
                        def tool = convertServiceToTool(serviceName)
                        if (tool) {
                            availableTools << tool
                        }
                    }
                    
                // Implement pagination according to MCP spec
                def pageSize = 50  // Reasonable page size for tool lists
                def startIndex = 0
                
                if (cursor) {
                    try {
                        // Parse cursor to get start index (simple approach: cursor is the start index)
                        startIndex = Integer.parseInt(cursor)
                    } catch (Exception e) {
                        ec.logger.warn("Invalid cursor format: ${cursor}, starting from beginning")
                        startIndex = 0
                    }
                }
                
                // Get paginated subset of tools
                def endIndex = Math.min(startIndex + pageSize, availableTools.size())
                def paginatedTools = availableTools.subList(startIndex, endIndex)
                
                result = [tools: paginatedTools]
                
                // Add nextCursor if there are more tools
                if (endIndex < availableTools.size()) {
                    result.nextCursor = String.valueOf(endIndex)
                }
                    
                    ec.logger.info("MCP ToolsList: Returning ${availableTools.size()} tools for user ${originalUsername}")
                    
                } finally {
                    // Always restore original user context
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ToolsCall" authenticate="true" allow-remote="true" transaction-timeout="300">
        <description>Handle MCP tools/call request with direct Moqui service execution</description>
        <in-parameters>
            <parameter name="name" required="true"/>
            <parameter name="arguments" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                // Validate service exists
                if (!ec.service.isServiceDefined(name)) {
                    throw new Exception("Tool not found: ${name}")
                }
                
                // Capture original user for permission context
                def originalUsername = ec.user.username
                UserInfo adminUserInfo = null
                
                // Validate session if provided
                /*
                if (sessionId) {
                    def visit = null
                    adminUserInfo = null
                    try {
                        adminUserInfo = ec.user.pushUser("ADMIN")
                        visit = ec.entity.find("moqui.server.Visit")
                            .condition("visitId", sessionId)
                            .one()
                    } finally {
                        if (adminUserInfo != null) {
                                ec.user.popUser()
                            }
                    }
                    
                    // Validate session - allow special MCP case where Visit was created with ADMIN but accessed by MCP_USER or MCP_BUSINESS
                    boolean sessionValid = false
                    if (visit) {
                        if (visit.userId == ec.user.userId) {
                            sessionValid = true
                        } else if (visit.userId == "ADMIN" && (ec.user.username == "mcp-user" || ec.user.username == "mcp-business")) {
                            // Special MCP case: Visit created with ADMIN for privileged access but accessed by MCP users
                            sessionValid = true
                        }
                    }
                    
                    if (!sessionValid) {
                        //throw new Exception("Invalid session: ${sessionId}")
                    }
                }
                */
                
                def startTime = System.currentTimeMillis()
                try {
                    // Execute service with elevated privileges for system access
                    // but maintain audit context with actual user
                    def serviceResult
                    adminUserInfo = null
                    try {
                        serviceResult = ec.service.sync().name(name).parameters(arguments ?: [:]).call()
                    } finally {
                        if (adminUserInfo != null) {
                                ec.user.popUser()
                            }
                    }
                    def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                    
                    // Convert result to MCP format
                    def content = []
                    if (serviceResult) {
                        content << [
                            type: "text",
                            text: new JsonBuilder(serviceResult).toString()
                        ]
                    }
                    
                    result.result = [
                        content: content,
                        isError: false
                    ]
                } catch (Exception e) {
                    def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                    
                    result = [
                        content: [
                            [
                                type: "text",
                                text: "Error executing tool ${name}: ${e.message}"
                            ]
                        ],
                        isError: true
                    ]
                    
                    ec.logger.error("MCP tool execution error", e)
                } finally {
                    // Always restore original user context
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesList" authenticate="true" allow-remote="true" transaction-timeout="60">
        <description>Handle MCP resources/list request with Moqui entity discovery</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Build list of available entities as resources
                def resources = []
                
                UserInfo adminUserInfo = null
                
                // Update session activity
                def metadata = [:]
                try {
                   metadata = groovy.json.JsonSlurper().parseText(visit.initialRequest ?: "{}") as Map
                } catch (Exception e) {
                   ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                }
                    
                // Store original user context before switching to ADMIN
                def originalUsername = ec.user.username
                def originalUserId = ec.user.userId
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                
                // Use curated list of commonly used entities instead of discovering all entities
                def availableResources = []
                
                ec.logger.info("MCP ResourcesList: Starting permissions-based entity discovery")
                
                // Get user's accessible entities using Moqui's optimized ArtifactAuthzCheckView
                def userAccessibleEntities = null as Set<String>
                adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_ENTITY")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                    userAccessibleEntities = aacvList.collect { it.artifactName } as Set<String>
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Helper function to check if user has permission to an entity
                def userHasEntityPermission = { entityName ->
                    // Use pre-computed accessible entities set for O(1) lookup
                    return userAccessibleEntities != null && userAccessibleEntities.contains(entityName.toString())
                }
                
                // Add all permitted entities including ViewEntities for LLM convenience
                def allEntityNames = ec.entity.getAllEntityNames()
                def allViewNames = [] as Set<String>
                
                // Get ViewEntities by checking entity definitions for view entities
                def entityInfoList = ec.entity.getAllEntityInfo(0, true) // includeViewEntities=true
                for (entityInfo in entityInfoList) {
                    if (entityInfo.isViewEntity) {
                        allViewNames.add(entityInfo.entityName)
                    }
                }
                
                // Combine real entities and ViewEntities
                def allAccessibleEntities = allEntityNames + allViewNames
                
                for (entityName in allAccessibleEntities) {
                    if (userHasEntityPermission(entityName)) {
                        def description = "Moqui entity: ${entityName}"
                        if (entityName.contains("View")) {
                            description = "Moqui ViewEntity: ${entityName} (pre-joined data for LLM convenience)"
                        }
                        
                        ec.logger.info("MCP ResourcesList: Adding entity: ${entityName}")
                        availableResources << [
                            uri: "entity://${entityName}",
                            name: entityName,
                            description: description,
                            mimeType: "application/json"
                        ]
                    }
                }
                
                result = [resources: availableResources]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesRead" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Handle MCP resources/read request with Moqui entity queries</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                // Parse entity URI (format: entity://EntityName)
                if (!uri.startsWith("entity://")) {
                    throw new Exception("Invalid resource URI: ${uri}")
                }
                
                def entityName = uri.substring(9) // Remove "entity://" prefix
                
                // Validate entity exists
                if (!ec.entity.isEntityDefined(entityName)) {
                    throw new Exception("Entity not found: ${entityName}")
                }
                
                // Permission checking is handled by Moqui's artifact authorization system through artifact groups
                
                 def startTime = System.currentTimeMillis()
                 try {
                 // Try to get entity definition - handle both real entities and view entities
                      def entityDef = null
                      try {
                          // First try getAllEntityInfo for detailed info
                          def entityInfoList = ec.entity.getAllEntityInfo(-1, true) // all entities, include view entities
                          entityDef = entityInfoList.find { it.entityName == entityName }
                          
                          if (!entityDef) {
                              // If not found in detailed list, try basic entity check
                              if (ec.entity.isEntityDefined(entityName)) {
                                  // Create minimal entity definition for basic query
                                  entityDef = [
                                      entityName: entityName,
                                      packageName: entityName.split('\\.')[0],
                                      description: "Entity: ${entityName}",
                                      isViewEntity: entityName.contains('View'),
                                      allFieldInfoList: []
                                  ]
                              }
                          }
                      } catch (Exception e) {
                          ec.logger.warn("ResourcesRead: Error getting entity info for ${entityName}: ${e.message}")
                          // Fallback: try basic entity check
                          if (ec.entity.isEntityDefined(entityName)) {
                              entityDef = [
                                  entityName: entityName,
                                  packageName: entityName.split('\\.')[0],
                                  description: "Entity: ${entityName}",
                                  isViewEntity: entityName.contains('View'),
                                  allFieldInfoList: []
                              ]
                          }
                      }
                      
                      if (!entityDef) {
                          throw new Exception("Entity not found: ${entityName}")
                      }
                      
                      ec.logger.info("ResourcesRead: Found entity ${entityName}, isViewEntity=${entityDef.isViewEntity}")
                     
                     // Query entity data (limited to prevent large responses)
                     def entityList = ec.entity.find(entityName)
                         .limit(100)
                         .list()
                     
                     def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                     
                     // Build field info for LLM
                     def fieldInfo = []
                     entityDef.allFieldInfoList.each { field ->
                         fieldInfo << [
                             name: field.name,
                             type: field.type,
                             description: field.description ?: "",
                             isPk: field.isPk,
                             required: field.notNull
                         ]
                     }
                     
                     // Convert to MCP resource content
                     def contents = [
                         [
                             uri: uri,
                             mimeType: "application/json",
                             text: new JsonBuilder([
                                 entityName: entityName,
                                 description: entityDef.description ?: "",
                                 packageName: entityDef.packageName,
                                 recordCount: entityList.size(),
                                 fields: fieldInfo,
                                 data: entityList
                             ]).toString()
                         ]
                     ]
                     
                     result = [contents: contents]
                     
                 } catch (Exception e) {
                      def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
                      ec.logger.warn("Error reading resource ${uri}: ${e.message}")
                      result = [error: "Error reading resource ${uri}: ${e.message}"]
                  }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="Ping" authenticate="true" allow-remote="true" transaction-timeout="10">
        <description>Handle MCP ping request for health check</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
          <script><![CDATA[
                result = [
                    timestamp: ec.user.getNowTimestamp(),
                    status: "healthy",
                    version: "2.0.2",
                    sessionId: sessionId,
                    architecture: "Visit-based sessions"
                ]
            ]]></script>
        </actions>
    </service>

    <!-- Debug Service -->
    
    <service verb="debug" noun="ComponentStatus" authenticate="false" allow-remote="true">
        <description>Debug service to verify component is loaded and working</description>
        <in-parameters/>
        <out-parameters>
            <parameter name="status" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                def status = [
                    componentLoaded: true,
                    componentName: "mo-mcp",
                    timestamp: ec.user.getNowTimestamp(),
                    user: ec.user.username,
                    userId: ec.user.userId,
                    serviceNames: ec.service.getKnownServiceNames().findAll { it.contains("Mcp") },
                    entityNames: ec.entity.getAllEntityNames().findAll { it.contains("ArtifactHit") }
                ]
                
                ec.logger.info("=== MCP COMPONENT DEBUG ===")
                ec.logger.info("Component status: ${status}")
                ec.logger.info("All service names count: ${ec.service.getKnownServiceNames().size()}")
                ec.logger.info("All entity names count: ${ec.entity.getAllEntityNames().size()}")
                ec.logger.info("=== END MCP COMPONENT DEBUG ===")
                
                result.status = status
            ]]></script>
        </actions>
    </service>

    <!-- Helper Functions -->
    
    <service verb="validate" noun="Origin" authenticate="false" allow-remote="false">
        <description>Validate Origin header for DNS rebinding protection</description>
        <in-parameters>
            <parameter name="origin" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="isValid" type="boolean"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Allow localhost origins
                if (origin?.startsWith("http://localhost:") || origin?.startsWith("https://localhost:")) {
                    isValid = true
                    return
                }
                
                // Allow 127.0.0.1 origins
                if (origin?.startsWith("http://127.0.0.1:") || origin?.startsWith("https://127.0.0.1:")) {
                    isValid = true
                    return
                }
                
                // Allow same-origin requests (check against current host)
                def currentHost = ec.web?.request?.getServerName()
                def currentScheme = ec.web?.request?.getScheme()
                def currentPort = ec.web?.request?.getServerPort()
                
                def expectedOrigin = "${currentScheme}://${currentHost}"
                if ((currentScheme == "http" && currentPort != 80) || (currentScheme == "https" && currentPort != 443)) {
                    expectedOrigin += ":${currentPort}"
                }
                
                if (origin == expectedOrigin) {
                    isValid = true
                    return
                }
                
                // Check for configured allowed origins (could be from system properties)
                def allowedOrigins = ec.getFactory().getConfiguration().getStringList("moqui.mcp.allowed_origins", [])
                if (allowedOrigins.contains(origin)) {
                    isValid = true
                    return
                }
                
                isValid = false
            ]]></script>
        </actions>
    </service>
    
    <service verb="convert" noun="MoquiTypeToJsonSchemaType" authenticate="false">
        <description>Convert Moqui data types to JSON Schema types</description>
        <in-parameters>
            <parameter name="moquiType" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="jsonSchemaType"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                // Simple type mapping - can be expanded as needed
                def typeMap = [
                    "text-short": "string",
                    "text-medium": "string", 
                    "text-long": "string",
                    "text-very-long": "string",
                    "id": "string",
                    "id-long": "string",
                    "number-integer": "integer",
                    "number-decimal": "number",
                    "number-float": "number",
                    "date": "string",
                    "date-time": "string",
                    "date-time-nano": "string",
                    "boolean": "boolean",
                    "text-indicator": "boolean"
                ]
                
                jsonSchemaType = typeMap[moquiType] ?: "string"
            ]]></script>
        </actions>
    </service>



    <service verb="list" noun="Products" authenticate="true" allow-remote="true" transaction-timeout="30">
        <description>List products with basic information for MCP business toolkit</description>
        <in-parameters>
            <parameter name="productCategoryId" required="false"/>
            <parameter name="ownerPartyId" required="false"/>
            <parameter name="pageSize" type="Integer" default="20"/>
            <parameter name="pageIndex" type="Integer" default="0"/>
        </in-parameters>
        <out-parameters>
            <parameter name="products" type="List"/>
            <parameter name="totalCount" type="Integer"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                def entityFind = ec.entity.find("mantle.product.Product")
                
                // Apply filters if provided
                if (productCategoryId) {
                    entityFind.condition("productCategoryId", productCategoryId)
                }
                if (ownerPartyId) {
                    entityFind.condition("ownerPartyId", ownerPartyId)
                }
                
                // Get total count
                totalCount = entityFind.count()
                
                // Apply pagination
                entityFind.orderBy("productName").limit(pageSize).offset(pageIndex * pageSize)
                
                // Get product list with basic fields
                products = entityFind.selectFields(["productId", "productName", "description", "productTypeId", 
                                                   "productCategoryId", "ownerPartyId", "internalName"]).list()
                
            ]]></script>
        </actions>
    </service>

    <!-- NOTE: handle#McpRequest service removed - functionality moved to screen/webapp.xml for unified handling -->

</services>