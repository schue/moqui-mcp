<?xml version="1.0" encoding="UTF-8"?>
<!-- This software is in the public domain under CC0 1.0 Universal plus a 
     Grant of Patent License.

     To the extent possible under law, the author(s) have dedicated all
     copyright and related and neighboring rights to this software to the
     public domain worldwide. This software is distributed without any warranty.

     You should have received a copy of the CC0 Public Domain Dedication
     along with this software (see the LICENSE.md file). If not, see
     <https://creativecommons.org/publicdomain/zero/1.0/>. -->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- MCP Services using Moqui's built-in JSON-RPC support -->
    
    
    <service verb="mcp" noun="Initialize" authenticate="true" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP initialize request using Moqui authentication</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="protocolVersion" required="true"/>
            <parameter name="capabilities" type="Map"/>
            <parameter name="clientInfo" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                // Permissions are handled by Moqui's artifact authorization system
                // Users must be in appropriate groups (McpUser, MCP_BUSINESS) with access to McpServices artifact group
                
                // Disable authz to prevent automatic Visit updates during MCP operations
                ec.artifactExecution.disableAuthz()
                
                // Get Visit (session) created by servlet and validate access
                def visit = ec.entity.find("moqui.server.Visit")
                    .condition("visitId", sessionId)
                    .one()
                
                if (!visit) {
                    throw new Exception("Invalid session: ${sessionId}")
                }
                
                if (visit.userId != ec.user.userId) {
                    throw new Exception("Access denied for session: ${sessionId}")
                }
                
                // Update Visit with MCP initialization data
                UserInfo adminUserInfo = null
                try {
                    adminUserInfo = ec.user.pushUser("ADMIN")
                    def metadata = [:]
                    try {
                        metadata = groovy.json.JsonSlurper().parseText(visit.initialRequest ?: "{}") as Map
                    } catch (Exception e) {
                        ec.logger.debug("Failed to parse Visit metadata: ${e.message}")
                    }
                    
                    metadata.mcpInitialized = true
                    metadata.mcpProtocolVersion = protocolVersion
                    metadata.mcpCapabilities = capabilities
                    metadata.mcpClientInfo = clientInfo
                    metadata.mcpInitializedAt = System.currentTimeMillis()
                    
                    // Session metadata stored in memory only - no Visit updates to prevent lock contention
                    ec.logger.info("SESSIONID: ${sessionId} - metadata stored in memory")
                } finally {
                    if (adminUserInfo != null) {
                        ec.user.popUser()
                    }
                }
                
                // Validate protocol version - support common MCP versions with version negotiation
                def supportedVersions = ["2025-11-25", "2025-06-18", "2024-11-05", "2024-10-07", "2023-06-05"]
                if (!supportedVersions.contains(protocolVersion)) {
                    throw new Exception("Unsupported protocol version: ${protocolVersion}. Supported versions: ${supportedVersions.join(', ')}")
                }

                // Get current user context (if authenticated)
                def userId = ec.user.userId
                def userAccountId = userId ? userId : null

                // Try to load root instructions from wiki
                def instructions = null
                try {
                    def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                        .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                        .condition("pagePath", "root")
                        .useCache(true)
                        .one()

                    if (wikiPage) {
                        def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                            .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                            .one()

                        if (wikiSpace) {
                            def pageLocation = wikiSpace.rootPageLocation
                            if (!pageLocation.endsWith('/')) pageLocation += '/'
                            pageLocation += wikiPage.pagePath + '.md'

                            def pageRef = ec.resource.getLocationReference(pageLocation)
                            def wikiText = pageRef?.getText()
                            if (wikiText) {
                                instructions = wikiText
                                ec.logger.info("MCP Initialize: Loaded root instructions from wiki")
                            }
                        }
                    }
                } catch (Exception e) {
                    ec.logger.debug("Could not load root instructions from wiki: ${e.message}")
                }

                // Fallback to hardcoded instructions if wiki not available
                if (!instructions) {
                    instructions = "This server provides access to Moqui ERP through MCP. Use moqui_browse_screens(path='/PopCommerce') to begin. Key screens include: /PopCommerce/Catalog/Product/FindProduct for products, /PopCommerce/Order/FindOrder for orders, and /PopCommerce/Customer for customer management. All screens support parameterized queries for filtering results."
                }
                
                // Build server capabilities - don't fetch actual tools/resources during init
                // Tools and resources will be discovered via separate list requests per MCP spec
                def serverCapabilities = [
                    tools: [listChanged: true],
                    resources: [subscribe: true, listChanged: true],
                    logging: [:]
                ]
                
                // Build server info
                def serverInfo = [
                    name: "Moqui MCP Server",
                    version: "2.0.1"
                ]
                
                result = [
                    protocolVersion: "2025-06-18",
                    capabilities: serverCapabilities,
                    serverInfo: serverInfo,
                    sessionId: sessionId,
                    instructions: instructions
                ]
                
                ec.logger.info("MCP Initialize for user ${userId} (session ${sessionId}): capabilities negotiated")
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ToolsCall" authenticate="true" allow-remote="true" transaction-timeout="300">
        <description>Handle MCP tools/call request with direct Moqui service execution</description>
        <in-parameters>
            <parameter name="sessionId" required="false"/>
            <parameter name="name" required="true"/>
            <parameter name="arguments" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                // Start timing for execution metrics
                def startTime = System.currentTimeMillis()
                def isError = false
                
                try {
                    // Consolidated Tool Dispatching

                    ec.logger.info("MCP ToolsCall: Dispatching tool name=${name}, arguments=${arguments}")
                    ec.logger.info("MCP ToolsCall: CODE VERSION: 2025-01-09 - FIXED NULL CHECK")

                    if (name == "moqui_render_screen" || name == "moqui_browse_screens") {
                        def targetServiceName = name == "moqui_browse_screens" ? "McpServices.mcp#BrowseScreens" : "McpServices.execute#ScreenAsMcpTool"
                        def serviceResult = ec.service.sync().name(targetServiceName).parameters(arguments ?: [:]).call()
                        
                        // Ensure standard MCP response format with content array
                        def actualRes = serviceResult?.result ?: serviceResult
                        if (actualRes instanceof Map && actualRes.content && actualRes.content instanceof List) {
                            result = actualRes
                        } else {
                            result = [ content: [[type: "text", text: new groovy.json.JsonBuilder(actualRes).toString()]], isError: false ]
                        }
                        return
                    }
                    
                    // Handle internal discovery/utility tools
                    def internalToolMappings = [
                        "moqui_search_screens": "McpServices.mcp#SearchScreens"
                    ]
                    
                    def targetServiceName = internalToolMappings[name]
                    if (targetServiceName) {
                        def serviceResult = ec.service.sync().name(targetServiceName).parameters(arguments ?: [:]).call()
                        def actualRes = serviceResult?.result ?: serviceResult
                        // Ensure standard MCP response format with content array
                        if (actualRes instanceof Map && actualRes.content && actualRes.content instanceof List) {
                            result = actualRes
                        } else {
                            result = [ content: [[type: "text", text: new groovy.json.JsonBuilder(actualRes).toString()]], isError: false ]
                        }
                        return
                     }

                    // Fallback: check if it's a general Moqui service (non-screen-based tools)
                    if (ec.service.isServiceDefined(name)) {
                        // Execute service with current user context
                        def serviceResult = ec.service.sync().name(name).parameters(arguments ?: [:]).call()
                        // Convert result to MCP format for general services
                        result = [content: [[type: "text", text: new JsonBuilder(serviceResult).toString()]], isError: false]
                        return
                    }

                    throw new Exception("Unknown tool name: ${name}")
                } catch (Exception e) {
                    isError = true
                    
                    result = [
                        content: [
                            [
                                type: "text",
                                text: "Error executing tool ${name}: ${e.message}"
                            ]
                        ],
                        isError: true
                    ]
                    
                    ec.logger.error("MCP tool execution error", e)
                } finally {
                    // Send a simple notification about tool execution
                    try {
                        def servlet = ec.web.getServletContext().getAttribute("enhancedMcpServlet")
                        if (servlet && sessionId) {
                            def notification = [
                                method: "notifications/tool_execution",
                                params: [
                                    toolName: name,
                                    executionTime: (System.currentTimeMillis() - startTime) / 1000.0,
                                    success: !isError,
                                    timestamp: System.currentTimeMillis()
                                ]
                            ]
                            //servlet.queueNotification(sessionId, notification)
                        }
                    } catch (Exception e) {
                        ec.logger.warn("Failed to send tool execution notification: ${e.message}")
                    }
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesList" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Handle MCP resources/list request with Moqui entity discovery based on user permissions</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def userGroups = ec.user.getUserGroupIdSet().collect { it }
                def availableResources = []
                
                ec.logger.debug("MCP ResourcesList: Discovering entities for user groups: ${userGroups}")
                
                // Use ArtifactAuthzCheckView to find all entities user has permission for
                // This is the "Moqui Way" - rely on the security system to tell us what is accessible
                def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                    .condition("userGroupId", userGroups)
                    .condition("artifactTypeEnumId", "AT_ENTITY")
                    .condition("authzActionEnumId", "AUTHZA_VIEW")
                    .useCache(true)
                    .disableAuthz()
                    .list()
                
                for (def aacv in aacvList) {
                    def entityName = aacv.artifactName
                    // Basic sanity check to ensure entity is actually defined
                    if (ec.entity.isEntityDefined(entityName)) {
                        def description = "Moqui entity: ${entityName}"
                        if (entityName.contains("View")) {
                            description = "Moqui ViewEntity: ${entityName}"
                        }
                        
                        availableResources << [
                            uri: "entity://${entityName}",
                            name: entityName,
                            description: description,
                            mimeType: "application/json"
                        ]
                    }
                }
                
                // Add instructions resource for MCP_USER role
                if (userGroups.contains("McpUser")) {
                    availableResources << [
                        uri: "moqui://mcp/instructions",
                        name: "instructions",
                        description: "MCP server usage instructions",
                        mimeType: "text/plain"
                    ]
                }
                
                result = [resources: availableResources]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="ResourcesRead" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Handle MCP resources/read request with Moqui entity queries</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                def startTime = System.currentTimeMillis()
                
                // Handle special moqui://mcp/instructions resource
                if (uri == "moqui://mcp/instructions") {
                    // Try to load from wiki
                    def instructionsText = null
                    try {
                        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                            .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                            .condition("pagePath", "root")
                            .useCache(true)
                            .one()

                        if (wikiPage) {
                            def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                                .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                                .one()

                            if (wikiSpace) {
                                def pageLocation = wikiSpace.rootPageLocation
                                if (!pageLocation.endsWith('/')) pageLocation += '/'
                                pageLocation += wikiPage.pagePath + '.md'

                                def pageRef = ec.resource.getLocationReference(pageLocation)
                                instructionsText = pageRef?.getText()
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not load instructions from wiki: ${e.message}")
                    }

                    // Fallback to hardcoded instructions
                    if (!instructionsText) {
                        instructionsText = "This server provides access to Moqui ERP through MCP. Use moqui_browse_screens(path='/PopCommerce') to begin. Key screens include: /PopCommerce/Catalog/Product/FindProduct for products, /PopCommerce/Order/FindOrder for orders, and /PopCommerce/Customer for customer management. All screens support parameterized queries for filtering results."
                    }

                    result = [
                        content: [[
                            uri: "moqui://mcp/instructions",
                            mimeType: "text/plain",
                            text: instructionsText
                        ]],
                        isError: false
                    ]
                    return
                }
                
                // Parse entity URI (format: entity://EntityName)
                if (!uri.startsWith("entity://")) {
                    throw new Exception("Invalid resource URI: ${uri}")
                }
                
                def entityName = uri.substring(9)
                
                if (!ec.entity.isEntityDefined(entityName)) {
                    throw new Exception("Entity not found: ${entityName}")
                }
                
                try {
                    def entityDef = null
                    try {
                        def entityInfoList = ec.entity.getAllEntityInfo(-1, true)
                        entityDef = entityInfoList.find { it.entityName == entityName }
                    } catch (Exception e) {
                        ec.logger.debug("Error getting detailed entity info: ${e.message}")
                    }
                    
                    if (!entityDef) {
                        entityDef = [
                            entityName: entityName,
                            packageName: entityName.contains('.') ? entityName.split('\\.')[0] : "",
                            description: "Entity: ${entityName}",
                            isViewEntity: entityName.contains('View'),
                            allFieldInfoList: []
                        ]
                    }
                    
                    // Query entity data
                    def entityList = ec.entity.find(entityName).limit(100).list()
                    
                    // Format response for MCP - create multiple content objects
                    def contentList = []
                    
                    // Add main content with entity data as text
                    contentList << [
                        type: "text",
                        text: new JsonBuilder([
                            entityName: entityName,
                            description: entityDef.description,
                            packageName: entityDef.packageName,
                            recordCount: entityList.size(),
                            data: entityList
                        ]).toString()
                    ]
                    
                    def responseMap = [
                        content: contentList,
                        isError: false
                    ]
                    
                    def jsonOutput = new JsonBuilder(responseMap).toString()
                    
                    // Size protection
                    def maxResponseSize = 1024 * 1024 // 1MB
                    if (jsonOutput.length() > maxResponseSize) {
                         def truncatedList = entityList.take(10)
                         responseMap.data = truncatedList
                         responseMap.truncated = true
                         responseMap.message = "Truncated to 10 records due to size."
                         jsonOutput = new JsonBuilder(responseMap).toString()
                    }
                    
                    result = [
                        content: [[
                            uri: uri,
                            mimeType: "application/json",
                            text: jsonOutput
                        ]],
                        isError: false
                    ]
                    
                } catch (Exception e) {
                    ec.logger.error("Error reading resource ${uri}", e)
                    result = [isError: true, content: [[type:"text", text: e.message]]]
                }
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="Ping" authenticate="true" allow-remote="true" transaction-timeout="10">
        <description>Handle MCP ping request for health check</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
          <script><![CDATA[
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                // Get current user information
                def currentUser = ec.user.username
                def currentUserId = ec.user.userId
                
                // Try to get visit information if sessionId is provided
                def visitInfo = null
                if (sessionId) {
                    try {
                        ec.artifactExecution.disableAuthz()
                        def adminUserInfo = ec.user.pushUser("ADMIN")
                        try {
                            def visit = ec.entity.find("moqui.server.Visit")
                                .condition("visitId", sessionId)
                                .one()
                            
                            if (visit) {
                                visitInfo = [
                                    visitId: visit.visitId,
                                    userId: visit.userId,
                                    fromDate: visit.fromDate,
                                    lastUpdatedStamp: visit.lastUpdatedStamp
                                ]
                            }
                        } finally {
                            ec.user.popUser()
                        }
                        ec.artifactExecution.enableAuthz()
                    } catch (Exception e) {
                        // Log but don't fail the ping
                        ec.logger.warn("Error getting visit info for sessionId ${sessionId}: ${e.message}")
                    }
                }
                
                result = [
                    timestamp: ec.user.getNowTimestamp(),
                    status: "healthy",
                    version: "2.0.2",
                    sessionId: sessionId,
                    currentUser: currentUser,
                    currentUserId: currentUserId,
                    visitInfo: visitInfo,
                    architecture: "Visit-based sessions"
                ]
            ]]></script>
        </actions>
    </service>

    <!-- Debug Service -->
    
    <service verb="debug" noun="ComponentStatus" authenticate="false" allow-remote="true">
        <description>Debug service to verify component is loaded and working</description>
        <in-parameters/>
        <out-parameters>
            <parameter name="status" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.impl.context.UserFacadeImpl.UserInfo
                
                ExecutionContext ec = context.ec
                
                def status = [
                    componentLoaded: true,
                    componentName: "mo-mcp",
                    timestamp: ec.user.getNowTimestamp(),
                    user: ec.user.username,
                    userId: ec.user.userId,
                    serviceNames: ec.service.getKnownServiceNames().findAll { it.contains("Mcp") },
                    entityNames: ec.entity.getAllEntityNames().findAll { it.contains("ArtifactHit") }
                ]
                
                ec.logger.info("=== MCP COMPONENT DEBUG ===")
                ec.logger.info("Component status: ${status}")
                ec.logger.info("All service names count: ${ec.service.getKnownServiceNames().size()}")
                ec.logger.info("All entity names count: ${ec.entity.getAllEntityNames().size()}")
                ec.logger.info("=== END MCP COMPONENT DEBUG ===")
                
                result.status = status
            ]]></script>
        </actions>
    </service>

    <service verb="execute" noun="ScreenAsMcpTool" authenticate="true" allow-remote="true" transaction-timeout="120">
        <description>Execute a screen as an MCP tool</description>
        <in-parameters>
            <parameter name="path" required="true"/>
            <parameter name="parameters" type="Map"><description>Parameters to pass to screen</description></parameter>
            <parameter name="action"><description>Action being processed: if not null, use real screen rendering instead of test mock</description></parameter>
            <parameter name="renderMode" default="mcp"><description>Render mode: mcp, text, html, xml, vuet, qvt</description></parameter>
            <parameter name="sessionId"><description>Session ID for user context restoration</description></parameter>
            <parameter name="terse" type="Boolean" default="false"><description>If true, return condensed data (50 items, 5000 char strings). If false, include full data (1000 items, 50k char strings).</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
import org.moqui.context.ExecutionContext
import groovy.json.JsonBuilder

ExecutionContext ec = context.ec

def startTime = System.currentTimeMillis()

// Set parameters in context
if (parameters) {
    ec.context.putAll(parameters)
}

// Map path parameter to screenPath for consistency
def screenPath = path

// Helper function to get simple path from component path
def getSimplePath = { fullPath ->
    if (!fullPath || fullPath == "root") return "root"
    String cleanPath = fullPath
    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
    List<String> parts = cleanPath.split('/').toList()
    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
    return parts.join('/')
}

// Helper function to load wiki instructions for a screen
def getWikiInstructions = { lookupPath ->
    try {
        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
            .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
            .condition("pagePath", lookupPath)
            .useCache(true)
            .one()

        if (!wikiPage) return null

        def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
            .condition("wikiSpaceId", wikiPage.wikiSpaceId)
            .one()

        if (!wikiSpace) return null

        // Build the resource location for the page
        def pageLocation = wikiSpace.rootPageLocation
        if (!pageLocation.endsWith('/')) {
            pageLocation += '/'
        }
        pageLocation += wikiPage.pagePath + '.md'

        // Get the resource reference and text content
        def pageRef = ec.resource.getLocationReference(pageLocation)
        def wikiText = pageRef?.getText()

        if (wikiText) {
            return wikiText
        }
    } catch (Exception e) {
        ec.logger.debug("Could not load wiki instructions for ${screenPath}: ${e.message}")
    }
    return null
}

// Optimized recursive serializer for Moqui/Java objects to JSON-friendly Map/List
// When terse=true, returns minimal data with truncation metadata for easy access to full version
def serializeMoquiObject
serializeMoquiObject = { obj, depth = 0, isTerse = false ->
    if (depth > 5) return "..." // Prevent deep recursion
    
    if (obj == null) return null
    if (obj instanceof Map) {
        def newMap = [:]
        obj.each { k, v ->
            def keyStr = k.toString()
            // Skip internal framework keys and metadata fields
            if (keyStr.startsWith("_") || keyStr == "ec" || keyStr == "sri") return
            // Skip audit fields to reduce payload
            if (keyStr in ["lastUpdatedStamp", "lastUpdatedTxStamp", "createdDate", "createdTxStamp", "createdByUserLogin"]) return
            def value = serializeMoquiObject(v, depth + 1, isTerse)
            if (value != null) newMap[keyStr] = value
        }
        return newMap
    }
    if (obj instanceof Iterable) {
        def list = obj.collect()
        // Apply truncation only if terse mode is enabled
        if (isTerse && list.size() > 50) {
            ec.logger.info("serializeMoquiObject: Terse mode - truncating list from ${list.size()} to 50 items")
            def truncated = list.take(50)
            def resultList = truncated.collect { serializeMoquiObject(it, depth + 1, isTerse) }
            return [
                _items: resultList,
                _totalCount: list.size(),
                _truncated: true,
                _hasMore: true,
                _message: "Terse mode: showing first 50 of ${list.size()} items. Set terse=false to get full data."
            ]
        }
        // Increased limits for non-terse mode - effectively unlimited for operational use
        def maxItems = isTerse ? 50 : 1000
        def truncated = list.take(maxItems)
        def resultList = truncated.collect { serializeMoquiObject(it, depth + 1, isTerse) }
        if (!isTerse && list.size() > maxItems) {
            ec.logger.info("serializeMoquiObject: Non-terse mode - truncating large list from ${list.size()} to ${maxItems} items for safety")
            return [
                _items: resultList,
                _totalCount: list.size(),
                _truncated: true,
                _hasMore: true,
                _message: "Truncated to ${maxItems} items (size safety limit reached)"
            ]
        }
        return resultList
    }
    if (obj instanceof org.moqui.entity.EntityValue) {
        return serializeMoquiObject(obj.getMap(), depth + 1, isTerse)
    }
    if (obj instanceof java.sql.Timestamp || obj instanceof java.util.Date) {
        return obj.toString()
    }
    if (obj instanceof Number || obj instanceof Boolean) {
        return obj
    }
    if (obj instanceof String) {
        // Apply truncation only if terse mode is enabled
        if (isTerse && obj.length() > 5000) {
            return [
                _value: obj.substring(0, 5000) + "...",
                _fullLength: obj.length(),
                _truncated: true,
                _message: "Terse mode: truncated to 5000 chars. Set terse=false to get more data."
            ]
        }
        // Non-terse limit increased to 50000 for safety
        if (!isTerse && obj.length() > 50000) {
            return [
                _value: obj.substring(0, 50000) + "...",
                _fullLength: obj.length(),
                _truncated: true,
                _message: "Truncated to 50000 chars for safety."
            ]
        }
        return obj
    }
    if (obj.getClass().getName().startsWith("org.moqui.impl.screen.ScreenDefinition")) {
        return [location: obj.location]
    }
    // Skip EntityFind objects entirely - they're query definitions, not actual data
    if (obj instanceof org.moqui.entity.EntityFind) {
        return null
    }
    // Fallback for unknown types - truncate if too long
    def str = obj.toString()
    if (str.length() > 200) {
        return [
            _value: str.substring(0, 200) + "...",
            _fullLength: str.length(),
            _truncated: true
        ]
    }
    return str
}

// Resolve input screen path to simple path for lookup
def inputScreenPath = screenPath
if (screenPath.startsWith("component://")) {
    inputScreenPath = getSimplePath(screenPath)
}
ec.logger.info("MCP Screen Execution: Looking up wiki docs for ${inputScreenPath}")

// Try to get wiki instructions
def wikiInstructions = getWikiInstructions(inputScreenPath)
        
        // Try to render screen content for LLM consumption
        def output = null
        def screenUrl = "http://localhost:8080/${screenPath}"
        def isError = false
        def resolvedScreenDef = null
         
        try {
            ec.logger.info("MCP Screen Execution: Attempting to render screen ${screenPath}")
            
            def rootScreen = "component://webroot/screen/webroot.xml"
            def testScreenPath = screenPath
            
            if (screenPath.startsWith("component://")) {
                // Component path handling
                resolvedScreenDef = ec.screen.getScreenDefinition(screenPath)
                rootScreen = screenPath
                testScreenPath = ""
            } else {
                // Forward slash path handling (e.g. /PopCommerce/Catalog)
                def testPath = screenPath.startsWith('/') ? screenPath : "/" + screenPath
                def pathSegments = []
                testPath.split('/').each { if (it && it.trim()) pathSegments.add(it) }
                
                // 1. Try literal resolution from webroot
                rootScreen = "component://webroot/screen/webroot.xml"
                def webrootSd = ec.screen.getScreenDefinition(rootScreen)
                def screenPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                    webrootSd, webrootSd, pathSegments, testPath, [:], ec.screenFacade
                )
                
                def currentSd = webrootSd
                def reachedIndex = -1
                if (screenPathList) {
                    for (int i = 0; i < screenPathList.size(); i++) {
                        def screenName = screenPathList[i]
                        def ssi = currentSd?.getSubscreensItem(screenName)
                        if (ssi && ssi.getLocation()) {
                            currentSd = ec.screen.getScreenDefinition(ssi.getLocation())
                            reachedIndex = i
                        } else {
                            break
                        }
                    }
                }
                
                // 2. If literal resolution failed, try Component-based resolution
                if (reachedIndex == -1 && pathSegments.size() >= 2) {
                    def componentName = pathSegments[0]
                    def rootScreenName = pathSegments[1]
                    def compRootLoc = "component://${componentName}/screen/${rootScreenName}.xml"
                    
                    if (ec.resource.getLocationReference(compRootLoc).exists) {
                        ec.logger.info("MCP Path Resolution: Found component root at ${compRootLoc}")
                        rootScreen = compRootLoc
                        testScreenPath = pathSegments.size() > 2 ? pathSegments[2..-1].join('/') : ""
                        resolvedScreenDef = ec.screen.getScreenDefinition(rootScreen)
                        
                        // Resolve further if there are remaining segments
                        if (testScreenPath) {
                            def remainingSegments = pathSegments[2..-1]
                            def compPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                                resolvedScreenDef, resolvedScreenDef, remainingSegments, testScreenPath, [:], ec.screenFacade
                            )
                            if (compPathList) {
                                for (String screenName in compPathList) {
                                    def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                    if (ssi && ssi.getLocation()) {
                                        resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                    } else {
                                        break
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 3. Fallback to double-slash search if still not found
                if (reachedIndex == -1 && !resolvedScreenDef && pathSegments.size() > 0 && !testPath.startsWith("//")) {
                    def searchPath = "//" + pathSegments.join('/')
                    ec.logger.info("MCP Path Resolution: Fallback to search path ${searchPath}")
                    
                    rootScreen = "component://webroot/screen/webroot.xml"
                    def searchPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                        webrootSd, webrootSd, pathSegments, searchPath, [:], ec.screenFacade
                    )
                    
                    if (searchPathList) {
                        testScreenPath = searchPath
                        resolvedScreenDef = webrootSd
                        for (String screenName in searchPathList) {
                            def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                            if (ssi && ssi.getLocation()) {
                                resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                            } else {
                                break
                            }
                        }
                    }
                }
                
                // If we found a specific target, we're good. 
                // If not, default to webroot with full path (original behavior, but now we know it failed)
                if (!resolvedScreenDef) {
                    rootScreen = "component://webroot/screen/webroot.xml"
                    resolvedScreenDef = webrootSd
                    testScreenPath = testPath
                }
            }

            // Regular screen rendering with current user context - use our custom ScreenTestImpl
            def screenTest = new org.moqui.mcp.CustomScreenTestImpl(ec.ecfi)
                .rootScreen(rootScreen)
                .renderMode(renderMode ?: "mcp")
                .auth(ec.user.username)

            def renderParams = parameters ?: [:]
            renderParams.userId = ec.user.userId
            renderParams.username = ec.user.username

            def relativePath = testScreenPath
            ec.logger.info("TESTRENDER root=${rootScreen} path=${relativePath} params=${renderParams}")

            def testRender = screenTest.render(relativePath, renderParams, "POST")
            output = testRender.getOutput()

            // --- NEW: Semantic State Extraction ---
            def postContext = testRender.getPostRenderContext()
            def semanticState = [:]
            def isTerse = context.terse == true

            // Get final screen definition using resolved screen location
            def finalScreenDef = resolvedScreenDef

            if (finalScreenDef && postContext) {
                semanticState.screenPath = inputScreenPath
                semanticState.terse = isTerse
                semanticState.data = [:]
                
                // Use the explicit semantic data captured by macros if available
                def explicitData = postContext.get("mcpSemanticData")
                if (explicitData instanceof Map) {
                    explicitData.each { k, v ->
                        semanticState.data[k] = serializeMoquiObject(v, 0, isTerse)
                    }
                }
                
                // Extract transitions (Actions) with type classification and metadata
                semanticState.actions = []
                finalScreenDef.getAllTransitions().each { trans ->
                    def transName = trans.getName()
                    def service = trans.getSingleServiceName()
                    
                    // Classify action type
                    def actionType = "screen-transition"
                    def transNameLower = transName?.toString()?.toLowerCase() ?: ''
                    
                    if (service) {
                        actionType = "service-action"
                    } else if (transNameLower.contains('delete')) {
                        actionType = "delete-action"
                    } else if (transNameLower.startsWith('form') || transNameLower == 'find' || transNameLower == 'search') {
                        actionType = "form-action"
                    }
                    
                    def actionInfo = [
                        name: transName,
                        service: service,
                        type: actionType
                    ]
                    
                    semanticState.actions << actionInfo
                }
                
                // 3. Extract parameters with metadata
                semanticState.parameters = [:]
                if (finalScreenDef.parameterByName) {
                    finalScreenDef.parameterByName.each { name, param ->
                        def value = postContext.get(name) ?: parameters?.get(name)
                        
                        // Build parameter metadata
                        def paramInfo = [:]
                        
                        // Add value if exists
                        if (value != null) {
                            paramInfo.value = serializeMoquiObject(value, 0, isTerse)
                        }
                        
                        // Extract parameter type - try multiple approaches
                        def type = "string"
                        try {
                            // Try to get type via reflection or known properties
                            if (param.hasProperty('type')) {
                                def typeObj = param.type
                                if (typeObj != null) type = typeObj.toString().toLowerCase()
                            } else if (param.hasProperty('parameterType')) {
                                def typeObj = param.parameterType
                                if (typeObj != null) type = typeObj.toString().toLowerCase()
                            }
                        } catch (Exception e) {
                            // Fall back to type inference from value
                        }
                        
                        // Infer type from value if type couldn't be extracted
                        if (type == "string" && value != null) {
                            if (value instanceof Number) {
                                type = (value instanceof Integer || value instanceof Long) ? "long" : "decimal"
                            } else if (value instanceof Boolean) {
                                type = "boolean"
                            } else if (value instanceof Collection || value instanceof Map) {
                                type = (value instanceof Collection) ? "list" : "map"
                            }
                        }
                        paramInfo.type = type
                        
                        // Extract required flag - defensive check
                        paramInfo.required = false
                        try {
                            if (param.hasProperty('required')) {
                                paramInfo.required = (param.required == true)
                            }
                        } catch (Exception e) {
                            // Skip if property doesn't exist
                        }
                        
                        // Extract default value - defensive check
                        try {
                            if (param.hasProperty('defaultValue') && param.defaultValue != null) {
                                paramInfo.defaultValue = param.defaultValue.toString()
                            }
                        } catch (Exception e) {
                            // Skip if property doesn't exist
                        }
                        
                        semanticState.parameters[name] = paramInfo
                    }
                }
                
                // Log semantic state size for optimization tracking
                def semanticStateJson = new groovy.json.JsonBuilder(semanticState).toString()
                def semanticStateSize = semanticStateJson.length()
                ec.logger.info("MCP Screen Execution: Semantic state size: ${semanticStateSize} bytes, data keys: ${semanticState.data.keySet()}, actions count: ${semanticState.actions.size()}, terse=${isTerse}")
            }
            
            ec.logger.info("MCP Screen Execution: Successfully rendered screen ${screenPath}, output length: ${output?.length() ?: 0}")

            def executionTime = (System.currentTimeMillis() - startTime) / 1000.0
            
            // Build result based on renderMode
            def content = []
            if ((renderMode == "mcp" || renderMode == "json") && semanticState) {
                // Return structured MCP data
                def mcpResult = [
                    screenPath: screenPath,
                    screenUrl: screenUrl,
                    executionTime: executionTime,
                    isError: isError,
                    semanticState: semanticState
                ]
                
                // Truncate text preview only if terse=true
                if (output) {
                    if (isTerse) {
                        mcpResult.textPreview = output.take(500) + (output.length() > 500 ? "..." : "")
                    } else {
                        mcpResult.textPreview = output
                    }
                }
                if (wikiInstructions) mcpResult.wikiInstructions = wikiInstructions
                
                content << [
                    type: "text",
                    text: new groovy.json.JsonBuilder(mcpResult).toString()
                ]
            } else {
                // Return raw output for other modes (text, html, etc)
                def textOutput = output
                if (wikiInstructions) {
                    textOutput = "--- Wiki Instructions ---\n\n${wikiInstructions}\n\n--- Screen Output ---\n\n${output}"
                }
                content << [
                    type: "text",
                    text: textOutput,
                    screenPath: screenPath,
                    screenUrl: screenUrl,
                    executionTime: executionTime,
                    isError: isError
                ]
            }
            
            result = [
                content: content,
                isError: false
            ]
            return // Success!

        } catch (Exception e) {
            isError = true
            ec.logger.error("MCP Screen Execution: Full exception for ${screenPath}", e)
            output = "SCREEN RENDERING ERROR: ${e.message}"
            result = [
                isError: true,
                content: [[type: "text", text: output]]
            ]
        }
    ]]></script>
</actions>
</service>

    <service verb="mcp" noun="ResourcesTemplatesList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/templates/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // For now, return empty templates list - can be extended later
                def templates = []
                
                result = [resourceTemplates: templates]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ResourcesSubscribe" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/subscribe request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"><description>Resource URI to subscribe to</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Resource subscription requested for URI: ${uri}, sessionId: ${sessionId}")
                
                // For now, just return success - actual subscription tracking could be added
                result = [subscribed: true, uri: uri]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ResourcesUnsubscribe" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP resources/unsubscribe request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="uri" required="true"><description>Resource URI to unsubscribe from</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Resource unsubscription requested for URI: ${uri}, sessionId: ${sessionId}")
                
                // For now, just return success - actual subscription tracking could be added
                result = [unsubscribed: true, uri: uri]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="PromptsList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP prompts/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.json.JsonSlurper
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("MCP PromptsList: Listing prompts from wiki space MCP_PROMPTS")
                
                def prompts = []
                
                // Query all wiki pages in MCP_PROMPTS space
                def wikiPageList = ec.entity.find("moqui.resource.wiki.WikiPage")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .useCache(true)
                    .list()
                
                for (def wp in wikiPageList) {
                    // Try to load argument schema from attachment
                    def arguments = []
                    try {
                        def attachment = ec.entity.find("moqui.resource.wiki.WikiPageAttachment")
                            .condition("wikiPageId", wp.wikiPageId)
                            .condition("filename", "arguments.json")
                            .one()
                        if (attachment) {
                            def attachmentRef = ec.resource.getLocationReference(attachment.getLocation())
                            def jsonText = attachmentRef?.getText()
                            if (jsonText) {
                                arguments = new JsonSlurper().parseText(jsonText) ?: []
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.debug("Could not parse arguments for ${wp.pagePath}: ${e.message}")
                    }
                    
                    prompts << [
                        name: wp.pagePath,
                        title: wp.pagePath.split('-').collect { it.capitalize() }.join(' '),
                        description: "MCP prompt template",
                        arguments: arguments
                    ]
                }
                
                result = [prompts: prompts]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="PromptsGet" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP prompts/get request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="name" required="true"><description>Prompt name to retrieve</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import groovy.text.GStringTemplateEngine
                import groovy.json.JsonSlurper
                import groovy.json.JsonBuilder
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("MCP PromptsGet: Retrieving prompt '${name}' from wiki space MCP_PROMPTS")
                
                // Get the wiki page for this prompt
                def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .condition("pagePath", name)
                    .one()
                
                if (!wikiPage) {
                    throw new Exception("Prompt not found: ${name}")
                }
                
                // Get the wiki space to build the page location
                def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                    .condition("wikiSpaceId", "MCP_PROMPTS")
                    .one()
                
                if (!wikiSpace) {
                    throw new Exception("MCP Prompts wiki space not found")
                }
                
                // Build the resource location for the page (root + page path + .md)
                def pageLocation = wikiSpace.rootPageLocation
                if (!pageLocation.endsWith('/')) {
                    pageLocation += '/'
                }
                pageLocation += name + '.md'
                
                // Get the resource reference and text content
                def pageRef = ec.resource.getLocationReference(pageLocation)
                def templateText = pageRef?.getText()
                
                if (!templateText) {
                    throw new Exception("Prompt template not found: ${name}")
                }
                
                // Render template using Groovy GString engine
                def templateEngine = new GStringTemplateEngine()
                def template = templateEngine.createTemplate(templateText)
                def binding = arguments ?: [:]
                def rendered = template.make(binding).toString()
                
                ec.logger.info("MCP PromptsGet: Rendered prompt '${name}' with ${binding.size()} arguments")
                
                result = [
                    description: "MCP prompt template",
                    messages: [[
                        role: "user",
                        content: [type: "text", text: rendered]
                    ]]
                ]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="RootsList" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP roots/list request</description>
        <in-parameters>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                // For now, return empty roots list - can be extended later
                def roots = []
                
                result = [roots: roots]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="SamplingCreateMessage" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP sampling/createMessage request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="messages" type="List"><description>List of messages to sample</description></parameter>
            <parameter name="maxTokens" type="Integer"><description>Maximum tokens to generate</description></parameter>
            <parameter name="temperature" type="BigDecimal"><description>Sampling temperature</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Sampling createMessage requested for sessionId: ${sessionId}")
                
                // For now, return not implemented - can be extended with actual LLM integration
                result = [error: "Sampling not implemented"]
            ]]></script>
        </actions>
    </service>
    
    <service verb="mcp" noun="ElicitationCreate" authenticate="false" allow-remote="true" transaction-timeout="30">
        <description>Handle MCP elicitation/create request</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="prompt"><description>Prompt for elicitation</description></parameter>
            <parameter name="context"><description>Context for elicitation</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                ec.logger.info("Elicitation create requested for sessionId: ${sessionId}")
                
                // For now, return not implemented - can be extended later
                result = [error: "Elicitation not implemented"]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="BrowseScreens" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Browse Moqui screens hierarchically to discover functionality. Renders screen content with renderMode='mcp' by default. Supports action parameter for form submission and transitions.</description>
        <in-parameters>
            <parameter name="path" required="false"><description>Screen path to browse (e.g. 'PopCommerce'). Leave empty for root apps.</description></parameter>
            <parameter name="action"><description>Action to process before rendering: null (browse), 'submit' (form), 'create', 'update', or transition name</description></parameter>
            <parameter name="renderMode" default="mcp"><description>Render mode: mcp (default), text, html, xml, vuet, qvt</description></parameter>
            <parameter name="parameters" type="Map"><description>Parameters to pass to screen during rendering or action</description></parameter>
            <parameter name="sessionId"/>
            <parameter name="terse" type="Boolean" default="false"><description>If true, return condensed data (50 items, 5000 char strings). If false, include full data (1000 items, 50k char strings).</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext

                ExecutionContext ec = context.ec
                ec.logger.info("BrowseScreens: SERVICE STARTED")
                def subscreens = []
                def currentPath = path ?: "root"
                def userGroups = ec.user.getUserGroupIdSet().collect { it }

                // Strip query parameters from path for screen resolution
                if (currentPath.contains("?")) {
                    currentPath = currentPath.split("\\?")[0]
                }
                
                // Helper function to load wiki content
                def loadWikiContent = { path ->
                    ec.logger.info("BrowseScreens: loadWikiContent CALLED for ${path}")
                    try {
                        def simplePath = (path == "root") ? "root" : path
                        if (simplePath.contains("?")) {
                            simplePath = simplePath.split("\\?")[0]
                        }

                        ec.logger.info("BrowseScreens: Looking up wiki instructions for ${simplePath}")

                        def wikiPage = ec.entity.find("moqui.resource.wiki.WikiPage")
                            .condition("wikiSpaceId", "MCP_SCREEN_DOCS")
                            .condition("pagePath", simplePath)
                            .useCache(true)
                            .one()

                        if (wikiPage) {
                            ec.logger.info("BrowseScreens: Found wikiPage: ${wikiPage.pagePath}")
                            def wikiSpace = ec.entity.find("moqui.resource.wiki.WikiSpace")
                                .condition("wikiSpaceId", wikiPage.wikiSpaceId)
                                .one()

                            if (wikiSpace) {
                                ec.logger.info("BrowseScreens: Found wikiSpace: ${wikiSpace.wikiSpaceId}")

                                def dbResource = ec.entity.find("moqui.resource.DbResource")
                                    .condition("parentResourceId", "WIKI_MCP_SCREEN_DOCS")
                                    .condition("filename", wikiPage.pagePath + ".md")
                                    .one()

                                if (dbResource) {
                                    ec.logger.info("BrowseScreens: Found dbResource: ${dbResource.resourceId}")
                                    def dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                        .condition("resourceId", dbResource.resourceId)
                                        .condition("versionName", wikiPage.publishedVersionName)
                                        .one()

                                    ec.logger.info("BrowseScreens: dbResourceFile query result: ${dbResourceFile ? 'found' : 'null'}")

                                    if (!dbResourceFile) {
                                        dbResourceFile = ec.entity.find("moqui.resource.DbResourceFile")
                                            .condition("resourceId", dbResource.resourceId)
                                            .one()
                                        ec.logger.info("BrowseScreens: dbResourceFile fallback query result: ${dbResourceFile ? 'found' : 'null'}")
                                    }

                                    if (dbResourceFile) {
                                        ec.logger.info("BrowseScreens: dbResourceFile.fileData: ${dbResourceFile.fileData ? 'exists, size=' + dbResourceFile.fileData.length() : 'null'}")
                                    }

                                    if (dbResourceFile && dbResourceFile.fileData) {
                                        def content = new String(dbResourceFile.fileData.getBytes(new Long(1).longValue(), new Long(dbResourceFile.fileData.length()).intValue()), "UTF-8")
                                        ec.logger.info("BrowseScreens: Found wiki instructions for ${simplePath}, length: ${content?.length()}")
                                        return content
                                    }
                                } else {
                                    ec.logger.warn("BrowseScreens: No dbResource found for ${wikiPage.pagePath}.md")
                                }
                            }
                        }
                    } catch (Exception e) {
                        ec.logger.warn("BrowseScreens: Error getting wiki instructions: ${e.message}")
                    }
                    return null
                }

                // Helper to convert full component path to simple path (PopCommerce/screen/Root.xml -> PopCommerce/Root)
                def convertToSimplePath = { fullPath ->
                    if (!fullPath) return null
                    String cleanPath = fullPath
                    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
                    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
                    List<String> parts = cleanPath.split('/').toList()
                    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
                    return parts.join('/')
                }

                // Helper to extract short description from wiki content
                def getShortDescription = { wikiText ->
                    if (!wikiText) return null
                    def textString = wikiText instanceof String ? wikiText : new String(wikiText, "UTF-8")
                    def lines = textString.split('\n')
                    for (def line : lines) {
                        if (line.trim() && !line.trim().startsWith('#')) {
                            return line.trim().take(200)
                        }
                    }
                    return null
                }

                def resolvedScreenDef = null
                if (currentPath == "root") {
                    // Discover top-level applications
                    def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                        .condition("userGroupId", userGroups)
                        .condition("artifactTypeEnumId", "AT_XML_SCREEN")
                        .useCache(true)
                        .disableAuthz()
                        .list()
                        
                    def rootScreens = new HashSet()
                    for (def aacv in aacvList) {
                        def name = aacv.artifactName
                        if (name.startsWith("component://") && name.endsWith(".xml")) {
                            def parts = name.substring(12).split('/')
                            if (parts.length >= 3 && parts[1] == "screen") {
                                def filename = parts[parts.length - 1]
                                def componentName = parts[0]
                                if (filename == componentName + ".xml" || filename == componentName + "Admin.xml" || filename == componentName + "Root.xml" || filename == "webroot.xml") {
                                    rootScreens.add(name)
                                }
                            }
                        }
                    }
                    
                    for (def screenPath in rootScreens) {
                        def simplePath = convertToSimplePath(screenPath)
                        def wikiContent = loadWikiContent(simplePath)
                        def description = wikiContent ? getShortDescription(wikiContent) : "Application: ${simplePath}"
                        subscreens << [
                            path: simplePath,
                            description: description
                        ]
                    }
                } else {
                    // Forward slash path resolution using Moqui standard with robust component-based fallback
                    def webrootSd = ec.screen.getScreenDefinition("component://webroot/screen/webroot.xml")
                    def pathSegments = []
                    currentPath.split('/').each { if (it && it.trim()) pathSegments.add(it) }
                    
                    // 1. Try literal resolution from webroot
                    def screenPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                        webrootSd, webrootSd, pathSegments, currentPath, [:], ec.screenFacade
                    )
                    
                    def currentSd = webrootSd
                    def reachedIndex = -1
                    if (screenPathList) {
                        for (int i = 0; i < screenPathList.size(); i++) {
                            def screenName = screenPathList[i]
                            def ssi = currentSd?.getSubscreensItem(screenName)
                            if (ssi && ssi.getLocation()) {
                                currentSd = ec.screen.getScreenDefinition(ssi.getLocation())
                                reachedIndex = i
                            } else {
                                break
                            }
                        }
                    }
                    
                    resolvedScreenDef = currentSd

                    // 2. If literal resolution failed, try Component-based resolution
                    if (reachedIndex == -1 && pathSegments.size() >= 2) {
                        def componentName = pathSegments[0]
                        def rootScreenName = pathSegments[1]
                        def compRootLoc = "component://${componentName}/screen/${rootScreenName}.xml"
                        
                        if (ec.resource.getLocationReference(compRootLoc).exists) {
                            ec.logger.info("BrowseScreens Path Resolution: Found component root at ${compRootLoc}")
                            resolvedScreenDef = ec.screen.getScreenDefinition(compRootLoc)
                            def subScreenPath = pathSegments.size() > 2 ? pathSegments[2..-1].join('/') : ""
                            
                            // Resolve further if there are remaining segments
                            if (subScreenPath) {
                                def remainingSegments = pathSegments[2..-1]
                                def compPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                                    resolvedScreenDef, resolvedScreenDef, remainingSegments, subScreenPath, [:], ec.screenFacade
                                )
                                if (compPathList) {
                                    for (String screenName in compPathList) {
                                        def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                        if (ssi && ssi.getLocation()) {
                                            resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                        } else {
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // 3. Fallback to double-slash search if still not found
                    if (reachedIndex == -1 && resolvedScreenDef == webrootSd && pathSegments.size() > 0 && !currentPath.startsWith("//")) {
                        def searchPath = "//" + pathSegments.join('/')
                        ec.logger.info("BrowseScreens Path Resolution: Fallback to search path ${searchPath}")
                        
                        def searchPathList = org.moqui.impl.screen.ScreenUrlInfo.parseSubScreenPath(
                            webrootSd, webrootSd, pathSegments, searchPath, [:], ec.screenFacade
                        )
                        
                        if (searchPathList) {
                            resolvedScreenDef = webrootSd
                            for (String screenName in searchPathList) {
                                def ssi = resolvedScreenDef?.getSubscreensItem(screenName)
                                if (ssi && ssi.getLocation()) {
                                    resolvedScreenDef = ec.screen.getScreenDefinition(ssi.getLocation())
                                } else {
                                    break
                                }
                            }
                        }
                    }

                    if (resolvedScreenDef) {
                        resolvedScreenDef.getSubscreensItemsSorted().each { subItem ->
                            def subName = subItem.getName()
                            def subPath = currentPath + "/" + subName
                            def wikiContent = loadWikiContent(subPath)
                            subscreens << [
                                path: subPath,
                                description: wikiContent ? getShortDescription(wikiContent) : "Subscreen: ${subName}"
                            ]
                        }
                    }
                }
                
                // Process action before rendering
                def actionResult = null
                def actionError = null
                
                if (action && resolvedScreenDef) {
                    try {
                        ec.logger.info("BrowseScreens: Executing action '${action}' on ${currentPath}")
                        def actionParams = parameters ?: [:]
                        
                        if (action == "submit") {
                            actionResult = [
                                action: "submit",
                                status: "success",
                                message: "Form parameters submitted",
                                parametersProcessed: actionParams.keySet()
                            ]
                        } else {
                            def foundTransition = resolvedScreenDef.getAllTransitions().find { it.getName() == action }
                            
                            if (foundTransition) {
                                def serviceName = foundTransition.getSingleServiceName()
                                
                                if (serviceName) {
                                    ec.logger.info("BrowseScreens: Executing service: ${serviceName}")
                                    def serviceCallResult = ec.service.sync().name(serviceName).parameters(actionParams).call()
                                    actionResult = [
                                        action: action,
                                        status: "executed",
                                        message: "Executed service ${serviceName}",
                                        result: serviceCallResult
                                    ]
                                } else {
                                    actionResult = [
                                        action: action,
                                        status: "success",
                                        message: "Transition '${action}' found"
                                    ]
                                }
                            } else {
                                // Fallback: check if it's a CRUD convention action for mantle entities
                                def actionPrefix = action.size() > 6 ? action.take(6) : ""
                                if (actionPrefix in ['create', 'update', 'delete']) {
                                    // Try to infer entity from screen context or parameters
                                    actionResult = [status: "error", message: "Dynamic CRUD not implemented without transition"]
                                } else {
                                    actionError = "Transition '${action}' not found on screen ${currentPath}"
                                }
                            }
                        }
                    } catch (Exception e) {
                        actionError = "Action execution failed: ${e.message}"
                    }
                }
                
                // Try to get wiki instructions for screen
                def wikiInstructions = null

                ec.logger.info("BrowseScreens: About to check wiki instructions, currentPath='${currentPath}', isRoot=${currentPath == 'root'}")

                wikiInstructions = loadWikiContent(currentPath)

                // Render current screen if not root browsing
                def renderedContent = null
                def renderError = null
                def actualRenderMode = renderMode ?: "mcp"

                def resultMap = [
                    currentPath: currentPath,
                    subscreens: subscreens,
                    renderMode: actualRenderMode
                ]

                if (currentPath != "root") {
                    try {
                        ec.logger.info("BrowseScreens: Rendering screen ${currentPath} with mode=${actualRenderMode}")

                        // Pass forward-slash path directly to ScreenAsMcpTool
                        // ScreenAsMcpTool will use Moqui's ScreenUrlInfo.parseSubScreenPath to navigate through screen hierarchy
                        def browseScreenCallParams = [
                            path: path,
                            parameters: parameters ?: [:],
                            renderMode: actualRenderMode,
                            sessionId: sessionId,
                            terse: context.terse == true
                        ]

                        // Call ScreenAsMcpTool to render
                        def browseResult = ec.service.sync().name("McpServices.execute#ScreenAsMcpTool")
                            .parameters(browseScreenCallParams)
                            .call()

                        // Extract rendered content and semantic state from result
                        if (browseResult) {
                            def resultObj = null
                            // ScreenAsMcpTool returns {result: {content: [...]}}
                            if (browseResult.result) {
                                def contentList = browseResult.result.content
                                if (contentList && contentList.size() > 0) {
                                    def rawText = contentList[0].text
                                    if (rawText && rawText.startsWith("{")) {
                                        try { resultObj = new groovy.json.JsonSlurper().parseText(rawText) } catch(e) {}
                                    }
                                    renderedContent = rawText
                                }
                            }

                            if (resultObj && resultObj.semanticState) {
                                resultMap.semanticState = resultObj.semanticState

                                // Build UI narrative for LLM guidance
                                try {
                                    def narrativeBuilder = new org.moqui.mcp.UiNarrativeBuilder()
                                    // Use the screen definition we already resolved
                                    def screenDefForNarrative = resolvedScreenDef

                                    def uiNarrative = narrativeBuilder.buildNarrative(
                                        screenDefForNarrative,
                                        resultObj.semanticState,
                                        currentPath,
                                        context.terse == true
                                    )
                                    resultMap.uiNarrative = uiNarrative
                                    ec.logger.info("BrowseScreens: Generated UI narrative for ${currentPath}: ${uiNarrative?.keySet()}")
                                } catch (Exception e) {
                                    ec.logger.warn("BrowseScreens: Failed to generate UI narrative: ${e.message}")
                                }
                            }
                        }

                        ec.logger.info("BrowseScreens: Successfully rendered screen ${currentPath}, content length: ${renderedContent?.length() ?: 0}")
                    } catch (Exception e) {
                        renderError = "Screen rendering failed: ${e.message}"
                        ec.logger.warn("BrowseScreens render error for ${currentPath}: ${e.message}")
                    }
                }
                
                if (actionResult) {
                    resultMap.actionResult = actionResult
                }

                // Don't include renderedContent for renderMode "mcp" - semanticState provides structured data
                // Including both duplicates data and truncation breaks JSON structure
                if (renderedContent && actualRenderMode != "mcp") {
                    resultMap.renderedContent = renderedContent
                }
                
                if (actionError) {
                    resultMap.actionError = actionError
                }

                if (wikiInstructions) {
                    resultMap.wikiInstructions = wikiInstructions
                }

                if (renderError) {
                    resultMap.renderError = renderError
                }
                
                // Return in MCP format - content array as direct child of result
                result = [
                    content: [[type: "text", text: new groovy.json.JsonBuilder(resultMap).toString()]],
                    isError: false
                ]
            ]]></script>
        </actions>
    </service>

    <service verb="mcp" noun="SearchScreens" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>Search for screens by name or path.</description>
        <in-parameters>
            <parameter name="query" required="true"/>
            <parameter name="sessionId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                def matches = []
                
                // Helper to convert full component path to simple forward-slash path
                def convertToSimplePath = { fullPath ->
                    if (!fullPath) return null
                    String cleanPath = fullPath
                    if (cleanPath.startsWith("component://")) cleanPath = cleanPath.substring(12)
                    if (cleanPath.endsWith(".xml")) cleanPath = cleanPath.substring(0, cleanPath.length() - 4)
                    List<String> parts = cleanPath.split('/').toList()
                    if (parts.size() > 1 && parts[1] == "screen") parts.remove(1)
                    return parts.join('/')
                }

                // Search all screens known to the system
                def aacvList = ec.entity.find("moqui.security.ArtifactAuthzCheckView")
                    .condition("artifactTypeEnumId", "AT_XML_SCREEN")
                    .condition("artifactName", "like", "%${query}%")
                    .selectField("artifactName")
                    .distinct(true)
                    .disableAuthz()
                    .limit(20)
                    .list()
                
                for (hit in aacvList) {
                    def simplePath = convertToSimplePath(hit.artifactName)
                    if (simplePath) {
                        matches << [
                            path: simplePath,
                            description: "Screen: ${hit.artifactName}"
                        ]
                    }
                }
                
                result = [matches: matches]
            ]]></script>
        </actions>
    </service>

    <service verb="list" noun="Tools" authenticate="false" allow-remote="true" transaction-timeout="60">
        <description>List discovery tools and the unified screen renderer.</description>
        <in-parameters>
            <parameter name="sessionId"/>
            <parameter name="cursor"/>
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map"/>
        </out-parameters>
        <actions>
            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                
                ExecutionContext ec = context.ec
                
                def tools = [
                    [
                        name: "moqui_browse_screens",
                        title: "Browse Screens",
                        description: "Browse Moqui screen hierarchy, process actions, and render screen content. Input 'path' (empty for root). Default renderMode is 'mcp'.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "path": [type: "string", description: "Path to browse (e.g. 'PopCommerce')"],
                                "action": [type: "string", description: "Action to process before rendering: null (browse), 'submit' (form), 'create', 'update', or transition name"],
                                "renderMode": [type: "string", description: "Render mode: mcp (default), text, html, xml, vuet, qvt"],
                                "parameters": [type: "object", description: "Parameters to pass to screen during rendering or action"],
                                "terse": [type: "boolean", description: "If true, return minimal data (10 items, 200 chars strings). If false, include full data (50 items). Default: false"]
                            ]
                        ]
                    ],
                    [
                        name: "moqui_search_screens",
                        title: "Search Screens",
                        description: "Search for screens by name to find their paths.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "query": [type: "string", description: "Search query"]
                            ],
                            required: ["query"]
                        ]
                     ],
                     [
                        name: "prompts_list",
                        title: "List Prompts",
                        description: "List available MCP prompt templates.",
                        inputSchema: [
                            type: "object",
                            properties: [:]
                        ]
                    ],
                    [
                        name: "prompts_get",
                        title: "Get Prompt",
                        description: "Retrieve and render a specific MCP prompt template.",
                        inputSchema: [
                            type: "object",
                            properties: [
                                "name": [type: "string", description: "Prompt name"],
                                "arguments": [type: "object", description: "Arguments for prompt template"]
                            ],
                            required: ["name"]
                        ]
                    ]
                ]
                
                result = [tools: tools]
            ]]></script>
        </actions>
    </service>

    <!-- NOTE: handle#McpRequest service removed - functionality moved to screen/webapp.xml for unified handling -->

</services>